<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: Linux - BONESKEEP&#039; BLOG</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="BONESKEEP&#039; BLOG"><meta name="msapplication-TileImage" content="/img/headlogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="BONESKEEP&#039; BLOG"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="BONESKEEP_BLOG"><meta property="og:type" content="blog"><meta property="og:title" content="BONESKEEP&#039; BLOG"><meta property="og:url" content="https://boneskeep.github.io/"><meta property="og:site_name" content="BONESKEEP&#039; BLOG"><meta property="og:description" content="BONESKEEP_BLOG"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://boneskeep.github.io/img/og_image.png"><meta property="article:author" content="BONESKEEP"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://boneskeep.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://boneskeep.github.io"},"headline":"BONESKEEP' BLOG","image":["https://boneskeep.github.io/img/og_image.png"],"author":{"@type":"Person","name":"BONESKEEP"},"publisher":{"@type":"Organization","name":"BONESKEEP' BLOG","logo":{"@type":"ImageObject","url":"https://boneskeep.github.io/img/head_circle.png"}},"description":"BONESKEEP_BLOG"}</script><link rel="icon" href="/img/headlogo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head_circle.png" alt="BONESKEEP&#039; BLOG" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/BONESKEEP">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/BONESKEEP/BONESKEEP.github.io"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">分类</a></li><li class="is-active"><a href="#" aria-current="page">Linux</a></li></ul></nav></div></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/09/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="通讯协议总结"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-09T11:00:00.000Z" title="2025/1/9 19:00:00">2025-01-09</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:15:38.732Z" title="2025/3/24 23:15:38">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">25 分钟读完 (大约3779个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/09/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/">通讯协议总结</a></p><div class="content"><h3 id="通讯协议总结"><a href="#通讯协议总结" class="headerlink" title="通讯协议总结"></a>通讯协议总结</h3><hr>
<p>原贴：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45726161/article/details/146225631">https://blog.csdn.net/weixin_45726161/article/details/146225631</a></p>
<hr>
<p><strong>1. 串口通信</strong></p>
<p>简介：<strong>成本低、容易使用、线路简单</strong>，可实现两个设备的互相通信。</p>
<p><strong>原理</strong>：简单双向串口通信 有<strong>两根通信线（发送端TX和接收端RX）</strong>，TX和RX交叉连接，只需单项数据传输时可只接一根通信线。</p>
<img src="https://i-blog.csdnimg.cn/direct/45fe94161a304cb1a28fe29f19ac8a74.png" alt="img" style="zoom:67%;" />

<p>电平标准：<strong>不同设备可能使用不同电平标准，电平不匹配时需要电平转换芯片进行适配</strong>。</p>
<table>
<thead>
<tr>
<th align="center">电平标准</th>
<th align="center">电压范围</th>
<th align="center">常用设备</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TTL电平</td>
<td align="center">+3.3V 或 +5V 表示 1, 0V表示 0</td>
<td align="center">单片机和嵌入式设备</td>
</tr>
<tr>
<td align="center">RS-232电平</td>
<td align="center">-3V<del>-15V 表示 1，+3V</del>+15V 表示 0</td>
<td align="center">传统 PC 串口通信</td>
</tr>
<tr>
<td align="center">RS-485电平</td>
<td align="center">两线压差 +2V<del>+6V 表示 1，-2V</del>-6V 表示 0</td>
<td align="center">采用差分信号，抗干扰强，适用工业总线</td>
</tr>
</tbody></table>
<p>不同电平标准的设备通信时，可使用 MAX232（TTL ↔ RS232） 或 MAX485（TTL ↔ RS485） 等电平转换芯片。</p>
<p><strong>串口参数及时序</strong>：</p>
<ol>
<li><strong>波特率</strong>：串口通信的速率（发送和接收约定好速率），决定每隔多久发送一位（或者每秒传输的bit位数），单位为bps（bits per second，位&#x2F;秒）。例如<strong>9600 bps：每秒传输 9600 个 bit，或者传输一个bit需要1&#x2F;9600s。</strong></li>
<li><strong>起始位</strong>：标志一个数据帧的<strong>开始</strong>，<strong>固定为低电平</strong>；因为<strong>空闲状态是低电平</strong>。</li>
<li><strong>数据位</strong>：<strong>数据帧的有效载荷</strong>，<strong>1为高电平，0为低电平</strong>，<strong>低位先行，左边为低位。</strong></li>
<li><strong>校验位</strong>：用于数据验证，根据数据位计算得来；<strong>校验位为0或1</strong>，具体校验位的值根据奇校验还是偶校验得出（<strong>奇校验：保证数据位1的个数为奇数</strong>；<strong>偶校验：保证数据位1的个数是偶数</strong>）</li>
<li><strong>停止位</strong>：用于数据帧间隔，<strong>固定为高电平</strong>，为下一帧的起始位低电平准备</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/c789c5768c60451f9fb2abd3b87f373c.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/0efe549cc183431f8bfabb103fc9697e.png" alt="img"></p>
<hr>
<p><strong>2. UART(USART)</strong></p>
<p><strong>UART</strong>（通用异步收发传输） 和 USART（通用同步&#x2F;异步收发传输） 是<strong>串口通信的一种实现方式</strong>，其基本<strong>原理与串口通信一致</strong>。</p>
<p>其中<strong>UART 是一种常见的串行通信方式</strong>，广泛应用于<strong>RS-232、RS-422、RS-485 及 TTL 电平通信</strong>。</p>
<p><strong>RS-232 采用点对点通信</strong>模式，仅支持两个设备直接连接，适用于<strong>短距离、本地设备</strong>间的<strong>全双工通信</strong>。</p>
<p><strong>RS-485 支持多设备总线通信</strong>，具备<strong>较长的传输距离和较强的抗干扰能力</strong>，但通常<strong>采用半双工通信模式</strong>。</p>
<hr>
<p><strong>3. I2C</strong></p>
<p>简介：<strong>串行</strong>数据总线，一根是<strong>双向的数据线SDA</strong>,一根是<strong>时钟线SCL</strong>。两条线可以挂多个设备，一般IIC设备里有个<strong>固化的地址</strong>，只有传输对应固化地址时才会响应。<strong>基本谁控制时钟线谁就是主设备</strong>。</p>
<p>I2C优缺点：</p>
<p>​	优点：<strong>硬件资源节约</strong>，协议设计精巧，易用，使用广泛易移植。</p>
<p>​	缺点：<strong>传输速率较慢</strong>。<br><strong>原理：</strong>两根通信线：<strong>时钟线SCL</strong>（Serial Clock）、<strong>数据线SDA</strong>（Serial Data），工作模式为<strong>同步</strong>（双方有时钟线SCL），<strong>半双工</strong>，带<strong>数据应答</strong>，支持总线挂载多设备（一主多从、多主多从），<strong>数据位一般7位或10位</strong>。</p>
<p>所有I2C设备的时钟线SCL连在一起，SDA连在一起设备的SCL和SDA均要配置成<strong>开漏输出模式</strong>；SCL和SDA<strong>各添加一个上拉电阻</strong>，阻值一般为4.7KΩ左右。<strong>从设备下拉</strong>，总线处于<strong>低电平</strong>；<strong>从设备放开</strong>，从设备相当于浮空，但<strong>由于上拉电阻</strong>作用，总线处于<strong>高电平</strong>。<strong>只要有一个从设备下拉，总线就处于低电平</strong>。<br><img src="https://i-blog.csdnimg.cn/direct/cd39ffc1ff3a49a18049457288d7d4cf.png" alt="img"></p>
<p><strong>时序：</strong></p>
<p>初始化：SCL SDA均为高。</p>
<p>开始信号：SCL保持高电平，SDA由高变低，SCL拉低。</p>
<p>停止信号：SCL拉高，SDA由低变高。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/c2638249fe6f4dceb1258c84d40a9a50.png" alt="img"></p>
<p><strong>（1）主机发送一个字节</strong>——SCL低电平发数据 SCL高电平读数据</p>
<p>SCL低电平期间，主机将数据位依次放到SDA线上（<strong>高位先行</strong>），然后释放SCL，<strong>从机将在SCL高电平期间读取数据位</strong>，所以<strong>SCL高电平期间SDA不允许有数据变化</strong>，<strong>依次循环上述过程8次</strong>，<strong>即可发送一个字节</strong>。SCL低电平的时候发送一方通过拉低或者释放SDA发送0或者1，SCL释放处于高电平的时候SDA不允许有数据变化。<br><img src="https://i-blog.csdnimg.cn/direct/c4d0f6fb3f0c452fbbfb1d1f3b8ecbe7.png" alt="img"></p>
<p><strong>（2）主机接收一个字节</strong>——主机在接收前要释放SDA给从机，从机获得发送权</p>
<p>SCL低电平期间，从机将数据位依次放到SDA线上（<strong>高位先行</strong>），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节<strong>（主机在接收之前，需要释放SDA，意思就是让从机获得发送权）。</strong></p>
<p><strong>（3）发送应答</strong>——接收后发送应答数据</p>
<p>主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答</p>
<p><strong>（4）接收应答</strong>——发送后接收应答数据</p>
<p>主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答<strong>（主机在接收之前，需要释放SDA，释放相当于放手SDA处于高电平，要不然SDA时钟被主机拉着处于低电平，从机没办法发送0和1）</strong></p>
<p><strong>（5）指定地址写</strong></p>
<p>对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data）</p>
<p><img src="https://i-blog.csdnimg.cn/direct/2dd2360accc047a79ed4fa5c8839447c.png" alt="img"></p>
<p><strong>（6）当前地址读</strong></p>
<p>对于指定设备（Slave Address），在当前地址指针（具体哪个寄存器）指示的地址下，读取从机数据（Data）</p>
<p><img src="https://i-blog.csdnimg.cn/direct/0d69ae692ff44750ac4cede307e1659f.png" alt="img"></p>
<p><strong>（7）指定地址读</strong></p>
<p>对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）；<strong>写两次，写设备地址和寄存器地址（与当前地址读的区别就是多写一次寄存器的地址）</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/c8ecdc45e78e454cbd2170de35158636.png" alt="img"></p>
<hr>
<p><strong>4. SPI</strong></p>
<p>简介：SPI（Serial Peripheral Interface）是由Motorola公司开发的一种<strong>通用数据总线</strong>。<strong>四根通信线</strong>：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）从机选择，是一种<strong>同步</strong>（有<strong>时钟线SCK</strong>，相当于I2C的SCL），<strong>全双工</strong>（<strong>主机发送和接收各占一条线</strong>）的协议， 支持<strong>总线挂载多设备</strong>（<strong>一主多从</strong>，不支持多主机）。</p>
<p>优缺点：</p>
<p>​	· 支持全双工操作，操作简单，<strong>数据传输速率较高</strong>（相比于I2C的优点，I2C的传输速率慢）； </p>
<p>​	· 需要<strong>占用主机较多的口线</strong>，只支持<strong>单个主机</strong>，<strong>没有应答机制</strong>确认是否接收到数据（相比于I2C的缺点）。</p>
<p><strong>原理：</strong></p>
<p>所有SPI设备的SCK、MOSI、MISO分别连在一起，<strong>主机另外引出多条SS控制线</strong>，<strong>分别接到各从机的SS引脚</strong>，<strong>输出引脚配置为推挽输出</strong>，<strong>输入引脚配置为浮空或上拉输入</strong>。推挽输出驱动能力强，<strong>SCK上升沿和下降沿都迅速</strong>，不像I2C上升沿慢。</p>
<p>不同于<strong>I2C发送寻址地址寻找从机</strong>，<strong>SPI通过从机选择线SS</strong>来寻找具体哪个从机SS线低电平有效。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/258b5c65d65547dd96beec9125fdddee.png" alt="img"></p>
<p><strong>移位示意图</strong>——循环式数据互换</p>
<p>SPI的主机和从机之间的<strong>数据传输就是一个数据移位的过程</strong>（主机把自身数据移给从机，同时从机把数据移给主机，在同一个时钟信号SCK的控制下）。<strong>高位先行</strong>，左移波特率发生器即SCK的上升沿，所有移位寄存器向左移动一位，把两边寄存器的最高位放在MISO和MOSI的数据线上； 下降沿的时候，主机和从机都会进行数据的采样输入，被发送的bit到达目的地； 这样<strong>八个时序</strong>之后，主机和从机的数据互换，实现了彼此的数据交换。<br><img src="https://i-blog.csdnimg.cn/direct/9b7205a36ee64f00a716849dfa38ce93.png" alt="img"></p>
<p><strong>(1)时序：</strong></p>
<p>起始条件：SS从高电平切换到低电平。终止条件：SS从低电平切换到高电平。<strong>SS为低电平有效，通信过程中要时钟保持为低电平。</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/a04c59b1cfa1494a942ad7d4d3a74a2f.png" alt="img"></p>
<p><strong>(2)时钟极性与时钟相位</strong></p>
<p>时钟极性（CPOL）：<strong>表示 SPI 在空闲时, 时钟信号是高电平还是低电平</strong>。若CPOL &#x3D;1, 设备在空闲时 SCK时钟信号为高电平.。CPOL&#x3D;0, SCK为低电平。</p>
<p>时钟相位（CPHA）：<strong>表示SPI在采样数据时是在SCK第一个边沿还是第二个边沿</strong>，第一个边沿CPHA&#x3D;0,第二个边沿CPHA&#x3D;1.<br>如何判断：<strong>SCK的空闲时候的电压，是0还是1，决定了CPOL是0还是1</strong>，<strong>数据采样时刻对应着的SCK的电平，是第一个边沿还是第二个边沿，对应着CPHA为0还是1</strong>。</p>
<p><strong>(3)交换一个字节（模式0）：</strong></p>
<p>模式0的时候：CPOL&#x3D;0：空闲状态时，SCK为低电平 CPHA&#x3D;0：SCK第一个边沿移入数据（<strong>上升沿移入数据</strong>），第二个边沿移出数据（<strong>下降沿移出数据</strong>）。</p>
<p>模式0是最常用的，S起始位的时候，下降的同时移出数据MOSI写入，SCK上升沿移入数据，SCK下降沿移出数据。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/87f08c4792cd4937a89e67aaad652360.png" alt="img"></p>
<p> MISO最开始的横线代表为高阻态，在一个从机被选中的时候<strong>为了避免别的从机的干扰</strong>，置为高阻态即为没有输入。</p>
<p><strong>(4)发送指令</strong></p>
<p>向SS指定的设备，发送指令（0x06），这里使用模式0，空闲时候SCK&#x3D;0，上升沿采样读取数据，下降沿移除数据发送。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/e993e9f73f9840b68304b01d47008994.png" alt="img"></p>
<p> 从机没有数据发送给主机，所以这里全是1挂起。</p>
<p><strong>(5)指定地址写</strong></p>
<p>向SS指定的设备，发送写指令（0x02），随后在指定地址（Address[23:0]）下，写入指定数据（Data）</p>
<p><img src="https://i-blog.csdnimg.cn/direct/9392b631738249fdbce28cf18e32422b.png" alt="img"></p>
<p><strong>(6)指定地址读</strong></p>
<p>向SS指定的设备，发送读指令（0x03） 随后在指定地址（Address[23:0]）下，读取从机数据（Data）</p>
<p><img src="https://i-blog.csdnimg.cn/direct/b44590fd2a9f420f9f83350c29b82d48.png" alt="img"></p>
<hr>
<p><strong>5 DDS</strong></p>
<p>DDS（Data Distribution Service）是一种<strong>实时发布-订阅</strong>（Pub-Sub）通信协议，用于<strong>分布式系统</strong>中的<strong>高效、低延迟数据交换</strong>。它支持<strong>数据自动发现</strong>、动态扩展、<strong>QoS（服务质量）管理</strong>，无需服务器中转，<strong>设备间可直接通信</strong>（明显区分于MQTT）。DDS 适用于工业自动化、航空航天、汽车电子、机器人等需要高可靠性和实时性的场景。</p>
<p>以下是DDS协议中的一些概念：</p>
<p>（1）Domain：代表一个通信平面，由Domain ID唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分1个Domain，也可以按照交互规则或其他规则，定义多个Domain；</p>
<p>（2）Domain Participant：代表域内通信的应用程序的本地成员身份，简单来说，就是说明同一数据域内的通信成员；</p>
<p>（3）Topic：是数据的抽象概念，由TopicName标识，关联相应数据的数据类型(DataType)，如果把车内所涉及的所有Topic集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了；</p>
<p>（4）DataWriter：数据写入者，类似<strong>缓存</strong>，把需要发布的主题数据从应用层写入到DataWriter中；</p>
<p>（5）DataReader：数据读取者，同样可以理解为一种<strong>缓存</strong>，从订阅者得到主题数据，随之传给应用层；</p>
<p>（6）Publisher：发布者，发布主题数据，<strong>至少与1个DataWriter关联</strong>，通过调用DataWriter的相关函数将数据发出去；</p>
<p>（7）Subscriber：订阅者，订阅主题数据，<strong>至少与1个DataReader关联</strong>。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。</p>
<p>根据前面介绍，我们清楚了DDS是一个以数据为中心的中间件协议和API标准，意为用户只关心自己想要的数据，数据通过Topic进行标识，这样发布者根据主题发布数据，订阅者根据自己感兴趣的主题订阅数据。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/94179a91cd954db7b7d2dc3a58e869f4.png" alt="img"></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="进程间通信"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-08T11:00:00.000Z" title="2025/1/8 19:00:00">2025-01-08</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:15:18.849Z" title="2025/3/24 23:15:18">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">2 小时读完 (大约20266个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/">进程间通信</a></p><div class="content"><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><hr>
<h3 id="一、进程间通信介绍"><a href="#一、进程间通信介绍" class="headerlink" title="一、进程间通信介绍"></a>一、进程间通信介绍</h3><ol>
<li><h3 id="进程间通信概念"><a href="#进程间通信概念" class="headerlink" title="进程间通信概念"></a>进程间通信概念</h3>​    进程间通信（Inter-Process Communication, IPC）是指在<strong>不同进程之间传递或交换信息的一种机制</strong>。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间<strong>不能直接访问对方的内存空间</strong>，需要通过特定的通信机制来实现数据交换和同步操作。</li>
</ol>
<p><strong>是什么——</strong></p>
<p>两个或多个进程实现<strong>数据层面的交互</strong>。因为<strong>进程独立性</strong>的存在，导致<strong>进程通信的成本比较高</strong>。</p>
<p>为什么——</p>
<p>发送基本数据、发送指令、多进程协同等需求</p>
<p><strong>怎么办——</strong></p>
<ul>
<li>进程间通信的本质：<strong>必须让不同的进程看到同一份“资源”</strong>，这里的资源就是指<strong>以特定形式存在的内存空间</strong>。</li>
<li><strong>资源由谁来提供？一般是操作系统。</strong>为什么不是我们两个进程中的一个呢？假设一个进程提供，这个资源就属于该进程所有，因为进程具有独立性！破坏进程独立性，这是操作系统不允许的，所以需要第三方提供空间，所以操作系统就是和事佬。</li>
<li>我们进程访问空间，进行进程间通信，<strong>本质就是访问操作系统</strong>，而<strong>进程代表的是用户</strong>，用户不能直接访问操作系统内核数据，所以操作系统提供了系统调用接口，所以是从操作系统底层设计，从接口设计，<strong>一个独立的通信模块IPC —— 隶属文件系统</strong>。当进程通信变多，显而易见，操作系统需要将他们管理起来，先描述再组织。</li>
</ul>
<ol start="2">
<li><h3 id="进程间通信目的"><a href="#进程间通信目的" class="headerlink" title="进程间通信目的"></a><strong>进程间通信目的</strong></h3></li>
</ol>
<p>  数据传输：一个进程需要将它的数据发送给另一个进程</p>
<p>  资源共享：多个进程之间共享同样的资源。</p>
<p>  通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p>
<p>  进程控制：有些<strong>进程希望完全控制另一个进程的执行（如Debug进程）</strong>，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<ol start="3">
<li><h3 id="进程间通信的本质"><a href="#进程间通信的本质" class="headerlink" title="进程间通信的本质"></a>进程间通信的本质</h3> <strong>必须让不同的进程看到同一份“资源”</strong>，这里的资源就是指<strong>以特定形式存在的内存空间</strong>。</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/a5885461758b4f49aefdcfb8b309d209.png" alt="img"></p>
<p>因此，进程间通信的本质就是，<strong>让不同的进程看到同一份资源（内存，文件内核缓冲等）</strong>。 由于<strong>这份资源可以由操作系统中的不同模块提供</strong>，因此出现了<strong>不同的进程间通信方式</strong>。</p>
<h4 id="4-进程间通信发展"><a href="#4-进程间通信发展" class="headerlink" title="4. 进程间通信发展"></a>4. 进程间通信发展</h4><ol>
<li><p>管道</p>
</li>
<li><p>System V 进程间通信</p>
</li>
<li><p>POSIX 进程间通信</p>
</li>
<li><h3 id="进程间通信分类"><a href="#进程间通信分类" class="headerlink" title="进程间通信分类"></a>进程间通信分类</h3><ol>
<li>管道（文件缓冲区）<br>1. 匿名管道pipe<br>2. 命名管道</li>
<li>System V IPC<ol>
<li>System V 消息队列</li>
<li>System V 共享内存 （内存块）</li>
<li>System V 信号量</li>
</ol>
</li>
<li>POSIX IPC<ol>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>互斥量</li>
<li>条件变量</li>
<li>读写锁</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h3 id="二、管道"><a href="#二、管道" class="headerlink" title="二、管道"></a>二、管道</h3><p>​        管道（Pipes）是一种基本的进程间通信（IPC）机制，用于<strong>连接一个进程的输出到另一个进程的输入</strong>。管道允许数据<strong>以字节流的形式</strong>从一个进程传递到另一个进程。它是<strong>单向</strong>的，即数据只能从一个方向流动。管道分为<strong>匿名管道和命名管道</strong>（也称为FIFO，即First In First Out）。</p>
<p>​	<strong>原理：基于文件的一种通信方式</strong></p>
<ol>
<li><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p> ​    匿名管道是最早出现的UNIX IPC机制之一，它只能用于<strong>具有亲缘关系的进程之间</strong>（通常是<strong>父子进程或兄弟进程</strong>）。当一个进程创建了一个管道后，它会得到两个文件描述符：一个用于写（通常称为管道的写端），另一个用于读（通常称为管道的读端）。进程可以将数据写入管道的写端，然后另一个进程可以从管道的读端读取数据。由于<strong>管道是基于文件描述符</strong>的，因此<strong>当所有指向管道的文件描述符都被关闭后</strong>，管道中的<strong>数据就会被丢弃</strong>，管道本身也会被销毁。</p>
<pre><code> 管道是一种简单但强大的IPC机制，它适用于需要数据流的场景，如父子进程之间的数据传递。然而，由于其单向性和有限的容量，管道可能不适合所有类型的IPC需求。在这种情况下，可以考虑使用其他IPC机制，如消息队列、共享内存或套接字等。
</code></pre>
</li>
</ol>
<p>例如，统计我们当前使用云服务器上的登录用户个数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who | wc -l</span><br></pre></td></tr></table></figure>

<p> who命令和wc命令都是两个程序，当它们运行起来后就变成了两个进程，who进程通过标准输出将数据打到“管道”当中，wc进程再通过标准输入从“管道”当中读取数据，至此便完成了数据的传输，进而完成数据的进一步加工处理。( who命令用于查看当前云服务器的登录用户（一行显示一个用户），wc -l用于统计当前的行数)<br><img src="https://i-blog.csdnimg.cn/direct/acbe35923c0c40ff9871a97167300e52.png" alt="img"></p>
<p>由管道（“|”）连接起来的各个进程是有亲缘关系的，它们之间互为兄弟进程，是匿名管道。</p>
<h5 id="1-1-匿名管道原理"><a href="#1-1-匿名管道原理" class="headerlink" title="1.1 匿名管道原理"></a>1.1 匿名管道原理</h5><p>重温一下进程结构体：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/1fe4e66715204c708422684cfbe8f5d7.png" alt="img"></p>
<p>进程创建时，创建 task_struct 结构体，结构体内有指针指向 files_struct 结构体，该结构体内有一个struct file* 数组，即文件描述符表，指向被该进程打开的 struct file 文件（默认打开stdin、stdout、stderr，对应键盘和显示器文件）。如果进程又打开一个文件（操作系统创建的内存级文件），那么为就为该文件分配一个最小的没有被使用的fd，在fd下标的文件描述符数组的元素填写指向该文件的struct file的struct file*，并且 struct file 结构体还指向了 inode 属性集结构体（有大部分inode的属性）、file_opeartors函数方法集（对硬件的操作函数的函数指针结构体）、文件页缓冲区。对于文件页缓冲区来说，无论读写，都将磁盘数据加载到文件页缓冲区（相当于缓冲，提高效率），如果是写就会修改缓冲区数据，该数据为脏，所以就会被操作系统刷新到磁盘，    </p>
<pre><code>    管道虽然用的是文件的方案，但操作系统一定不会把进程进行通信的数据刷新到磁盘当中，因为这样做有IO参与会降低效率，而且也没有必要。也就是说，这种文件是一批不会把数据写到磁盘当中的文件，换句话说，磁盘文件和内存文件不一定是一一对应的，有些文件只会在内存当中存在，而不会在磁盘当中存在。
</code></pre>
<p>进程打开文件后再 fork，会拷贝 files_struct 吗？ </p>
<pre><code>    会拷贝files_struct ，但是不会拷贝struct file，对于 struct file 直接引用计数即可(图画错了，两个进程的3号fd应该指向相同的struct file)。
    所以父子进程会看到同一个新建的文件 —— 内存级文件，这就实现了不同的进程，看到同一份资源！父进程可以向文件页缓冲区写入数据，子进程就可以在文件页缓冲区读取数据！这就实现了进程间通信。所以管道就是文件！是一种内存级别文件，不在磁盘。
    内存级文件：不在磁盘，操作系统在内存直接创建一个struct file。
</code></pre>
<p>管道是一个内存级别文件，由os直接创建一个文件结构体用于进程间读写，不会加载到磁盘。</p>
<p>这里父子进程看到的同一份文件资源是由操作系统来维护的，所以当父子进程对该文件进行写入操作时，该文件缓冲区当中的数据并不会进行写时拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内存级文件（管道文件）有路径、文件名、inode吗？</span><br><span class="line"></span><br><span class="line">由于匿名管道不直接对应于文件系统中的任何实体，因此它没有自己的inode号。并且根本就不需要名字，因为子进程看到父进程是靠继承拷贝来看到的。</span><br><span class="line">匿名管道的文件描述符仅用于在创建它的进程及其子进程或通过其他IPC机制（如消息队列、共享内存等）与之通信的进程之间进行数据传递。</span><br></pre></td></tr></table></figure>

<p><strong>命名管道：有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作。</strong><br><strong>匿名管道：没有明确的路径、文件名和inode号，仅存在于内存中，通过进程间的文件描述符进行通信。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当进程依靠管道文件通信时，一方关闭文件，另一方会受影响而出现错误吗？</span><br><span class="line"></span><br><span class="line">如果父进程只是以读方式打开管道文件，那么子进程拷贝父进程进程的一系列结构体，导致子进程也只能以读方式读管道文件，父子都只能读管道文件，这就会引发矛盾。所以，父进程打开文件是有要求的，需要以读和写分别打开管道文件！</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/9ac46c225bf141c5af52e4ec8e53fb2b.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/e894e87ef87743989ca870dc4b387daa.png" alt="img"></p>
<pre><code>    虽然读写在技术角度可以，但是读写不建议混起来，因为读写都是由各自的变量控制的，如果混在一起我们刚写的数据是读不出来的。所以，一般都是读打开一次、写打开一次，但是除了创建一个struct file，其他的都是共享（inode结构体、文件缓冲区）
    所以操作系统规定，一个进程不能同时读写，因为如果同时读写，不能确定哪些数据是自己的哪些是其他进程写的，这就很繁琐，操作系统使用文件系统来实现就是为了简单一些，否则就会再设计一个复杂的系统来实现，所以操作系统就规定进程之间只能进行单向通信！
    所以一个进程在读时，就关闭自己的写文件，另一个进程在写时，就关闭自己的读文件，从而实现单向通信。
</code></pre>
<p>管道进行读写时，一般都是关闭各自的另一个写读文件，比如A读就关闭A的写文件，B写就关闭B的读文件，实现单向通信，而且只能互斥地读写，每次每个管道只能有一端被一个进程访问。</p>
<p>匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么非要搞管道，我父进程写一个全局数据，子进程继承，这不就是传递消息吗？</span><br><span class="line">首先，进程的通信内容大部分为动态的消息，即消息是即时性的传递，而不是静态的数据，其次父进程的全局数据只是单方面的传递，子进程只能读数据，不能写数据，一旦写数据就会触发写时拷贝。</span><br></pre></td></tr></table></figure>

<p><strong>写时拷贝&#x2F;写时复制：一种资源管理优化策略</strong></p>
<p><strong>核心思想是延迟数据的实际复制操作，直到数据被修改时才进行复制。</strong>具体来说，如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会<strong>共同获取相同的指针指向相同的资源</strong>，直到某个调用者<strong>试图修改</strong>资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>fork()系统调用创建子进程时会使用写时拷贝。子进程和父进程共享内存空间，只有<strong>在某个进程对内存进行写操作时，才会复制相应的内存页面。</strong></p>
<p>优点：<strong>减少不必要的数据复制，节省内存和存储空间。提高系统性能，避免数据共享时的多个复制开销。</strong></p>
<p>缺点：<strong>需要额外的机制来管理；某些情况会多次触发写时拷贝，导致内存中有多份数据副本。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果进程不是父子关系，那么还能通过管道通信吗？</span><br><span class="line">不可以，必须是父子关系。管道原理就是父子进程共享管道文件。</span><br><span class="line"></span><br><span class="line">如果父进程创建多个子进程，那么这些子进程可以通过管道通信吗？</span><br><span class="line">可以，因为全都继承的父进程，所以都指向同一个内存文件——管道文件（文件页缓冲区）。</span><br><span class="line"> </span><br><span class="line">如果父进程创建的子进程，子进程又创建了子进程，那么爷孙进程可以通过管道通信吗？</span><br><span class="line">可以，因为也都是拷贝的同一份files_struct，都指向同一个内存文件——管道文件。</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong>匿名管道通信<strong>，</strong>进程之间需要又血缘关系，常见于父子关系。匿名管道通常只能用于具有亲缘关系的进程之间（如父子进程、兄弟进程）。这是因为非亲缘关系的进程无法直接访问对方的内存空间，也无法通过文件描述符&#x2F;句柄继承来访问对方的管道。</p>
<hr>
<h5 id="1-2-pipe系统调用"><a href="#1-2-pipe系统调用" class="headerlink" title="1.2 pipe系统调用"></a>1.2 pipe<strong>系统调用</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 pipe</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/d38666cd7b1843f3bba91cfccd140679.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br></pre></td></tr></table></figure>

<p><strong>该函数参数是一种输出型参数，</strong>pipe内部将struct file、文件缓冲区等结构创建好，以读写方式打开内存文件（匿名管道），然后返回两个文件描述符fd ，<strong>靠数组带回</strong>，数组只需两个元素，默认：</p>
<ul>
<li><strong>pipefd[0] ：读下标</strong></li>
<li><strong>pipefd[1] ：写下标</strong></li>
</ul>
<p><strong>返回值：pipe函数调用成功时返回0，调用失败时返回-1</strong></p>
<p>举例：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/8fc99c92b28f4a7b8c727b03812bccbc.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ff3291b0df74db3baf14cca773c98e2.png" alt="img"></p>
<p>pipefd有两个元素，用于存储管道的读写端；</p>
<p>pipefd传入pipe，将pipefd[0]设为当前文件句柄3，将pipefd[1]设为当前文件句柄4；</p>
<p>然后返回一个数用于反馈，成功为0，并且pipefd中会包含两个有效的文件描述符；失败为-1，并且会设置errno以指示错误原因。</p>
<hr>
<h5 id="1-3-匿名管道的使用"><a href="#1-3-匿名管道的使用" class="headerlink" title="1.3 匿名管道的使用"></a>1.3 匿名管道的使用</h5><p> 在创建匿名管道实现父子进程间通信的过程中，需要pipe函数和fork函数搭配使用。</p>
<p>1、父进程调用pipe函数创建管道</p>
<img src="https://i-blog.csdnimg.cn/direct/5ef0abc0575742e0acbda3094fbd5f71.png" alt="img" style="zoom:50%;" />

<p>2、父进程创建子进程</p>
<img src="https://i-blog.csdnimg.cn/direct/dab4bcb10ccb4d3d8e424cae7aa612d2.png" alt="img" style="zoom:50%;" />

<p>3、父进程关闭写端，子进程关闭读端（当然，父进程也可以关闭读端）</p>
<img src="https://i-blog.csdnimg.cn/direct/1596bea838aa46348204aa02514a1e6f.png" alt="img" style="zoom:50%;" />

<p>匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。</p>
<p>父子进程的<strong>通信靠操作系统的系统调用接口write、read</strong>，因为操作系统不相信用户，不可能让用户自己指定一块内存区域，让用户随便访问，这是不允许的。</p>
<p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//child-&gt;write, father-&gt;read</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)&#123; <span class="comment">//使用pipe创建匿名管道</span></span><br><span class="line">		perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">pid_t</span> id = fork(); <span class="comment">//使用fork创建子进程</span></span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//child</span></span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">//子进程关闭读端</span></span><br><span class="line">		<span class="comment">//子进程向管道写入数据</span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello father, I am child...&quot;</span>;</span><br><span class="line">		<span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">while</span> (count--)&#123;</span><br><span class="line">			write(fd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">//子进程写入完毕，关闭文件</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//father</span></span><br><span class="line">	close(fd[<span class="number">1</span>]); <span class="comment">//父进程关闭写端</span></span><br><span class="line">	<span class="comment">//父进程从管道读取数据</span></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">ssize_t</span> s = read(fd[<span class="number">0</span>], buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">		<span class="keyword">if</span> (s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			buff[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child send to father:%s\n&quot;</span>, buff);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read file end\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd[<span class="number">0</span>]); <span class="comment">//父进程读取完毕，关闭文件</span></span><br><span class="line">	waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>管道内部自带同步与互斥机制</strong></p>
<p>多执行流共享时，可能会出现访问冲突问题。即一个进程正在访问数据时，另一个进程写入数据，这就可能覆盖原数据——临界资源竞争问题</p>
<p>临界资源是需要被保护的，若是我们不对管道这种临界资源进行任何保护机制，那么就可能出现同一时刻有多个进程对同一管道进行操作的情况，进而导致同时读写、交叉读写以及读取到的数据不一致等问题。</p>
<p>为了避免这些问题，内核会对管道操作进行同步与互斥：</p>
<p>​	<strong>同步： 两个或两个以上的进程在运行过程中协同步调，按预定的先后次序运行。比如，A任务的运行依赖于B任务产生的数据。<br>​	互斥： 一个公共资源同一时刻只能被一个进程使用，多个进程不能同时使用公共资源。</strong><br>实际上，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。对于管道的场景来说，互斥就是两个进程不可以同时对管道进行操作，它们会相互排斥，必须等一个进程操作完毕，另一个才能操作，而同步也是指这两个不能同时对管道进行操作，但这两个进程必须要按照某种次序来对管道进行操作。</p>
<p>也就是说，互斥具有唯一性和排它性，但<strong>互斥并不限制任务的运行顺序</strong>，而<strong>同步的任务之间则有明确的顺序关系</strong>。</p>
<hr>
<h5 id="1-4-管道通信的特征"><a href="#1-4-管道通信的特征" class="headerlink" title="1.4 管道通信的特征"></a><strong>1.4 管道通信的特征</strong></h5><p>​	<strong>亲缘性</strong>：具有血缘关系的进程才能通过管道通信<br>​	<strong>单向性</strong>：管道是单向的，数据只能从一个方向流动<br>​	<strong>通信进程之间会协同（互斥、同步）</strong>，这是为了保护管道文件的数据安全。如果父进程读数据时，缓冲区直接拿来就读会导致乱码，因为缓冲区不是每时每刻都为空，子进程也不是时时刻刻写入缓冲区，所以进程间需要协同！一方没有写入，另一方就不读写。<br>​	<strong>基于字节流</strong>：管道是面向字节流的，管道中的数据以字节流的形式传递，没有消息边界的概念（不管一个进程写了多少字符、写了几次，另一个进程<strong>读取时一次全部读完</strong>。就像是自来水，来自写端的自来水不分边界，不管写端放了多少自来水，<strong>读端都是一个读完</strong>，不管读端是拿盆还是拿桶来接）对于进程A写入管道当中的数据，进程B每次从管道读取的数据的多少是任意的，这种被称为流式服务。<br>​	<strong>生命周期</strong>：<strong>匿名管道的生命周期随进程结束而结束</strong>；<strong>命名管道的生命周期则取决于文件系统</strong>，除非显式删除，否则会一直存在。<strong>管道是基于文件的</strong>，文件的生命周期是跟随进程的。父子进程退出时，管道文件自动被操作系统释放，例如默认打开的stdin、stdout、stderr都是操作系统关闭的<br><strong>管道是有固定大小的 ，在不同内核里大小有差别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<p>使用 ulimit 指令查看对很多重要资源的限制，进程可打开最大文件数、管道大小等等</p>
<p><img src="https://i-blog.csdnimg.cn/direct/07e49248461b4ca88efe98138cfaecfd.png" alt="img"></p>
<p>  centos7.6版本默认给管道大小是64KB。当写入的字节小于PIPE_BUF时，写入的必须是原子（单次写入大小），这里的pipe size 就可以看 作 PIPE_BUF</p>
<p>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。<br>当要写入的<strong>数据量大于PIPE_BUF时，linux将不再保证写入的原子性</strong>。</p>
<hr>
<h5 id="1-5-管道读写的4种情况"><a href="#1-5-管道读写的4种情况" class="headerlink" title="1.5 管道读写的4种情况"></a><strong>1.5 管道读写的4种情况</strong></h5><ol>
<li>读写端正常，管道如果为空，读端就要阻塞，直到管道内出现数据</li>
<li>读写端正常，管道如果被写满，写端就要阻塞，直到管道内数据被读端读取</li>
<li>读端正常读，写端关闭，读端就会读到0，表明读到了文件（pipe）结尾，不会被阻塞</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/97e0a28c17bd4e6d862ce38e5b70942f.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/2a6864ab841b400b98da320f6f24d5ba.png" alt="img"></p>
<ol start="4">
<li>写端正常写，读端关闭，操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程（操作系统不会做低效、浪费内存等类似的工作，如果做了，那么就是操作系统的bug）</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/c2a723327a584febb1fc2a6b30cac17e.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/cc38546d15e6461d8cd4479205de9d52.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ac5195a5651417e98c3aa710f689a27.png" alt="img"></p>
<p>操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程</p>
<p><img src="https://i-blog.csdnimg.cn/direct/8aab473539d74eacb5f1dbeb6ad91b62.png" alt="img"></p>
<p>其中前面两种情况就能够很好的说明，管道是自带同步与互斥机制的，读端进程和写端进程是有一个步调协调的过程的，不会说当管道没有数据了读端还在读取，而当管道已经满了写端还在写入。读端进程读取数据的条件是管道里面有数据，写端进程写入数据的条件是管道当中还有空间，若是条件不满足，则相应的进程就会被挂起，直到条件满足后才会被再次唤醒。</p>
<p>第三种情况也很好理解，读端进程已经将管道当中的所有数据都读取出来了，而且此后也不会有写端再进行写入了，那么此时读端进程也就可以执行该进程的其他逻辑了，而不会被挂起。<br>第四种情况也不难理解，既然管道当中的数据已经没有进程会读取了，那么写端进程的写入将没有意义，因此操作系统直接将写端进程杀掉。而此时子进程代码都还没跑完就被终止了，属于异常退出，那么子进程必然收到了某种信号。</p>
<hr>
<h5 id="1-6-实践操作："><a href="#1-6-实践操作：" class="headerlink" title="1.6 实践操作："></a><strong>1.6 实践操作：</strong></h5><p><strong>shell管道</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/b751056f955f4c87a7478a8d5e9eea26.png" alt="img"></p>
<p>hpp文件：c++的头文件。直接将.h和.cpp文件混在一起，之前 .h 和 .cpp 分开编译是因为为了打包成库，如果本身就奔着开源，那么大部分就是直接使用hpp后缀 </p>
<hr>
<p><strong>进程池</strong></p>
<p>由于每次fork一个子进程效率并不高，我们可以在空闲时让父进程fork出一些子进程，组成一个进程池，当有需要时指定进程池中任意一个进程分配任务，这样的效率就提高了。</p>
<hr>
<ol start="2">
<li><h3 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h3></li>
</ol>
<p>命名管道克服了匿名管道只能用于亲缘关系进程间通信的限制，它<strong>允许无亲缘关系的进程间通信</strong>。命名管道在<strong>文件系统中有一个名字</strong>，任何<strong>进程都可以通过这个名字来访问管道</strong>。</p>
<p> 命名管道和匿名管道一样，都是内存文件，只不过命名管道在磁盘有一个简单的映像，但这个映像的大小永远为0，因为命名管道和匿名管道都不会将通信数据刷新到磁盘当中</p>
<p>匿名管道是<strong>通过子进程继承父进程实现的看到同一份资源</strong>，而命名管道是通过 <strong>路径+文件名 确定同一份资源</strong>，该文件只存一份数据，即一份inode、一份文件缓冲区、一份操作方法集。</p>
<h5 id="2-1-mkfifo"><a href="#2-1-mkfifo" class="headerlink" title="2.1 mkfifo"></a>2.1 mkfifo</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man mkfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/d701f2ba3f804963bc137973690c6a64.png" alt="img"></p>
<p><strong>命令行创建命名管道</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/2c69c95ca6454a99b345156f4b07251e.png" alt="img"></p>
<p>可以看到，创建出来的文件的类型是**<code>p</code><strong>，代表该文件是</strong>命名管道文件**</p>
<p><strong>举例</strong>：我们打开两个终端，一个终端持续向命名管道追加写入字符串，另一个终端cat命名管道，<strong>两个终端靠命名管道实现echo进程与cat进程的通信</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/8896afd038b144b68ddf785541e29c05.png" alt="img"></p>
<p>echo 指令并不在左边终端打印，而是从命名管道myfifo传到右边终端的cat进程，并且在打印过程中命名管道大小不变（因为<strong>命名管道不会将通信数据刷新到磁盘当中</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程间通信的前提，是先让不同的进程看到同一份资源。那么为什么两个进程不直接读同一个磁盘上的文件？</span><br><span class="line">进行交流信息的进程只想用文件缓冲区来交流，只需要一个进程把数据放到缓冲区，另一个进程去拿就够了，如果是磁盘文件，它就需要刷盘，这是一个冗余的行为！</span><br><span class="line">管道文件不需要刷到磁盘，是一个内存级文件，所以即使追加写到命名管道，它的属性inode也不会改变，因为不会刷到磁盘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不同的进程怎么知道打开的是同一个文件？</span><br><span class="line">匿名管道是通过继承，而命名管道：路径+文件名</span><br><span class="line">我们在基础IO学过，路径+文件名具有唯一性，因为路径确定了分区，同一目录下文件名不能重复，因为文件名需要和inode一一映射，再者找到文件后发现是p属性，进程就知道要找到文件就是它了，所以这种方式就是命名管道通信方式</span><br></pre></td></tr></table></figure>

<p><strong>命名管道与匿名管道几乎完全相同，不同的一点就是命名管道可以让毫不相干、没有血缘关系的进程进行通信</strong></p>
<hr>
<p><strong>系统调用创建命名管道：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 mkfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/5d01dead8e444736be94ba176473967f.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">mkfifo函数的第一个参数是pathname，表示要创建的命名管道文件。</span><br><span class="line">· 若pathname以路径的方式给出，则将命名管道文件创建在pathname路径下。</span><br><span class="line">· 若pathname以文件名的方式给出，则将命名管道文件默认创建在当前路径下。（注意当前路径的含义）</span><br><span class="line"></span><br><span class="line">mkfifo函数的第二个参数是mode，表示创建命名管道文件的默认权限。</span><br><span class="line">例如，将mode设置为0666，则命名管道文件创建出来的权限：</span><br><span class="line">prw-rw-rw-  具体权限会受到umask掩码的影响（0002） umask掩码是控制文件和目录默认权限的</span><br><span class="line"></span><br><span class="line">mkfifo函数的返回值。</span><br><span class="line">· 命名管道创建成功，返回0</span><br><span class="line">· 命名管道创建失败，返回-1</span><br></pre></td></tr></table></figure>

<p><strong>命名管道的打开规则</strong></p>
<p>1、如果当前打开操作是为读而打开FIFO时。</p>
<p>O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO。<br>O_NONBLOCK enable：立刻返回成功。<br>2、如果当前打开操作是为写而打开FIFO时。</p>
<p>O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO。<br>O_NONBLOCK enable：立刻返回失败，错误码为ENXIO。</p>
<hr>
<h5 id="2-2-unlink"><a href="#2-2-unlink" class="headerlink" title="2.2 unlink"></a>2.2 unlink</h5><p>unlink——删除命名管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 unlink</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/6915a6229cea4a9dbe3644c92c3f41b0.png" alt="img"></p>
<hr>
<h5 id="2-3-实践通信"><a href="#2-3-实践通信" class="headerlink" title="2.3 实践通信"></a>2.3 实践通信</h5><p>comm.hpp 封装命名管道的创建与销毁功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span>    <span class="comment">//命名管道的文件名</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664               <span class="comment">//管道默认创建权限</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//enum错误类型，假定为进程退出码</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREAT_ERR = <span class="number">1</span>,</span><br><span class="line">    FIFO_DELETE_ERR,</span><br><span class="line">    FIFO_OPEN_ERR</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对创建和销毁命名管道做封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建命名管道，mkfifo</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREAT_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//销毁命名管道，unlink</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Log log;    <span class="comment">//日志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>server.cc 服务端创建命名管道，打开管道读取数据（此时客户端未进程启动，所以会在open处阻塞）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 让服务端管理命名管道文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init init;</span><br><span class="line">    Log log;</span><br><span class="line">    <span class="comment">// 先设置日志为单文件输出</span></span><br><span class="line">    log.<span class="built_in">Enable</span>(Classfile);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Warning, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">    <span class="built_in">log</span>(Error, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让服务端作为读端</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[x] = <span class="number">0</span>; <span class="comment">// 读取后在末尾处加\0，构成C语言字符串</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client say# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(Debug, <span class="string">&quot;client quit, me too! error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// break出来表示写端读端都关闭了，所以关闭管道文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> cilent.cc 打开管道文件，从键盘读取数据，再向文件内write数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd  &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client open file done&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">write</span>(fd, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在大多数现代操作系统和编程语言中，当一个进程被Ctrl+C（SIGINT信号）直接关闭时，程序会接收到一个中断信号，这通常会导致程序立即终止执行。对于C++等需要显式资源管理的语言来说，这意味着如果程序在没有适当处理该信号的情况下被终止，那么程序中的对象可能不会按预期调用它们的析构函数。</span><br><span class="line"></span><br><span class="line">析构函数的调用通常发生在以下几种情况：</span><br><span class="line"></span><br><span class="line">作用域结束：对于局部变量，当它们的作用域结束时（例如，函数返回或块结束），它们的析构函数会被自动调用。</span><br><span class="line"></span><br><span class="line">delete操作符：对于通过new操作符动态分配的对象，当使用delete操作符释放这些对象时，它们的析构函数会被调用。</span><br><span class="line"></span><br><span class="line">程序正常结束：当程序正常结束（例如，通过return语句从main函数返回）时，全局对象和静态局部对象的析构函数会按照与它们被创建时相反的顺序被调用。</span><br><span class="line"></span><br><span class="line">然而，当程序接收到SIGINT信号（如Ctrl+C）并直接终止时，这些规则并不适用。程序会立即停止执行，而不会执行任何清理操作（如调用析构函数）。这可能导致资源泄漏，比如未关闭的文件描述符、未释放的内存等。</span><br><span class="line"></span><br><span class="line">要处理这种情况，你可以：</span><br><span class="line"></span><br><span class="line">使用信号处理：在C++中，你可以使用信号处理函数（如signal或sigaction在UNIX/Linux系统中）来捕获SIGINT信号，并执行一些清理工作。但请注意，从信号处理函数中直接调用非异步信号安全的函数（包括大多数C++库函数）是不安全的。</span><br><span class="line"></span><br><span class="line">使用RAII（Resource Acquisition Is Initialization）：尽量使用RAII技术来管理资源。RAII是一种在对象构造时获取资源并在对象析构时释放资源的编程技术。这样，即使程序因为接收到SIGINT信号而异常终止，如果对象的析构函数有机会被调用（这通常很难保证），那么资源也能被正确释放。然而，如前所述，当程序因为信号而终止时，析构函数可能不会被调用。</span><br><span class="line"></span><br><span class="line">优雅地关闭程序：在程序的关键位置添加检查点，以检测用户是否请求了中断（例如，通过捕获SIGINT信号），并在检测到中断时执行必要的清理工作，然后正常退出程序。</span><br><span class="line"></span><br><span class="line">综上所述，当程序被Ctrl+C直接关闭时，程序中的对象可能不会按预期调用它们的析构函数，这可能导致资源泄漏等问题。因此，在编写需要处理中断信号的程序时，应该采取适当的措施来确保资源被正确管理。</span><br></pre></td></tr></table></figure>

<p>先关闭客户端（写端），服务端（读端）就会因为写端关闭而读到0，然后break，init对象的生命周期随程序结束，才会调用它的析构函数，unlink命名管道。</p>
<p>如果直接ctrl c掉服务端，那么进程直接退出，不会调用析构函数，这就会导致内存泄露</p>
<hr>
<p><strong>多文件编译Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:client server</span></span><br><span class="line"> </span><br><span class="line"><span class="section">client:client.cc</span></span><br><span class="line">	g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"><span class="section">server:server.cc</span></span><br><span class="line">	g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f client server</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li><h3 id="命名管道和匿名管道的区别"><a href="#命名管道和匿名管道的区别" class="headerlink" title="命名管道和匿名管道的区别"></a>命名管道和匿名管道的区别</h3></li>
</ol>
<ul>
<li><strong>命名管道有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作</strong>。</li>
<li>匿名管道没有明确的路径、文件名和inode号，仅存在于内存中，<strong>通过进程间的文件描述符进行通信</strong><br>匿名管道<strong>由pipe函数创建并打开</strong>。</li>
<li><strong>命名管道由mkfifo函数创建，由open函数打开</strong>。</li>
<li>FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在于<strong>它们创建与打开的方式不同</strong>，一旦这些工作完成之后，它们具有相同的语义。</li>
</ul>
<hr>
<h3 id="四、system-V"><a href="#四、system-V" class="headerlink" title="四、system V"></a>四、system V</h3><p>管道通信本质是基于文件的，也就是说操作系统并没有为此做过多的设计工作，而system V IPC是操作系统特地设计的一种通信方式。但是不管怎么样，它们的本质都是一样的，都是在想尽办法让不同的进程看到同一份由操作系统提供的资源。</p>
<p>system V IPC提供的通信方式有以下三种：</p>
<ul>
<li>system V<strong>共享内存</strong>：<strong>允许两个或多个进程共享一段内存区域</strong>，是进程间<strong>通信中最快</strong>的方式，因为<strong>数据不需要在进程间复制</strong>。</li>
<li>system V<strong>消息队列</strong>：允许<strong>一个或多个进程写入或读取消息</strong>，可以看作是一个<strong>消息链表</strong>，<strong>每个消息都有一个类型和一个优先级</strong></li>
<li>system V<strong>信号量</strong>：用于<strong>同步进程</strong>，<strong>控制多个进程对共享资源的访问</strong>。System V信号量<strong>分为二进制信号量和计数信号量</strong>。</li>
</ul>
<p>其中，system V共享内存和system V<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">消息队列</a>是以传送数据为目的的，而<strong>system V信号量是为了保证进程间的同步与互斥而设计的，虽然system V信号量和通信好像没有直接关系，但属于通信范畴</strong></p>
<hr>
<h4 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h4><h5 id="1-1-共享内存原理"><a href="#1-1-共享内存原理" class="headerlink" title="1.1 共享内存原理"></a>1.1 共享内存原理</h5><p>类似<strong>动态库加载</strong>，操作系统在物理内存创建一块区域，<strong>通过页表映射到需要通信的进程的虚拟地址空间的共享区中</strong>，并<strong>向应用层返回一个起始的虚拟地址</strong>，使得虚拟地址和物理地址之间建立起对应关系，从而使不同的进程看到同一份资源，这块物理内存就是共享内存。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/a0026aa10ab24fbeaf9bec4e20d9d136.png" alt="img"></p>
<p><strong>可以概括</strong>为：申请内存、挂接到进程地址空间、返回首地址。并且不能由进程自己malloc内存，因为进程是独立的，需要操作系统创建内存空间，创建信道，才可以实现不同进程通信。所以需求方进程要求执行方操作系统完成任务的过程就是<strong>系统调用</strong>。</p>
<h5 id="1-2-共享内存数据结构"><a href="#1-2-共享内存数据结构" class="headerlink" title="1.2 共享内存数据结构"></a>1.2 共享内存数据结构</h5><p>当进程之间的共享内存多了之后，操作系统就需要描述并组织起来大量的共享内存！所以对共享内存的增删查改就变成了对组织的数据结构的增删查改，所以共享内存除了在内存当中真正开辟空间之外，<strong>系统一定还要为共享内存维护相关的内核数据结构</strong>。</p>
<p><strong>共享内存的数据结构：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shmid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span>     shm_perm;   <span class="comment">/* operation perms */</span></span><br><span class="line">	<span class="type">int</span>         shm_segsz;  <span class="comment">/* size of segment (bytes) */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_atime;  <span class="comment">/* last attach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_dtime;  <span class="comment">/* last detach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>  shm_cpid;   <span class="comment">/* pid of creator */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>  shm_lpid;   <span class="comment">/* pid of last operator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>      shm_nattch; <span class="comment">/* no. of current attaches */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>      shm_unused; <span class="comment">/* compatibility */</span></span><br><span class="line">	<span class="type">void</span>            *shm_unused2;   <span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line">	<span class="type">void</span>            *shm_unused3;   <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们申请了一块共享内存后，<strong>为了让要实现通信的进程能够看到同一个共享内存</strong>，因此<strong>每一个共享内存被申请时都有一个key值，这个key值用于标识系统中共享内存的唯一性</strong>。</p>
<p>可以看到上面共享内存数据结构的第一个成员是shm_perm，shm_perm是一个ipc_perm类型的结构体变量，每个共享内存的key值存储在shm_perm这个结构体变量当中，其中ipc_perm结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-共享内存的建立与释放"><a href="#1-3-共享内存的建立与释放" class="headerlink" title="1.3 共享内存的建立与释放"></a>1.3 共享内存的建立与释放</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共享内存的建立大致包括以下两个过程：</span><br><span class="line">1. 在物理内存当中申请共享内存空间。</span><br><span class="line">2. 将申请到的共享内存挂接到地址空间，即建立映射关系。</span><br><span class="line"></span><br><span class="line">共享内存的释放大致包括以下两个过程：</span><br><span class="line">1. 将共享内存与地址空间去关联，即取消映射关系。</span><br><span class="line">2. 释放共享内存空间，即将物理内存归还给系统。</span><br></pre></td></tr></table></figure>

<h5 id="1-4-共享内存的创建"><a href="#1-4-共享内存的创建" class="headerlink" title="1.4 共享内存的创建"></a>1.4 共享内存的创建</h5><p>创建共享内存我们需要用shmget函数，shmget函数的函数原型如下：</p>
<p><strong>shmget</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 shmget</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/04895e1b544d4d0fa66d0fe1c72489c3.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/ba593954601d4780897c1687e9bf04bd.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget函数的参数说明：</span><br><span class="line">· 第一个参数key，表示待创建共享内存在系统当中的唯一标识。</span><br><span class="line">· 第二个参数size，表示待创建共享内存的大小。</span><br><span class="line">· 第三个参数shmflg，表示创建共享内存的方式。</span><br></pre></td></tr></table></figure>

<p><strong>shmflg：</strong>创建共享内存的操作只需要一次，剩下的进程只需要获取就好了，所以需要有一个参数来标识</p>
<p><img src="https://i-blog.csdnimg.cn/direct/c8b8a14a9f354f04b86dca8b59bda892.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPC_CREAT：如果申请的共享内存不存在，就创建；存在，就获取并返回。（这些都是宏，标记位，每个bit都不相同）</span><br><span class="line">IPC_CREAT | IPC_EXCL：如果申请的共享内存不存在，就创建；存在，就出错返回原有的共享内存。</span><br><span class="line">解释：第二个搭配确保了，如果我们申请成功了一个共享内存，这个共享内存一定是一个新的！并且 IPC_EXCL不单独使用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shmget函数的返回值说明：</span><br><span class="line">· shmget调用成功，返回一个有效的共享内存标识符（用户层标识符），类似文件句柄，我们使用后续接口时都要通过这个句柄对指定的共享内存进行操作。</span><br><span class="line">· shmget调用失败，返回-1。</span><br><span class="line"></span><br><span class="line">在进程内，shimid 用来标识资源的唯一性，shmid并不像fd那样是0，1，2的小的数组下标，shmid数值很大，但是他也是一个数组下标，在它内部还有一套算法。shmid搞特殊，因为Linux中一切皆文件，那么共享内存也可以被看作文件，那么我们也应该使用fd就可以访问，这是因为当初shmid 标准没有制定好。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：我们把具有标定某种资源能力的东西叫做句柄，而这里shmget函数的返回值实际上就是共享内存的句柄，这个句柄可以在用户层标识共享内存，当共享内存被创建后，我们在后续使用共享内存的相关接口时，都是需要通过这个句柄对指定共享内存进行各种操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们怎么保证让不同的进程看到同一个共享内存？怎么知道这个共享内存是是否存在呢？</span><br><span class="line">通过相同的参数调用ftok函数，获取相同的Key值</span><br></pre></td></tr></table></figure>

<p>传入shmget函数的第一个参数key，需要我们使用<strong>ftok</strong>函数进行获取</p>
<p><img src="https://i-blog.csdnimg.cn/direct/b7a3ce86ce8143b1be7ed6e5f236ca4c.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">ftok函数的作用就是，将一个已存在的路径名pathname和一个整数标识符proj_id转换成一个key值，称为IPC键值，在使用shmget函数获取共享内存时，这个key值会被填充进维护共享内存的数据结构当中。需要注意的是，pathname所指定的文件必须存在且可存取。</span><br><span class="line">ftok是一套算法，用路径名和项目id进行数值计算，获得冲突概率极低的数字 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为什么要让用户自己指定key，而不是操作系统自动生成？</span><br><span class="line">操作系统完全有能力创建很多的不冲突的key，但是操作系统创建的key只能由一个进程拿到，又因为进程的独立性，其他的想要和该进程通信的进程（没有血缘关系）拿不到该数据，又需要通信传递key，这就矛盾了，所以让用户（程序员）约定一个key，根据ftok使用通向的路径名和项目id，即使通信双方看不到彼此，也能获取相同的key，这样才可以看到同一个共享内存</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">使用ftok函数生成key值可能会产生冲突，此时可以对传入ftok函数的参数进行修改。</span><br><span class="line">需要进行通信的各个进程，在使用ftok函数获取key值时，都需要采用同样的路径名和和整数标识符，进而生成同一种key值，然后才能找到同一个共享资源。</span><br></pre></td></tr></table></figure>

<p>至此我们就可以使用ftok和shmget函数创建一块共享内存了，创建后我们可以将共享内存的key值和句柄进行打印，以便观察，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Log log;</span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享内存权限在flag参数处追加</p>
<p><img src="https://i-blog.csdnimg.cn/direct/3b133402c6da4d8790bf62403a1fdf36.png" alt="img"></p>
<hr>
<p><strong>在Linux中，查看系统内IPC的指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/fa81fa78b3394088a3dc573f00c78a24.png" alt="img"></p>
<p>单独使用 <strong><code>ipcs</code><strong>命令时，会默认列出消息队列、共享内存以及信号量相关的信息，若只想查看它们之间某一个的相关信息，可以选择携带以下</strong>选项：</strong></p>
<ul>
<li>-q：列出消息队列相关信息。</li>
<li>-m：列出共享内存相关信息。</li>
<li>-s：列出信号量相关信息。</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/direct/7feae806f0b344bf9b32a589a3d01364.png" alt="img"></p>
<p><code>ipcs</code>命令输出的每列信息的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>key</strong></th>
<th><strong>系统区别各个共享内存的唯一标识</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>shmid</strong></td>
<td><strong>共享内存的用户层id（句柄）</strong></td>
</tr>
<tr>
<td><strong>owner</strong></td>
<td><strong>共享内存的拥有者</strong></td>
</tr>
<tr>
<td><strong>perms</strong></td>
<td><strong>共享内存的权限</strong></td>
</tr>
<tr>
<td><strong>bytes</strong></td>
<td><strong>共享内存的大小</strong></td>
</tr>
<tr>
<td><strong>nattch</strong></td>
<td><strong>关联共享内存的进程数</strong></td>
</tr>
<tr>
<td><strong>status</strong></td>
<td><strong>共享内存的状态</strong></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <strong>key是在内核层面上</strong>保证共享内存唯一性的方式，而<strong>shmid是在用户层面上</strong>保证共享内存的唯一性，key和shmid之间的关系类似于fd和FILE*之间的的关系。</p>
<hr>
<p><strong>共享内存挂接</strong></p>
<p><strong>共享内存创建后，开始调用系统调用shmat进行挂接</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/8514d249f0ac4ccdbcb462128f9f5eea.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">shmat函数的参数说明：</span><br><span class="line">· 第一个参数shmid：表示待关联共享内存的用户级标识符。应用层都是以shmid为准</span><br><span class="line">· 第二个参数shmaddr：指定共享内存映射到进程地址空间的某一地址，通常设置为NULL，表示让内核自己决定一个合适的地址位置。最终的挂接位置会被返回</span><br><span class="line">· 第三个参数shmflg：表示关联共享内存时设置的某些属性。挂接时按什么权限，在创建共享内存时的权限就可以了，不用再修改，所以可以从传0</span><br></pre></td></tr></table></figure>

<p>其中，作为shmat函数的第三个参数传入的常用的选项有以下三个：</p>
<table>
<thead>
<tr>
<th align="left"><strong>选项</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SHM_RDONLY</strong></td>
<td align="left">关联共享内存后只进行读取操作</td>
</tr>
<tr>
<td align="left"><strong>SHM_RND</strong></td>
<td align="left">若shmaddr不为NULL，则关联地址自动向下调整为SHMLBA的整数倍。公式：shmaddr-(shmaddr%SHMLBA)</td>
</tr>
<tr>
<td align="left"><strong>0</strong></td>
<td align="left">默认为读写权限</td>
</tr>
</tbody></table>
<p><strong>shmat函数的返回值说明：</strong></p>
<ul>
<li>shmat调用成功，返回共享内存映射到进程地址空间中的起始地址。</li>
<li>shmat调用失败，返回(void*)-1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="1-5-共享内存去关联"><a href="#1-5-共享内存去关联" class="headerlink" title="1.5 共享内存去关联"></a>1.5 共享内存去关联</h5><p>取消共享内存与进程地址空间之间的关联我们需要用shmdt函数，shmdt函数的函数原型如下：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/80ceea1a523f41068cf787b11aec6533.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>去掉共享内存的关联，如果直接进程退出，那么进程会释放它的进程虚拟地址空间，和页表映射的物理内存，所以此时共享内存的引用计数–，<strong>ipcs -m</strong> 就可以查看到 nattck （挂接数）减1</p>
<p><strong>shmdt函数的参数说明：</strong></p>
<ul>
<li>待去关联共享内存的起始地址，即调用shmat函数时得到的起始地址。</li>
</ul>
<p><strong>shmdt函数的返回值说明：</strong></p>
<ul>
<li>shmdt调用成功，返回0。</li>
<li>shmdt调用失败，返回-1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只给它起始地址，shmdt它是怎么知道我们申请的共享内存有多大呢？</span><br><span class="line">因为需要知道具体大小才能在页表消除映射，并使共享内存引用计数--</span><br></pre></td></tr></table></figure>

<p> 这个问题就如同malloc申请内存、free只需要起始地址，这两个概念是完全相同的，因为操作系统有结构体维护申请的空间，例如malloc，如果你申请100字节，那么实际上操作系统会在进程地址空间的堆区申请120字节，多出来的就是维护申请空间信息的变量</p>
<p><strong>举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 将共享内存段与当前进程脱离不等于删除共享内存，只是取消了当前进程与该共享内存之间的联系。</p>
<hr>
<h5 id="1-6-共享内存的释放"><a href="#1-6-共享内存的释放" class="headerlink" title="1.6 共享内存的释放"></a><strong>1.6 共享内存的释放</strong></h5><p>通过上面创建共享内存的实验可以发现，当我们的进程运行完毕后，申请的共享内存依旧存在，并没有被操作系统释放。即进程退出，共享内存没有被释放！</p>
<p>这表明<strong>共享内存的生命周期是跟随内核的</strong>（匿名管道是生命周期是随进程的，命名管道生命周期独立于进程，需要显示的unlink），<strong>用户不主动关闭，共享内存会一直存在，除非内核重启或用户释放</strong>。如果我们忘记释放共享内存，那么这就算内存泄漏；如果我们没有忘记，那么这就不算内存泄漏</p>
<p>例如两个进程通信完毕后走了，操作系统把共享内存释放了，过了一段时间，这两个进程又回来继续通信，此时发现共享内存没有了，而里面可能还有它们上一次通信的内容，此时操作系统就算是惹祸了</p>
<p>此时我们若是要将创建的共享内存释放，有两个方法，一就是<strong>使用命令释放共享内存</strong>，二就是在进程通信完毕后<strong>调用释放共享内存的系统调用函数</strong>进行释放。</p>
<hr>
<p> <strong>命令释放共享内存</strong></p>
<p>在shell中使用命令释放共享内存 </p>
<p><strong>ipcrm</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m 共享内存shmid</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 指定删除时使用的是共享内存的用户层id，即列表当中的shmid。用户层统一使用shmid，命令行输入也是用户层。</p>
<p><strong>系统调用释放共享内存</strong></p>
<p>在程序中，释放共享内存我们需要用shmctl函数，控制共享内存，我们用它来删除共享内存。shmctl函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">shmctl函数的参数说明：</span><br><span class="line">· 第一个参数shmid，表示所控制共享内存的用户级标识符。</span><br><span class="line">· 第二个参数cmd，表示具体的控制动作。</span><br><span class="line">· 第三个参数buf，用于获取或设置所控制共享内存的数据结构。</span><br><span class="line">shmctl函数的返回值说明：</span><br><span class="line">· shmctl调用成功，返回<span class="number">0</span>。</span><br><span class="line">· shmctl调用失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>其中，作为shmctl函数的第二个参数传入的常用的选项有以下三个：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IPC_STAT</td>
<td align="left">获取共享内存的当前关联值，此时参数buf作为输出型参数</td>
</tr>
<tr>
<td align="left">IPC_SET</td>
<td align="left">在进程有足够权限的前提下，将共享内存的当前关联值设置为buf所指的数据结构中的值</td>
</tr>
<tr>
<td align="left">IPC_RMID</td>
<td align="left">删除共享内存段</td>
</tr>
</tbody></table>
<p>我们目前使用该函数时，不需要获取值，所以在第三个参数处传nullptr即可（我们是C&#x2F;C++混编，所以使用了nullptr）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="1-7-实践通信"><a href="#1-7-实践通信" class="headerlink" title="1.7 实践通信"></a><strong>1.7 实践通信</strong></h5><p> 我们讲了这么多全都是预备工作，创建、挂接、去关联、释放共享内存。那么预备工作完成后，双方如何进行通信？</p>
<pre><code>很简单，此时共享内存已经被映射到各进程的地址空间中，已经属于进程（进程：这就是我创建的空间，我随便用），使用方法与平时我们 malloc 的空间使用方法完全相同！直接访问、写入即可
为了让服务端和客户端在使用ftok函数获取key值时，能够得到同一种key值，那么服务端和客户端传入ftok函数的路径名和和整数标识符必须相同，这样才能生成同一种key值，进而找到同一个共享资源进行挂接。这里我们可以将这些需要共用的信息放入一个头文件当中，服务端和客户端共用这个头文件即可。
我们依旧使用日志类来管理程序。共享内存流程：创建、挂接、去关联、释放
</code></pre>
<p><strong>comm.hpp</strong></p>
<p>该文件用来定义+实现共享内存的创建和获取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMM_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMM_HPP__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>服务端processa.cc</strong></p>
<p>​    读取共享内存的信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say@ &quot;</span> &lt;&lt; shmaddr &lt;&lt; endl; <span class="comment">//直接访问共享内存</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除</span></span><br><span class="line">    <span class="comment">//如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端processb.cc</strong> </p>
<p>​    向共享内存写入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//processb直接使用即可，共享内存的创建和销毁由processa全权负责</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">GetShm</span>();</span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(shmaddr, <span class="number">4096</span>, stdin);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);         <span class="comment">//去掉共享内存关联</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/968e31eab76c453e9b5cc43ba1c135d5.png" alt="img"></p>
<p><strong>根据结果来看，共享内存有几个特性：</strong></p>
<ol>
<li>共享内存<strong>没有同步互斥之类的保护机制</strong>，跟管道不同，共享内存的读端进程不会等待写端进程就绪，会一直读空字符串。所以我们可以将共享内存和管道结合，当共享内存创建后，两者再使用管道，那么读端就必须等待写端写入数据，否则阻塞，这就实现了同步！</li>
<li>当共享内存<strong>创建好后就不再需要调用系统接口进行通信</strong>了，共享内存是所有的进程间通信中，<strong>速度是最快的，因为拷贝少</strong>！不需要read、write等系统接口进行通信。<strong>一旦有了共享内存，挂接到自己的地址空间中，那么直接使用起始地址进程操作即可</strong>，就如同操作自己malloc的空间，而管道创建好后仍需要read、write等系统接口进行通信。</li>
<li>共享内存<strong>内部的数据由用户自己维护</strong></li>
</ol>
<p><strong>我们来算算管道通信拷贝次数：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/b42b7dfdf6cc4a50ab34873024ba0765.png" alt="img"></p>
<p>使用管道通信的方式，将一个文件从一个进程传输到另一个进程需要进行<strong>四次拷贝操作：</strong></p>
<ol>
<li>服务端将信息<strong>从输入文件</strong>复制到服务端的临时缓冲区中。</li>
<li>将服务端<strong>临时缓冲区</strong>的信息复制到<strong>管道</strong>中。</li>
<li>客户端将信息从<strong>管道</strong>复制到客户端的<strong>缓冲区</strong>中。</li>
<li>将客户端<strong>临时缓冲区</strong>的信息复制到<strong>输出文件</strong>中。</li>
</ol>
<p><strong>注意：</strong>服务端和客户端的退出顺序 ，将共享内存和命名管道结合</p>
<p>与命名管道的服务端和客户端相同，只有先关闭客户端（写端），读端才会读到0，然后break，再执行后序的shmctl，shmctl是真的能删除共享内存，不用手动的使用 ipcrm -m 删除共享内存</p>
<p>如果直接ctrl c掉读端，进程会直接退出，不会执行后面的代码</p>
<p><img src="https://i-blog.csdnimg.cn/direct/138bd8d4886a45fab323102ad3415406.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/03e4c97343c7487ebb40c70211698faa.png" alt="img"></p>
<p>每一个共享内存都有自己的数据结构，里面就有相应的key值</p>
<p>共享内存+命名管道代码</p>
<hr>
<p><strong>comm.hpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMM_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMM_HPP__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,</span><br><span class="line">    FIFO_DELETE_ERR,</span><br><span class="line">    FIFO_OPEN_ERR</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREATE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//销毁管道</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Log log;</span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> <strong>processa.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Init init;</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ipc code 在这里！！</span></span><br><span class="line">    <span class="comment">// 一旦有人把数据写入到共享内存，其实我们立马能看到了！！</span></span><br><span class="line">    <span class="comment">// 不需要经过系统调用，直接就能看到数据了！</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY); <span class="comment">// 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// struct shmid_ds shmds;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say@ &quot;</span> &lt;&lt; shmaddr &lt;&lt; endl; <span class="comment">//直接访问共享内存</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// shmctl(shmid, IPC_STAT, &amp;shmds);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm size: &quot; &lt;&lt; shmds.shm_segsz &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm nattch: &quot; &lt;&lt; shmds.shm_nattch &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;shm key: 0x%x\n&quot;,  shmds.shm_perm.__key);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm mode: &quot; &lt;&lt; shmds.shm_perm.mode &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除</span></span><br><span class="line">    <span class="comment">//如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>processb.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//processb直接使用即可，共享内存的创建和销毁由processa全权负责</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">GetShm</span>();</span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);                 <span class="comment">// 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一旦有了共享内存，挂接到自己的地址空间中，你直接把他当成你的内存空间来用即可！</span></span><br><span class="line">    <span class="comment">// 不需要调用系统调用</span></span><br><span class="line">    <span class="comment">// ipc code</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(shmaddr, <span class="number">4096</span>, stdin);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);  <span class="comment">// 通知对方</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);         <span class="comment">//去掉共享内存关联</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-System-V消息队列"><a href="#2-System-V消息队列" class="headerlink" title="2. System V消息队列"></a>2. System V消息队列</h4><h5 id="2-1-消息队列基本原理"><a href="#2-1-消息队列基本原理" class="headerlink" title="2.1 消息队列基本原理"></a>2.1 消息队列基本原理</h5><p> 消息队列实际上就是<strong>在系统当中创建了一个队列</strong>，<strong>队列当中的每个成员都是一个数据块</strong>，<strong>这些数据块都由类型和信息两部分构成</strong>，两个互相通信的进程通过某种方式看到同一个消息队列，这两个进程向对方发数据时，都在消息队列的<strong>队尾添加数据块</strong>，这两个进程<strong>获取数据块时</strong>，都在消息队列的<strong>队头取数据块</strong>。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/082663a30ffe4fd9bbd6bc9b93331e8a.png" alt="img"></p>
<p>其中消息队列当中的某一个数据块是由谁发送给谁的，取决于数据块的类型。</p>
<p><strong>总结一下：</strong></p>
<ol>
<li>消息队列提供了一个从一个进程向另一个进程发送数据块的方法。</li>
<li>每个数据块都被认为是有一个类型的，接收者进程接收的数据块可以有不同的类型值。</li>
<li>和共享内存一样，<strong>消息队列的资源也必须自行删除</strong>，否则不会自动清除，因为system V IPC资源的生命周期是随内核的。</li>
</ol>
<hr>
<h5 id="2-2-消息队列数据结构"><a href="#2-2-消息队列数据结构" class="headerlink" title="2.2 消息队列数据结构"></a>2.2 消息队列数据结构</h5><p>​    当然，系统当中也可能会存在大量的消息队列，系统一定也要为消息队列维护相关的内核数据结构。</p>
<p>消息队列的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msqid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span> msg_perm;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">msg</span> *msg_first;      <span class="comment">/* first message on queue,unused  */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">msg</span> *msg_last;       <span class="comment">/* last message in queue,unused */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_stime;  <span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_rtime;  <span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_cbytes;  <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_qnum;    <span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_qbytes;  <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span> msg_lspid;   <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span> msg_lrpid;   <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到消息队列数据结构的第一个成员是<code>msg_perm</code>，它和<code>shm_perm</code>是同一个类型的结构体变量，<code>ipc_perm</code>结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-消息队列的创建"><a href="#2-3-消息队列的创建" class="headerlink" title="2.3 消息队列的创建"></a><strong>2.3 消息队列的创建</strong></h5><p>创建消息队列我们需要用msgget函数，msgget函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数接口几乎与共享内存完全相同，这里还不用传size</strong></p>
<p>说明一下：</p>
<ul>
<li>创建消息队列也<strong>需要使用ftok函</strong>数生成一个key值，这个key值作为msgget函数的第一个参数。</li>
<li><strong>msgget函数的第二个参数</strong>，与创建共享内存时使用的<strong>shmget函数的第三个参数相同</strong>。</li>
<li>消息队列创建成功时，msgget函数返回的一个有效的消息队列标识符（用户层标识符）。</li>
</ul>
<h5 id="2-4-消息队列的释放"><a href="#2-4-消息队列的释放" class="headerlink" title="2.4 消息队列的释放"></a>2.4 消息队列的释放</h5><p>释放消息队列我们需要用msgctl函数，msgctl函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明一下：</strong></p>
<ul>
<li>msgctl函数的参数与释放共享内存时使用的shmctl函数的三个参数相同，只不过msgctl函数的第三个参数传入的是消息队列的相关数据结构</li>
</ul>
<hr>
<p><strong>向消息队列发送数据</strong></p>
<p>向消息队列发送数据我们需要用msgsnd函数，msgsnd函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>msgsnd函数的参数说明：</strong></p>
<ul>
<li>第一个参数msqid，表示消息队列的用户级标识符。</li>
<li>第二个参数msgp，表示待发送的数据块。</li>
<li>第三个参数msgsz，表示所发送数据块的大小</li>
<li>第四个参数msgflg，表示发送数据块的方式，一般默认为0即可。</li>
</ul>
<p><strong>msgsnd函数的返回值说明：</strong></p>
<ul>
<li>msgsnd调用成功，返回0。</li>
<li>msgsnd调用失败，返回-1。</li>
</ul>
<p> 其中<strong>msgsnd</strong>函数的第二个参数必须为以下结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msgbuf</span>&#123;</span><br><span class="line">	<span class="type">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 该结构当中的第二个成员mtext即为待发送的信息，当我们定义该结构时，mtext的大小可以自己指定。</p>
<hr>
<h5 id="2-5-从消息队列获取数据"><a href="#2-5-从消息队列获取数据" class="headerlink" title="2.5 从消息队列获取数据"></a>2.5 从消息队列获取数据</h5><p>从消息队列获取数据我们需要用msgrcv函数，msgrcv函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>msgrcv函数的参数说明：</p>
<ul>
<li>第一个参数msqid，表示消息队列的用户级标识符。</li>
<li>第二个参数msgp，表示获取到的数据块，是一个输出型参数。</li>
<li>第三个参数msgsz，表示要获取数据块的大小</li>
<li>第四个参数msgtyp，表示要接收数据块的类型。</li>
</ul>
<p>msgrcv函数的返回值说明：</p>
<ul>
<li>msgsnd调用成功，返回实际获取到mtext数组中的字节数。</li>
<li>msgsnd调用失败，返回-1。</li>
</ul>
<p><em><strong>*消息队列不作为重点*</strong></em></p>
<hr>
<h4 id="3-System-V信号量"><a href="#3-System-V信号量" class="headerlink" title="3. System V信号量"></a>3. System V信号量</h4><p><strong>3.1 信号量的基本概念</strong></p>
<ul>
<li>定义：信号量是一种用于<strong>保证两个或多个关键代码段不被并发调用的机制</strong>。<strong>线程在进入一个关键代码段之前，必须先获取一个信号量；一旦该关键代码段执行完成，线程必须释放信号量</strong>。</li>
<li><strong>类型</strong>：信号量主要分为<strong>计数信号量（Counting Semaphore）和二元信号量（Binary Semaphore）或称为互斥量（Mutex）</strong>。<strong>计数信号量允许多个线程访问一定数量的资源</strong>，而<strong>二元信号量则只允许一个线程访问资源</strong>。</li>
<li><strong>核心操作</strong>：信号量的核心操作包括<strong>P操作（也称为wait或down操作）</strong>和V操作<strong>（也称为signal或up操作）</strong>。P操作会使信号量的值减1，<strong>如果信号量的值已经为0，则调用线程将会被阻塞</strong>；V操作则使信号量的值加1，如果有线程因为信号量值为0而被阻塞，则这些线程会被唤醒。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">共享内存中，如果进程A正在写入10个数字，只写了一部分，例如5个数字，此时进程B直接就拿走了这5个数字，但是这10个数字必须组合在一起才有意义，所以B拿了也没用，这就会导致数据不一致问题，即A发的数据和B收的数据不一致，这就是没有互斥的弊端。而管道就不会出现这种问题，因为管道数据有原子性</span><br><span class="line"></span><br><span class="line">1. A、B看到的同一份资源——共享资源，如果不加保护，会导致数据不一致问题</span><br><span class="line">2. 加锁 -- 互斥访问 -- 任何时刻只允许一个执行流访问共享资源 -- 互斥 </span><br><span class="line">3. 共享资源，任何时刻只允许一个执行流访问的资源——临界资源 --- 一般是内存空间</span><br><span class="line">4. 如果有100行代码，其中只有5-10行在访问临界资源（访问IPC资源都是代码干的），那么我们访问临界资源的代码叫做临界区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么多进程在显示器上打印的数据又是是错乱的、还会和命令行混在一起？</span><br><span class="line">因为显示器也是被多个进程共享的共享资源，没有互斥保护所以各打各的</span><br></pre></td></tr></table></figure>

<h5 id="3-2-信号量数据结构"><a href="#3-2-信号量数据结构" class="headerlink" title="3.2 信号量数据结构"></a>3.2 信号量数据结构</h5><p>在系统当中也为信号量维护了相关的内核数据结构。</p>
<p>信号量的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span> sem_perm;       <span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> sem_otime;      <span class="comment">/* last semop time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> sem_ctime;      <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem</span>  *sem_base;      <span class="comment">/* ptr to first semaphore in array */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_queue</span> *sem_pending;      <span class="comment">/* pending operations to be processed */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_queue</span> **sem_pending_last;    <span class="comment">/* last pending operation */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_undo</span> *undo;          <span class="comment">/* undo requests on this array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  sem_nsems;      <span class="comment">/* no. of semaphores in array */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量数据结构的第一个成员也是<code>ipc_perm</code>类型的结构体变量，<code>ipc_perm</code>结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-信号量原理"><a href="#3-3-信号量原理" class="headerlink" title="3.3 信号量原理"></a>3.3 信号量原理</h5><p>以停车场的运作为例，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待。此后来的车也都不得不在入口处等待。当有一辆车离开停车场时，看门人得知后，会打开车拦，放入外面的一辆车进去。这个过程中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用——计数信号量（Counting Semaphore）</p>
<p>如果此时只有一个车位，那么就表示只有一辆车能抢占位置，那么我们只需要一个值为1的计数器——二元信号量（Binary Semaphore）或称为互斥量（Mutex）</p>
<p><strong>将临界资源整合，作为一个整体，此时就是互斥原理</strong></p>
<p><strong>信号量是描述临界资源中资源数量的多少</strong>，我们怕的是多个执行流（车）访问同一个资源（车位），所以引入计数器，当计数器为0时，再有执行流申请资源，就不会同意了</p>
<p><strong>但是信号量计数器也是共享资源！它的目的是保护别人的安全，但是前提是它自己是安全的！</strong></p>
<p>所以<strong>信号量的申请和释放是原子的</strong>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">· 信号量本质是一把计数器，信号量的申请和释放（PV）操作是原子的</span><br><span class="line">· 执行流申请资源，必须先申请信号量资源，得到信号量之后才能访问临界资源</span><br><span class="line">· 信号量值为0或1两态的是二元信号量，对应互斥功能</span><br><span class="line">· 申请信号量的本质就是对临界资源的预定机制，就是对计数器的--，即P操作</span><br><span class="line">· 释放资源，释放信号量，本质是对计数器的++，即V操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号量凭什么是进程通信的一种？它又不能进行通信。 </span><br><span class="line">· 通信不仅仅是通信数据，互相协同也算通信</span><br><span class="line">· 要协同本质也是通信，信号量首先要被所有的通信进程看到，即不同的进程看到同一份资源</span><br></pre></td></tr></table></figure>

<p><strong>信号量不能用来通信资源，它是来帮助通信的</strong> </p>
<hr>
<h5 id="3-4-信号量的优缺点"><a href="#3-4-信号量的优缺点" class="headerlink" title="3.4 信号量的优缺点"></a>3.4 信号量的优缺点</h5><ul>
<li><strong>优点</strong>：<ul>
<li>灵活性强：信号量可以用于多种同步场景，如进程同步、资源管理和死锁预防。</li>
<li>可扩展性：信号量可以扩展为计数信号量，用于管理多个同类型资源的并发访问。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>编程复杂度：信号量的使用需要开发者仔细设计同步逻辑，避免出现死锁、优先级反转等问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五、mmap系统调用"><a href="#五、mmap系统调用" class="headerlink" title="五、mmap系统调用"></a>五、mmap系统调用</h3><p><strong>mmap（内存映射文件）</strong>函数是Unix和类Unix系统（包括Linux）中用于<strong>创建内存映射文件的一个系统调用</strong>。它<strong>允许程序将文件或其他对象的内容映射到进程的地址空间</strong>，从而<strong>实现文件内容的高效访问</strong>。通过mmap，<strong>进程可以像访问内存一样访问文件内容</strong>，这可以显著提高处理大文件时的性能，因为操作系统可以更有效地管理内存和磁盘之间的数据传输。</p>
<p>mmap（Memory Mapped File）是<strong>将磁盘上的文件加载到内存中，并将其映射到进程的地址空间中</strong>。这种机制<strong>允许进程通过访问内存的方式（通过指针）来直接操作文件内容</strong>，而无需通过传统的系统调用如read和write来进行数据的读写操作。这样做可以显著提高文件I&#x2F;O操作的效率，尤其是在处理大文件或需要频繁访问文件内容的场景下。</p>
<p><strong>功能：</strong></p>
<ol>
<li><strong>内存映射文件</strong><ul>
<li>将<strong>文件的内容映射到进程的地址空间</strong>中，使得文件内容可以<strong>通过指针直接访问</strong>。</li>
<li>这种方式可以提高文件读写效率，因为它<strong>减少了系统调用的开销</strong>。</li>
</ul>
</li>
<li><strong>匿名内存映射</strong><ul>
<li>创建一块<strong>匿名内存区域</strong>，通常<strong>用于分配动态内存</strong>。这块内存不与任何文件关联。</li>
</ul>
</li>
<li><strong>进程间通信</strong><ul>
<li><strong>多个进程可以映射同一个文件或共享内存区域</strong>，从而实现进程间通信。</li>
</ul>
</li>
</ol>
<h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><p>在C语言中，<code>mmap</code>函数的原型定义在<code>&lt;sys/mman.h&gt;</code>头文件中，其基本形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h4><p>void *addr：建议的映射地址。通常设为NULL，让系统自动选择地址。<br>size_t length：要映射的字节数。<br>int prot：映射区域的保护方式，可以是PROT_READ（可读）、PROT_WRITE（可写）或PROT_EXEC（可执行）的位或操作。<br>int flags：映射选项，常用的有MAP_SHARED（共享映射）和MAP_PRIVATE（私有映射）。<br>int fd：文件描述符，表示要映射的文件。<br>off_t offset：文件映射的偏移量，即从文件的哪个位置开始映射。</p>
<h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p>成功时，<code>mmap</code>返回指向映射区域的指针。失败时，返回<code>MAP_FAILED</code>（其值通常被定义为<code>(void *)-1</code>），并设置<code>errno</code>以指示错误。</p>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h4><p>以下是一个简单的使用<code>mmap</code>来读取文件的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);  </span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error opening file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;sb) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error getting file size&quot;</span>);  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> length = sb.st_size;  </span><br><span class="line">    <span class="type">char</span> *map = <span class="built_in">mmap</span>(<span class="number">0</span>, length, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (map == MAP_FAILED) &#123;  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error mmapping the file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设example.txt是一个文本文件  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents of file:\n%s&quot;</span>, map);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">munmap</span>(map, length) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error un-mmapping the file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">close</span>(fd);  </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ul>
<li>使用完映射区域后，应使用<code>munmap</code>函数来<strong>取消映射</strong>。</li>
<li><strong>映射的文件在进程终止时自动取消映射</strong>，但在进程生命周期内，如果不显式调用<code>munmap</code>或关闭文件描述符，映射会一直保持。</li>
<li><strong>映射的写操作</strong>（当使用<code>MAP_SHARED</code>时）会直接影响磁盘上的文件内容，这可能不是所有应用场景都期望的。</li>
</ul>
<h3 id="四、mmap-的优点"><a href="#四、mmap-的优点" class="headerlink" title="四、mmap 的优点"></a>四、<code>mmap</code> 的优点</h3><ol>
<li><strong>高效性</strong><ul>
<li><code>mmap</code> 提供了高效的文件访问方式，减少了系统调用的开销。</li>
<li>数据直接在内存中操作，无需通过缓冲区复制。</li>
</ul>
</li>
<li><strong>简单性</strong><ul>
<li><code>mmap</code> 提供了简单的接口，使得文件操作类似于内存操作。</li>
</ul>
</li>
<li><strong>灵活性</strong><ul>
<li>支持多种保护权限和映射类型，可以根据需要选择共享或私有映射。</li>
</ul>
</li>
<li><strong>进程间通信</strong><ul>
<li>多个进程可以映射同一个文件或共享内存区域，从而实现进程间通信。</li>
</ul>
</li>
</ol>
<h3 id="五、mmap-的缺点"><a href="#五、mmap-的缺点" class="headerlink" title="五、mmap 的缺点"></a>五、<code>mmap</code> 的缺点</h3><ol>
<li><strong>复杂性</strong><ul>
<li><code>mmap</code> 的使用相对复杂，需要理解内存映射的概念和参数。</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li>需要<strong>手动管理映射区域的取消映射</strong>，否则可能导致内存泄漏。</li>
</ul>
</li>
<li><strong>文件大小限制</strong><ul>
<li><strong>映射区域的大小必须与文件大小一致</strong>，否则可能导致未定义行为</li>
</ul>
</li>
</ol>
<hr>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/07/TCPUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="TCP/UDP网络编程"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-07T11:00:00.000Z" title="2025/1/7 19:00:00">2025-01-07</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:14:39.555Z" title="2025/3/24 23:14:39">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">39 分钟读完 (大约5814个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/07/TCPUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">TCP/UDP网络编程</a></p><div class="content"><h3 id="TCP-UDP网络编程"><a href="#TCP-UDP网络编程" class="headerlink" title="TCP&#x2F;UDP网络编程"></a>TCP&#x2F;UDP网络编程</h3><hr>
<p>网络编程有三个要素，分别是IP地址、端口号和通信协议。</p>
<h2 id="一、IP地址"><a href="#一、IP地址" class="headerlink" title="一、IP地址"></a><strong>一、IP地址</strong></h2><p><strong>网络中的计算机使用IP地址来进行唯一标识</strong>，IP地址有<strong>IPv4和IPv6两种类型</strong>。<strong>IPv4采用十进制或二进制表示形式</strong>，十进制是一种比较常用的表示形式，如<code>192.168.1.131</code>，<strong>IPv6采用十六进制表示形式，一般不常用</strong>。</p>
<p>查看IP地址相关信息：</p>
<p>Windows命令——<code>ipconfig</code></p>
<p>Linux或Mac——ifconfig&#96;命令</p>
<h2 id="二、端口号"><a href="#二、端口号" class="headerlink" title="二、端口号"></a><strong>二、端口号</strong></h2><p>端口号是计算机中的<strong>应用程序的一个整数数字标号，用来区分不同的应用程序</strong>。</p>
<p><code>0 ~ 1023</code> 为被<strong>系统使用或保留的端口号</strong>，<code>0 ~ 65535</code>为有效的端口号，也就是说我们要对一些程序定义端口号的时候，要<strong>选择1024 ~ 65535范围内的整数数字</strong>。</p>
<ul>
<li>ftp服务器：使用21号端口。</li>
<li>ssh服务器：使用22号端口。</li>
<li>telnet服务器：使用23号端口。</li>
<li>http服务器：使用80号端口。</li>
<li>https服务器：使用443号端口。</li>
</ul>
<h2 id="三、通信协议"><a href="#三、通信协议" class="headerlink" title="三、通信协议"></a><strong>三、通信协议</strong></h2><p>说的通俗一点，通信协议就是<strong>网络通信中的规则</strong>，分为TCP协议和UDP协议两种。</p>
<h3 id="第一种：TCP协议"><a href="#第一种：TCP协议" class="headerlink" title="第一种：TCP协议"></a><strong>第一种：TCP协议</strong></h3><p>英文名：Transmission Control Protocol 中文名：<strong>传输控制协议</strong> 协议说明：TCP是一种<strong>面向连接的</strong>、<strong>可靠的、基于字节流的传输层通信协议</strong>。</p>
<p>举例：传输前要建立连接，比如打电话，需要双方都接通，才能进行对话。</p>
<p>特点：效率低，数据传输比较安全，因为有重传机制。</p>
<ul>
<li>面向连接的</li>
<li>可靠的</li>
<li>面向字节流的</li>
</ul>
<hr>
<h4 id="确认应答-ACK-机制"><a href="#确认应答-ACK-机制" class="headerlink" title="确认应答(ACK)机制"></a>确认应答(ACK)机制</h4><p>对于TCP双方发送的每一个报文，<strong>作为接收的一方都需要发送确认应答信息</strong>（ACK）来表示自己已经接收到了对端发送的报文，这样的机制即为确认应答机制，而这种机制保证了对端接收到了信息，也即保证了发送数据的<strong>可靠性</strong>。</p>
<p>TCP将每个字节的数据都进行了编号. 即为序列号;</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/b90309c179712d6c4b4fc81f75ef93cd.png" alt="在这里插入图片描述" style="zoom: 67%;" />

<p>那么主机A与B进行数据传输的时候如下图:</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/929767377829b9d64c3c7bee88a77b24.png" alt="在这里插入图片描述"></p>
<p>应答时ACK标志位置1,每一个ACK都带有对应的<strong>确认序列号</strong>, 意思是告诉发送者, 我已经收到了哪些数据; 从而让发送端<strong>下一次从相应位置开始发</strong>。</p>
<p>这个序列号也解决了数据到达先后顺序的问题。</p>
<hr>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>网络通信中可能存在这种情况:主机A发送数据给B之后, 可能因为<strong>网络拥堵</strong>等原因, <strong>数据无法到达主机B</strong>;</p>
<p>那么如果主机A<strong>在一个特定时间间隔内</strong>没有收到B发来的<strong>确认应答</strong>, <strong>就会进行重发</strong>;</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8265adb6503c1d27e48ddd8ef29bff55.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>情况二:数据到达了主机B，但是主机B的确认应答消息丢失了,那么A还是以为自己的数据没到，再次发送相同消息;这不就重复了吗？</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/56dca2f5a5fb850c46e106a421c8b3c5.png" alt="在这里插入图片描述" style="zoom:67%;" />

<p>没关系,既然B之前已经收到了A的1~1000消息,那么<strong>确认序号就是1001发回A</strong>，即便A没收到确认，但是之后<strong>主机B意识到消息重复了，然后舍弃</strong>;</p>
<p>以上TCP超时重传机制也保证了TCP的可靠性;</p>
<p><strong>那么这个重传所需要等待的时间怎么规范呢？</strong></p>
<p>时间太长，影响整体效率;时间太短，相同数据包可能重复发送;因此,TCP为了保证无论在任何环境下都能比较高性能的通信, 因此会动态计算这个最大超时时间;</p>
<p>Linux中(BSD Unix和Windows也是如此), <strong>超时以500ms为一个单位进行控制</strong>, 每次<strong>判定超时重发的超时时间</strong>都是- <strong>500ms的整数倍</strong>.<br>如果重发一次之后, 仍然得不到应答, 等待 <strong>2</strong>*500ms 后再进行重传.<br>如果仍然得不到应答, 等待 <strong>4</strong>*500ms 进行重传. 依次类推, <strong>以指数形式递增</strong>.<br><strong>累计到一定的重传次数</strong>, TCP认为网络或者对端主机出现异常, <strong>强制关闭连接</strong>,释放资源。</p>
<hr>
<h4 id="连接管理机制"><a href="#连接管理机制" class="headerlink" title="连接管理机制"></a>连接管理机制</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bb37f986f14bcdf93d6f294cd045613e.png" alt="在这里插入图片描述"></p>
<h3 id="三次握手——TCP建立连接"><a href="#三次握手——TCP建立连接" class="headerlink" title="三次握手——TCP建立连接"></a>三次握手——TCP建立连接</h3><p>三次握手是由客户端<strong>connect()<strong>主动发起，之后由</strong>操作系统内部建立</strong>，accpet只是把建立连接的结果拿上到应用层;</p>
<ol>
<li>客户端把含有SYN(同步报文段)标志位的报文发给server请求建立连接；</li>
<li>server系统内部发回给client带有SYN+ACK标志位的报文，表示已收到，确认允许连接请求;</li>
<li>client收到确认信息后，发送ACK确认报文给server;</li>
</ol>
<p>因为connect与accept都是应用层上拿到连接的接口，则<strong>建立连接的具体过程由双方操作系统内部建立起来连接并将连接返回给connect()与accept(),我们可以通过他们的返回值判断连接是否建立成功</strong>！(<strong>连接由connect发起，操作系统内部自动完成！accpet只是看结果用</strong>);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是3次连接？</span><br><span class="line">两次握手不够：无法解决历史连接的干扰问题，也无法确认客户端是否正确接收了服务器的初始序列号。</span><br><span class="line">四次握手多余：会增加连接建立的时间和网络开销，而三次握手已经能够满足可靠性和效率的平衡。</span><br></pre></td></tr></table></figure>

<h3 id="四次挥手——TCP断开连接"><a href="#四次挥手——TCP断开连接" class="headerlink" title="四次挥手——TCP断开连接"></a>四次挥手——TCP断开连接</h3><ol>
<li>每次挥手由断开方调用close(连接sock)发起挥手给对方发送FIN（结束报文段）；</li>
<li>在对方收到断开消息后，回应ACK，表示数据还未发完，稍等一下；</li>
<li>并准备数据处理完后，调用close(sock)与之也准备进行挥手断开；</li>
<li>同时等待ACK（last_ack）;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是四次挥手而不是三次挥手？</span><br><span class="line">三次挥手无法确保数据完整传输：如果接收方还有数据未发送，仅用三次挥手可能会导致数据丢失。</span><br><span class="line">四次挥手能够兼顾可靠性和效率：通过两次FIN和两次ACK，确保双方都能安全地关闭连接。</span><br></pre></td></tr></table></figure>

<h3 id="关于TIME-WAIT状态"><a href="#关于TIME-WAIT状态" class="headerlink" title="关于TIME_WAIT状态"></a>关于<code>TIME_WAIT</code>状态</h3><p><code>TIME_WAIT</code>状态是TCP协议中一个重要的机制，其主要作用是：</p>
<ol>
<li><strong>确保最后一个<code>ACK</code>报文能够被对方收到</strong>：如果对方没有收到<code>ACK</code>报文，可能会重新发送<code>FIN</code>报文，此时<code>TIME_WAIT</code>状态可以<strong>确保连接不会被过早关闭</strong>。</li>
<li><strong>防止历史连接的干扰</strong>：等待<strong>2MSL</strong>（2倍报文最大生存时间）时间，确保网络中残留的报文能够被清理干净，避免对后续连接造成干扰。</li>
</ol>
<p><strong>三次握手和四次挥手充分体现了标志位对区分普通报文和建立连接时的请求\应答报文的重要性。</strong></p>
<hr>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>顾名思义，这个机制类似与算法里的滑动窗口;</p>
<p>之前我们提到过TCP的确认<strong>应答策略</strong>，即对于连接双方发送的每一个数据端，都需要进行ACK确认应答，收到ACK后再发送下一个数据段，但这样做有一个明显的缺陷，<strong>串行</strong>就是性能较差，尤其是数据往返时间较长的时候：</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/214b347d78ef511b1239d4fd4467ea25.png" alt="在这里插入图片描述" style="zoom: 50%;" />

<p>引入<strong>滑动窗口</strong>机制;我们将<strong>发送缓冲区</strong>分为三个部分：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/be23ce351c07e0b1ab3372b829ca25e1.png" alt="在这里插入图片描述"></p>
<p>其中红色标注部分就是滑动窗口，也就是说<strong>滑动窗口本质是发送缓冲区的一部分</strong>，其因为应发送的数据不断变化，而区域也不断变化，就像在滑动一样，故称为滑动窗口。</p>
<p>TCP协议报头里的<strong>16位窗口大小</strong>就是这个滑动窗口的大小,他的大小是受接收方接收缓冲区可用大小制约的，这个大小通过之前通信时接收方发来报头里的<strong>确认序号</strong>传递;</p>
<p><strong>串行</strong>效率差我们来<strong>并行</strong>：</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/fee2649576b5dee25091b51adaf1890f.png" alt="在这里插入图片描述" style="zoom:50%;" />

<ul>
<li>窗口大小指的是<strong>无需等待确认应答而可以继续发送数据的最大值</strong>. 上图的窗口大小就是4000个字节(四个段)</li>
<li>发送前四个段的时候, 不需要等待任何 ACK, 直接发送</li>
<li><strong>收到第一个段的ACK后, 滑动窗口向后移动, 继续发送第五个段的数据; 依次类推</strong></li>
<li>操作系统内核为了维护这个滑动窗口, 需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉;</li>
<li><strong>窗口越大, 则网络的吞吐率就越高</strong>;</li>
</ul>
<p>滑动窗口可以让发送方<strong>一次发送大量数据</strong>，从而保证效率。</p>
<p>滑动窗口可以<strong>配合</strong>对端的接收能力，来<strong>实现流量控制</strong>。</p>
<hr>
<h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><p>在并发传送数据过程中发生了丢包，除了超时重传机制应该怎么解决，这里分两种情况：</p>
<p>情况1:</p>
<p>数据包已经抵达, ACK被丢了</p>
<p>这种情况很容易解决，因为假设A的1~1000数据发过去了，但是B发回来的ack没收到，那么如果B发回来的2001或者更大位置的ack被A收到了(B一定是按顺序收的，如果收到大的index数据，那么证明之前的小序列号的数据已经收了)，则证明A的1~1001其实已经被B收到了，只是ack丢了，不用重新发1~1000了;</p>
<p>情况2：</p>
<p>发送的数据发生了丢包</p>
<p>假如A的1~1000发过去了，那么此时B只收到了1~1000，提醒A下一个是1001以后，A发给B的1001~2000数据丢了！那么B将收不到1001，即便是之后的2001~3000，3001~4000都过来了，B也不能收，只能先存缓冲区，并且返回接下来应该收到的序列1001;</p>
<p>如果A连续收到3次同样的ACK以后，就会意识到自己这个数据包丢了，然后重新发送给B,此时B终于拿到1001，紧接着把之前存到缓冲区的2000 ~3000 ~4000的数据拼起来，最后直接返回个4001ACK给A，A之后就能从4001继续传输数据了;</p>
<p>这种<strong>对付丢包问题的机制就被称为“高速重发机制”（也被叫做“快重传”）</strong>;</p>
<p>这种快重传(效率)可以理解为<strong>并发大量数据包时候的一种丢包处理方法，与超时重传(可靠性)不矛盾</strong>;</p>
<hr>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>其实,在引入滑动窗口这个机制后，流量控制自然显现出来了；流量控制是TCP协议中保证效率的一个重要措施</p>
<p><strong>接收端处理数据的速度是有限的</strong>，如果发送端发的太快, 导致接收端的<strong>缓冲区被打满</strong>, 这个时候如果发送端继续发送,就会造成丢包, 继而引起超时重传等等一系列连锁反应。</p>
<p>因此TCP支持<strong>根据接收端的处理能力, 来决定发送端的发送速度</strong>. 这个机制就叫做流量控制(Flow Control);</p>
<ul>
<li>接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端;<br>窗口大小字段越大, 说明网络的吞吐量越高;</li>
<li>接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;发送端接受到这个窗口之后, 就会减慢自己的发送速度;</li>
<li>如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要<strong>定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端</strong>同时防止接收端的窗口更新通知丢失，也要定期发送窗口探测数据包。</li>
</ul>
<img src="https://i-blog.csdnimg.cn/blog_migrate/2570717e7c97eed2a51e1e7fd14200c6.png" alt="在这里插入图片描述" style="zoom:50%;" />

<p>至于接收端如何把窗口大小告诉发送端呢?</p>
<p>之前我们介绍的<strong>TCP首部中, 有一个16位窗口字段</strong>, 就是存放了窗口大小信息;建立连接的时候就能给到发送端;<br>那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?<br>实际上, TCP首部40字节选项中还包含了一个<strong>窗口扩大因子M</strong>, 实际窗口大小是 <strong>窗口字段的值左移 M 位</strong>。</p>
<hr>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>在刚开始阶段就发送大量的数据, 仍然可能引发问题.因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. <strong>在不清楚当前网络状态下, 贸然发送大量的数据, 是很有可能引起雪上加霜</strong>的.</p>
<p>TCP引入慢启动机制, <strong>先发少量的数据</strong>, 探探路, <strong>摸清当前的网络拥堵状态</strong>, 再决定按照多大的速度传输数据.</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/8745fdcc4de240a1ebd84c6d89404f37.png" alt="在这里插入图片描述" style="zoom:67%;" />

<ul>
<li>此处引入一个概念程为<strong>拥塞窗口</strong>，发送开始的时候, <strong>定义拥塞窗口大小为1</strong>，每次收到一个ACK应答, 拥塞窗口加1(相当于每次启动拥塞窗口大小是上次的一倍);</li>
<li>每次发送数据包的时候, 将拥塞窗口和<strong>接收端主机反馈的窗口大小</strong>做比较, <strong>取较小</strong>的值作为实际发送的窗口;</li>
</ul>
<p>像上面这样的拥塞窗口增长速度, 是指数级别的. “<strong>慢启动</strong>” 只是指<strong>初使时慢</strong>, 但是<strong>增长速度非常快</strong></p>
<ul>
<li>为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍,此处引入一个叫做<strong>慢启动的阈值</strong></li>
<li>当拥塞窗口<strong>超过这个阈值</strong>的时候, <strong>不再按照指数方式增长</strong>, 而是按照<strong>线性方式</strong>增长</li>
</ul>
<img src="https://i-blog.csdnimg.cn/blog_migrate/36b541e5494dfacd2ed6fc455b5019fb.png" alt="在这里插入图片描述" style="zoom:67%;" />

<ul>
<li>当TCP通信开始后, 网络吞吐量会逐渐上升;</li>
<li>如之后如果网络发生拥塞,拥塞控制生效，吞吐量会立刻下降;</li>
<li>这里的拥塞判断有不同策略：1.发生快重传(连续收到重复确认的次数维度) 2. 发生超时重传(等待确认的时间维度)</li>
</ul>
<p><strong>拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案</strong></p>
<hr>
<h3 id="延迟应答"><a href="#延迟应答" class="headerlink" title="延迟应答"></a>延迟应答</h3><p>关于确认应答机制，如果接收数据的主机<strong>立刻返回ACK应答</strong>, 这时候返回的窗口可能比较小;</p>
<ul>
<li>假设接收端缓冲区为1M. 一次收到了500K的数据; 如果立刻应答, 返回的窗口就减少500K;</li>
<li>但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了</li>
<li>在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些（把这500k加上）, 也能处理过来</li>
<li>因此如果<strong>接收端稍微等一会再应答</strong>, 比如等待200ms再应答, 那么这个时候<strong>返回的窗口大小就是1M，显然吞吐量加大了，这就是延迟应答</strong>;</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/2ee420a2b6f843002844f323c0f27f72.png" alt="在这里插入图片描述"></p>
<p>窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率;</p>
<p>延迟应答的具体方式有两种:</p>
<ul>
<li>数量限制: 每隔N个包就应答一次(如上图),一般N &#x3D; 2;</li>
<li>时间限制: <strong>超过最大延迟时间就应答一次</strong>，一般T&#x3D; 200ms，注意，这个延迟时间<strong>应远小于</strong>超时重传时间，不然就帮倒忙了;</li>
</ul>
<hr>
<h4 id="捎带应答"><a href="#捎带应答" class="headerlink" title="捎带应答"></a>捎带应答</h4><p>在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “<strong>一个发送数据，一个确认收到</strong>” 的. 意味着接收方需要发送确认收到的报文给发送方;</p>
<p>可是往往接收方也需要回复数据给确认方，那么就可以<strong>回复ACK顺便捎带上数据</strong>了。</p>
<p>通过抓包工具，可以发现四次挥手怎么只有三次？原因是确认方收到断开信息以后，自己也要断开，就把2，3次挥手用<strong>捎带应答优化</strong>了！</p>
<hr>
<h4 id="TCP异常处理"><a href="#TCP异常处理" class="headerlink" title="TCP异常处理"></a>TCP异常处理</h4><ol>
<li>进程终止: 进程终止会释放文件描述符,此时TCP连接还在,仍然可以发送FIN. 和正常关闭没有什么区别.</li>
<li>机器重启: 和进程终止的情况相同;</li>
<li>机器掉电&#x2F;网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. <strong>如果对方不在, 也会把连接释放</strong>.另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会<strong>定期检测对方的状态</strong>. 例如QQ, 在QQ断线之后, 也会定期尝试重新连接.</li>
</ol>
<p>此外,TCP在面对异常情况可能会发送RST包（重新建立连接请求）。发送RST包的情况通常有：1、端口未打开；2、请求超时；3、提前关闭；4、在一个已关闭的socket上收到数据</p>
<hr>
<h4 id="面向字节流特性"><a href="#面向字节流特性" class="headerlink" title="面向字节流特性"></a>面向字节流特性</h4><p>由于<strong>读&#x2F;写缓冲区的存在</strong>，TCP程序的<strong>读和写</strong>操作<strong>不需要一一匹配</strong>:</p>
<ul>
<li>写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节;</li>
<li>读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次read一个字节, 重复100次。</li>
</ul>
<p>TCP如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出 去;</p>
<p>而<strong>UDP只有接收缓冲区,是面向数据包的</strong>，<strong>固定的发送与读取</strong>！</p>
<hr>
<h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h3><p>粘包问题中的 “包” , 是指的<strong>应用层的数据包</strong>，不是分离报头和有效载荷的报;</p>
<p>站在传输层的角度, TCP是一个一个报文过来的. 按照报头里的序号排好序放在缓冲区中，而站在应用层的角度, 看到的只是一串连续的字节数据，那么应用程序看到了这么一连串的字节数据, 就<strong>不知道从哪个部分开始到哪个部分, 是一个完整的应用层数据包</strong>——<strong>不会分割</strong><br><img src="https://i-blog.csdnimg.cn/blog_migrate/039ca07e2df5ec051ea399836a82b8c9.png" alt="在这里插入图片描述"></p>
<p>解决方法:<strong>明确两个包之间的边界</strong></p>
<ul>
<li>对于<strong>定长</strong>的包,保证每次都<strong>按固定大小读取</strong>即可;eg:没内容的HTTP请求报文Request，就直接按sizeof(Request)单位大小读取;</li>
<li>对于<strong>变长</strong>的包,发送方可以<strong>在包头的位置, 添加约定一个包总长度的字段length</strong>,从而就知道了包的结束位置;接收方就有能力根据单位length分开不同的包了;&#x2F;&#x2F;TCP</li>
<li>对于<strong>变长</strong>的包, 还可以<strong>在包和包之间使用明确的分隔符</strong>(应用层协议, 是程序猿自己来定的, 只要保证分隔 符不和正文冲突即可) eg：HTTP的报头与body正文的分隔符空行&#x2F;n这种规定的方式，在包与包之间加特殊分隔符;</li>
</ul>
<p><strong>UDP不需要考虑粘包：</strong></p>
<ul>
<li>UDP<strong>报头</strong>本身就存在<strong>数据包长度</strong>，按照那个大小就能有效读取;</li>
<li>面向数据报，要么收到完整的UDP报文, 要么不收;不会出现”不完整的半个”的情况.</li>
</ul>
<hr>
<h3 id="第二种：UDP协议"><a href="#第二种：UDP协议" class="headerlink" title="第二种：UDP协议"></a><strong>第二种：UDP协议</strong></h3><p>英文名：User Datagram Protocol 中文名：<strong>数据报协议</strong> 协议说明：UDP是一种<strong>面向无连接的</strong>传输层通信协议。</p>
<p>举例：发短信，<strong>不需要双方建立连接</strong>，But，数据报的大小应限制在64k以内</p>
<p>特点：<strong>效率高，数据传输不安全，容易丢包</strong></p>
<ul>
<li><p><strong>无连接</strong>: 知道对端的IP和端口号就直接进行传输, 不需要建立连接;</p>
</li>
<li><p><strong>不可靠</strong>: <strong>没有确认机制, 没有重传机制</strong>; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层 返回任何错误信息;</p>
</li>
<li><p><strong>面向数据报</strong>: <strong>不能够灵活的控制读写数据的次数和数量</strong>;</p>
</li>
</ul>
<hr>
<h3 id="TCP与UDP对比"><a href="#TCP与UDP对比" class="headerlink" title="TCP与UDP对比"></a>TCP与UDP对比</h3><p>我们既然说了TCP是可靠连接，那么是不是TCP就一定优于UDP呢？这个问题已经老生常谈了。<br>TCP和UDP的优缺点不能简单、绝对的进行比较。</p>
<ul>
<li>TCP用于可靠传输的情况，<strong>应用于文件传输，重要状态更新等场景</strong>，其也有一系列提高效率的机制保证效率。</li>
<li>UDP用于<strong>对高速传输和实时性要求较高的通信领域</strong>，比如早期的qq，视频传输等。另外UDP可以用于广播。</li>
</ul>
<p><strong>UDP实现可靠传输</strong>;（经典面试题）&#x2F;<strong>&#x2F;回答tcp可靠性的的核心方法</strong></p>
<ul>
<li><p><strong>引入确认应答</strong>, 确保对端收到了数据;</p>
</li>
<li><p><strong>引入超时重传</strong>, 如果隔一段时间没有应答, 就重发数据;</p>
</li>
<li><p><strong>引入序列号</strong>, 保证数据顺序;</p>
</li>
</ul>
<hr>
<h2 id="四、三要素关系图与网络模型图"><a href="#四、三要素关系图与网络模型图" class="headerlink" title="四、三要素关系图与网络模型图"></a><strong>四、三要素关系图与网络模型图</strong></h2><p><strong>1、网络编程三要素关系图</strong></p>
<img src="https://img2020.cnblogs.com/other/1218593/202106/1218593-20210616075442940-2118574705.png" alt="img" style="zoom:50%;" />

<p><strong>2、OSI参考模型与TCP&#x2F;IP参考模型</strong></p>
<img src="https://img2020.cnblogs.com/other/1218593/202106/1218593-20210616075443290-934582443.png" alt="img" style="zoom:50%;" />

</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/07/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="进程调度"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-07T11:00:00.000Z" title="2025/1/7 19:00:00">2025-01-07</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:14:55.460Z" title="2025/3/24 23:14:55">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">21 分钟读完 (大约3123个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/07/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/">进程调度</a></p><div class="content"><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><hr>
<p>目的：在进程间切换CPU，最大化CPU的利用率，提高计算机的效率。</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-CPU-I-O执行周期"><a href="#1-1-CPU-I-O执行周期" class="headerlink" title="1.1 CPU-I&#x2F;O执行周期"></a>1.1 CPU-I&#x2F;O执行周期</h3><p>进程的属性：进程执行包括<strong>周期地</strong>进行<strong>CPU执行</strong>和<strong>I&#x2F;O等待</strong>。据此可以将程序分为<strong>CPU密集型程序</strong>和<strong>I&#x2F;O密集型程序</strong>。</p>
<p><strong>CPU密集型程序</strong>一般只有少量长CPU执行；<strong>I&#x2F;O密集型程序</strong>一般具有大量短CPU执行。</p>
<h3 id="1-2-CPU调度程序（CPU-scheduler）"><a href="#1-2-CPU调度程序（CPU-scheduler）" class="headerlink" title="1.2 CPU调度程序（CPU scheduler）"></a>1.2 CPU调度程序（CPU <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=scheduler&spm=1001.2101.3001.7020">scheduler</a>）</h3><p>CPU空闲时，操作系统从<strong>就绪队列</strong>中选择一个进程来执行，进程选择采用<strong>短期调度程序（short-term scheduler）或CPU调度程序</strong>。</p>
<p><strong>调度程序</strong>分为：<strong>短期调度程序</strong>，<strong>中期调度程序</strong>和<strong>长期调度程序</strong>。</p>
<ul>
<li><strong>短期调度程序：</strong>从<strong>准备执行的进程中选择进程</strong>，并分配CPU，这里准备执行的进程理解为<strong>内存中就绪的进程</strong>。</li>
<li><strong>长期调度程序：</strong>从<strong>外部</strong>大容量<strong>存储设备</strong>（通常为磁盘）的<strong>缓冲池</strong>中<strong>选择进程</strong>，<strong>加载到内存</strong>。</li>
<li><strong>中期调度程序：</strong>将<strong>进程从内存（或从CPU竞争）中移出</strong>，从而<strong>降低多道程序程度（内存中的进程数量）</strong>。被调出的进程可被重新调入内存，并从中断处继续运行，这种方案称为<strong>交换</strong>（swap）。通过中期调度程序，<strong>进程可换入（swap in）和换出（swap out）</strong>。</li>
</ul>
<h3 id="1-3-进程状态模型"><a href="#1-3-进程状态模型" class="headerlink" title="1.3 进程状态模型"></a>1.3 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81&spm=1001.2101.3001.7020">进程状态</a>模型</h3><p>其中<strong>七状态模型</strong>包含的情况比较全面，除了进程的<strong>创建、就绪、运行、等待、终止</strong>这五个状态，考虑在执行<strong>虚拟内存管理</strong>的操作系统中，可以将暂时不用的进程（处于就绪态和等待态的进程）<strong>换出（swap out）</strong>到外部存储设备（如硬盘）中，在适当的时间再将其<strong>换入（swap in）</strong>到内存中，此时引入了<strong>就绪挂起</strong>和<strong>等待挂起</strong>状态。</p>
<img src="https://i-blog.csdnimg.cn/blog_migrate/3009cd8554e5148311533d1a374becad.jpeg" alt="img" style="zoom:50%;" />

<h3 id="1-4-抢占调度"><a href="#1-4-抢占调度" class="headerlink" title="1.4 抢占调度"></a>1.4 抢占调度</h3><p>需要<strong>CPU调度的4种情况</strong>：</p>
<ol>
<li>当一个进程从<strong>运行</strong>状态切换到<strong>等待</strong>状态（例如I&#x2F;O请求，或wait()调用）</li>
<li>当一个进程从<strong>运行</strong>状态切换到<strong>就绪</strong>状态（例如当出现<strong>中断</strong>）</li>
<li>当一个进程从<strong>等待</strong>状态切换到<strong>就绪</strong>状态（例如I&#x2F;O完成）</li>
<li>当一个进程<strong>终止</strong>。</li>
</ol>
<p>调度方案分为两种：<strong>（1）非抢占的（nonpreemptive）或协作的（cooperative）</strong>；<strong>（2）抢占的（preemptive）</strong>。<strong>非抢占调度</strong>下，一旦某个进程分配到CPU，该进程会<strong>一直</strong>使用CPU，<strong>直到它终止或切换到等待状态</strong>。<strong>抢占调度</strong>允许第二个进程抢占第一个进程的运行，这中间可能涉及进程共享数据的一致性问题，进程同步问题。</p>
<h3 id="1-5-调度程序（dispatcher）"><a href="#1-5-调度程序（dispatcher）" class="headerlink" title="1.5 调度程序（dispatcher）"></a>1.5 调度程序（<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=dispatcher&spm=1001.2101.3001.7020">dispatcher</a>）</h3><p>这个调度程序在英文原书中称为<strong>“dispatcher”</strong>，与上面说的<strong>CPU调度程序（CPU scheduler）</strong>不同，<strong>CPU scheduler</strong>负责进程的<strong>选择（调度）</strong>，而<strong>dispatcher</strong>负责<strong>将CPU控制交给由CPU schedule（即短期调度程序）选择的进程</strong>，<strong>CPU scheduler负责进程选择，dispatcher实现调度过程的进程切换细节，个人感觉二者属于上下游关系</strong>。</p>
<p><strong>dispatcher</strong>的主要功能如下：</p>
<ul>
<li>切换上下文；</li>
<li>切换到用户模式；</li>
<li>跳转到用户程序的合适位置，以便重新启动程序；</li>
</ul>
<p>调度程序停止一个程序而启动另一个程序所需的时间称为<strong>调度延迟（dispatch latency）</strong>。</p>
<h3 id="1-6-调度准则"><a href="#1-6-调度准则" class="headerlink" title="1.6 调度准则"></a>1.6 调度准则</h3><p>为了比较不同的CPU调度算法，采用一些<strong>比较准则</strong>来评价CPU<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95&spm=1001.2101.3001.7020">调度算法</a>的特性，具体的一些<strong>比较准则包括</strong>：</p>
<ul>
<li><strong>CPU使用率</strong>；</li>
<li><strong>吞吐量（throughput）：</strong>一个时间单元内进程完成的数量；</li>
<li><strong>周转时间（turnaround time）：</strong>进程从提交到进程完成的时间段；</li>
<li><strong>等待时间：</strong>进程在就绪队列种因等待所需的时间；</li>
<li><strong>响应时间：</strong>进程从提交请求到产生第一响应的时间。</li>
</ul>
<p>进程调度的<strong>理想情况</strong>是：<strong>最大化CPU使用率和吞吐量，最小化周转时间、等待时间和响应时间。</strong></p>
<hr>
<h2 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2. 调度算法"></a>2. 调度算法</h2><h3 id="2-1-先到先服务（FCFS）"><a href="#2-1-先到先服务（FCFS）" class="headerlink" title="2.1 先到先服务（FCFS）"></a>2.1 先到先服务（FCFS）</h3><p><strong>先到先服务（First-Come First-Served，FCFS）调度算法</strong>。通过<strong>FIFO</strong><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">队列</a>实现，当一个进程进入就绪队列中的时候，它的<strong>PCB</strong>会被链接到队列尾部；当CPU空闲时，它会分配给位于队列头部的进程，并且这个进程从队列中移去。</p>
<p>特点：</p>
<ul>
<li><strong>平均等待时间</strong>往往很长；</li>
<li>非抢占，可能导致一个进程占用CPU时间过长；</li>
<li>会存在多个I&#x2F;O进程在就绪队列中等待CPU密集型进程的完成（其他进程都等待一个大进程释放CPU），称为<strong>护航效果（convoy effect）</strong>，导致CPU和设备的使用率降低。</li>
</ul>
<h3 id="2-2-最短作业优先调度（SJF）"><a href="#2-2-最短作业优先调度（SJF）" class="headerlink" title="2.2 最短作业优先调度（SJF）"></a>2.2 最短作业优先调度（SJF）</h3><p><strong>最短作业优先（Shortest-Job-First，SJF）调度算法</strong>。将每个进程与其<strong>下次CPU执行长度</strong>关联起来，CPU空闲时会被赋给具有最短CPU执行时间（注意是<strong>下次CPU执行的时间最短</strong>而不是总的时间最短）的进程执行。另一种叫法是：<strong>最短下次CPU执行（shortest-next-CPU-burst）算法</strong>。</p>
<p>特点：</p>
<ul>
<li>SJF算法可以证明<strong>是最优的</strong>，对于给定的一组进程，SJF算法的平均等待时间最短。</li>
<li>SJF算法<strong>困难在于如何确定下次CPU执行的长度</strong>。下次CPU执行通常<strong>预测为以前CPU执行的测量长度的指数平均（exponential average）</strong>。</li>
<li>SJF算法<strong>可以是抢占或非抢占的</strong>。</li>
</ul>
<h3 id="2-3-优先级调度"><a href="#2-3-优先级调度" class="headerlink" title="2.3 优先级调度"></a>2.3 优先级调度</h3><p><strong>优先级调度（priority-scheduling）算法</strong>为每个进程关联一个优先级，具有最高优先级的进程会分到CPU；具有相同优先级的进程按照FCFS的顺序调度。SJF算法是一个简单的优先级算法，其优先级（p）为下次（预测的）CPU执行时间的导数。</p>
<p>特点：</p>
<ul>
<li>优先级算法可以是抢占的或非抢占的；</li>
<li>主要问题是会导致<strong>无穷阻塞（indefinite blocking）</strong>或<strong>饥饿（starvation）</strong>；</li>
<li>解决低优先级进程的无穷等待的方案之一：<strong>老化（aging）</strong>，即<strong>逐渐增加在系统中等待时间很长的进程的优先级</strong>。</li>
</ul>
<h3 id="2-4-轮转调度（RR）"><a href="#2-4-轮转调度（RR）" class="headerlink" title="2.4 轮转调度（RR）"></a>2.4 轮转调度（RR）</h3><p><strong>轮转（Round-Robin，RR）调度算法</strong>，类似FCFS调度，但是<strong>增加了抢占</strong>以切换进程。将一个<strong>较小的时间单元</strong>定义为<strong>时间量（time quantum）或时间片（time slice）</strong>，将就绪队列作为<strong>循环队列</strong>，CPU调度整个就绪队列，为<strong>每个进程分配不超过一个是时间片的CPU</strong>。</p>
<p>特点：</p>
<ul>
<li>RR算法的性能很大程度上取决于<strong>时间片的大小</strong>：时间片<strong>太小</strong>，<strong>频繁的进程上下文切换耗费大量资源</strong>；时间片<strong>太大</strong>，RR<strong>退化成FCFS</strong>。<strong>一般根据经验</strong>，<strong>80％的CPU执行应小于时间片</strong>。</li>
</ul>
<h3 id="2-5-多级队列调度"><a href="#2-5-多级队列调度" class="headerlink" title="2.5 多级队列调度"></a>2.5 多级队列调度</h3><p><strong>多级队列（multilevel queue）调度算法</strong>，将<strong>就绪队列分成多个单独的队列，根据进程属性（如内存大小、进程优先级、进程类型等）</strong>，<strong>一个进程永久分到一个队列</strong>，<strong>每个队列有自己的调度算法</strong>。例如可有两个队列分别用于前台进程和后台进程，前台队列可采用RR算法调度，后台队列采用FCFS算法调度。</p>
<p>多级队列调度算法实例，有五个队列，优先级由高到低，分别为：（1）系统进程；（2）交互进程；（3）交互编辑进程；（4）批处理进程；（5）学生进程。其中每个队列与更低层队列相比具有绝对的优先，例如只有系统进程、交互进程和交互编辑进程队列都为空，批处理队列内的进程才能运行。如果一个批处理进程运行过程中有一个交互进程进入就绪队列，那么该批处理进程会被抢占。</p>
<p>另一种可能是，<strong>在队列之间划分时间片</strong>，每个队列具有一定比例的CPU时间，可用于调度队列内的进程。例如对于前台-后台队列例子，前台队列可有80％的CPU时间，用于进程之间的RR调度；后台队列可以有20％的CPU时间，用于按FCFS算法来调度进程。</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/02c1cefa7f32e27124e1f033e3026e36.jpeg" alt="img"></p>
<h3 id="2-6-多级反馈队列调度"><a href="#2-6-多级反馈队列调度" class="headerlink" title="2.6 多级反馈队列调度"></a>2.6 多级反馈队列调度</h3><p><strong>多级反馈队列调度（multilevel feedback queue）调度算法</strong>允许<strong>进程在队列之间迁移</strong>，其特点在于：</p>
<ul>
<li>如果<strong>进程使用过多的CPU时间，其将会被放到更低的优先级队列</strong>；</li>
<li><strong>I&#x2F;O密集型和交互进程放在更高优先级队列</strong>上；</li>
<li>在<strong>较低优先级队列中等待过长的进程会被移到更高优先级队列</strong>，以<strong>阻止饥饿</strong>的发生。</li>
</ul>
<p>多级反馈队列调度程序可由下列参数定义：</p>
<ul>
<li>队列数量；</li>
<li>每个队列的调度算法；</li>
<li>用以确定何时升级到最高优先级队列的方法；</li>
<li>用以确定何时降级到最低优先级队列的方法；</li>
<li>用以确定进程在需要服务时将会进入那个队列的方法。</li>
</ul>
<h2 id="3-线程调度"><a href="#3-线程调度" class="headerlink" title="3 线程调度"></a>3 线程调度</h2><p>线程可以分为<strong>用户级（user-level）线程</strong>和<strong>内核级（kernel-level）线程</strong>。<strong>在支持线程的操作系统上</strong>，<strong>内核级线程（而不是进程）才是操作系统所调度的</strong>。这里理解为上述的进程调度算法，其实就CPU而言，并不严格区分该算法究竟是用于调度进程还是用于调度线程，而是用于调度<strong>基本的调度单元</strong>，<strong>在支持线程的操作系统上，线程才是CPU调度的基本单元</strong>，此时上述调度算法此时用于线程调度。</p>
<p>关于用户级线程和内核级线程：<strong>用户级线程是由线程库管理的</strong>，内核并不知道。用户级线程最后运行在CPU上，<strong>映射</strong>到相应的内核级线程，这种映射不是直接的，可能采用<strong>轻量级进程（Light Weight Process，LWP）</strong>，因此<strong>内核级线程和用户级线程的调度具体实现仍有所区别</strong>。</p>
<ul>
<li><strong>进程竞争范围</strong>（Process-Contention Scope，PCS）：对于<strong>实现多对一和多对多模型的系统线程库会调用用户级线程</strong>，以便在可用LWP上运行。<strong>线程调度</strong>到<strong>可用LWP</strong>上并不意味着线程真实运行在一个CPU上，而是<strong>需要系统调度内核线程到物理CPU</strong>）</li>
<li><strong>系统竞争范围</strong>（System-Contention Scope）：为了<strong>决定哪个内核线程调度到同一个处理器上</strong>，内核采用SCS竞争CPU。<strong>采用一对一模型的系统如Windows、Linux和Solaris只采用SCS调度</strong></li>
</ul>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/06/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Socket网络编程"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-06T11:00:00.000Z" title="2025/1/6 19:00:00">2025-01-06</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:14:23.072Z" title="2025/3/24 23:14:23">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">21 分钟读完 (大约3086个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/06/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Socket网络编程</a></p><div class="content"><h3 id="Socket网络编程"><a href="#Socket网络编程" class="headerlink" title="Socket网络编程"></a>Socket网络编程</h3><hr>
<p><strong>网络知识介绍</strong></p>
<ol>
<li><p>客户端和服务端<br>    网络程序是由两个部分组成的–客户端和服务器端.</p>
<ol>
<li>客户端——主动和外面的程序通信的程序</li>
<li>服务端——和客户端相对应，被动的等待外面的程序来和自己通讯的程序。<br>    实际生活中有些程序是互为服务和客户端。在这种情况下， 一个程序既为客户端也是服务端。</li>
</ol>
</li>
<li><p>常用的命令<br>    由于网络程序是有两个部分组成,所以在调试的时候比较麻烦,为此我们有必要知道一些常用的网络命令<br> netstat<br> 命令netstat是用来显示网络的连接,路由表和接口统计等网络的信息.netstat有许多的选项.<br> 我们常用的选项是-na 用来显示详细的网络状态.至于其它的选项我们可以使用帮助手册获得详细的情况.</p>
<p> telnet<br> telnet是一个用来登录远程的程序,但是我们完全可以用这个程序来调试我们的服务端程序的.<br> 比如我们的服务器程序在监听8888端口,我们可以用telnet localhost 8888来查看服务端的状况.</p>
<p> ping<br> ping程序用来判断网络的状态是否正常，最经常的一个用法是ping 192.168.0.1<br> 表示我们想查看到192.168.0.1的硬件连接是否正常</p>
</li>
</ol>
<hr>
<h3 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a><strong>TCP编程</strong></h3><p> Linux系统是通过提供<strong>套接字(socket)<strong>来进行网络编程的.网络程序通过socket和其它几个函数的调用,<br> 会返回一个</strong>通讯的文件描述符</strong>,我们可以将这个描述符看成普通的文件的描述符来操作,这就是linux的设备无关性的好处.<br>我们可以通过<strong>向描述符读写操作实现网络之间的数据交流</strong>.</p>
<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193208670.png" alt="image-20250321193208670" style="zoom: 67%;" />

<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193308447.png" alt="image-20250321193308447"></p>
<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193321947.png" alt="image-20250321193321947" style="zoom:67%;" />

<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193456509.png" alt="image-20250321193456509" style="zoom:67%;" />

<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193724182.png" alt="image-20250321193724182" style="zoom:67%;" />

<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193749513.png" alt="image-20250321193749513" style="zoom:67%;" />

<img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250321193802148.png" alt="image-20250321193802148" style="zoom:67%;" />

<hr>
<p><strong>服务端流程：</strong></p>
<ol>
<li>首先调用<strong>socket</strong>得到一个sockfd，类似文件句柄，此时其中没有任何ip信息；</li>
<li>调用<strong>bind</strong>绑定一个端口：表明这个服务器要监测这个ip的这个端口，地址信息来自结构体；</li>
<li>调用<strong>listen</strong>函数开始监测；</li>
<li>在while(1)中调用<strong>accept</strong>函数来等待客户端的连接，如果有客户端来连接，返回一个来自客户端的sockfd；</li>
<li>连接后，统计一下连接数，打印一些信息表示连接成功；</li>
<li>如果等待多个客户端连接，那么就在连接并打印信息后，对于每个客户端创建一个子进程，在子进程中，用<strong>recv</strong>函数，传入客户端sockfd和缓冲区，接受客户端发来的数据并显示出来。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	包含的系统调用：</span></span><br><span class="line"><span class="comment">	socket</span></span><br><span class="line"><span class="comment">	bind</span></span><br><span class="line"><span class="comment">	listen</span></span><br><span class="line"><span class="comment">	accept</span></span><br><span class="line"><span class="comment">	send/recv</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"><span class="comment">// 连接数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BACKLOG 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> iSocketServer;<span class="comment">// 返回的sockfd</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;<span class="comment">// 服务端地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketClientAddr;<span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> iSocketClient;<span class="comment">// 客户端sockfd</span></span><br><span class="line">    <span class="type">int</span> iRet;<span class="comment">// 返回值</span></span><br><span class="line">    <span class="type">int</span> iAddrLen;<span class="comment">// 地址长度</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iRecvLen;<span class="comment">// 接受到的数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> iClientNum = <span class="number">-1</span>;<span class="comment">// 接收到的客户端连接数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一下结构体</span></span><br><span class="line">    tSocketServerAddr.sin_family = AF_INET;<span class="comment">// 进程间通信还是Internet</span></span><br><span class="line">    tSocketServerAddr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);<span class="comment">// 要监听的端口号 host to net, short,字节序的转换</span></span><br><span class="line">    tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">// 本机上所有的ip</span></span><br><span class="line">    <span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);<span class="comment">// 设置为0，8字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    iSocketServer = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">// 选择Internet和TCP</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iSocketServer)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    iRet = <span class="built_in">bind</span>(iSocketServer, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听</span></span><br><span class="line">    iRet = <span class="built_in">listen</span>(iSocketServer, BACKLOG);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待一条连接并接受</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 传入客户端地址信息</span></span><br><span class="line">        iAddrLen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">        iSocketClient = <span class="built_in">accept</span>(iSocketServer, (<span class="keyword">struct</span> sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> != iSocketClient)&#123;</span><br><span class="line">            iClientNum++;<span class="comment">// 连接数加一</span></span><br><span class="line">            <span class="comment">// 返回不为-1则说明连接成功，并打印客户端地址信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Get connect from client %d : %s\n&quot;</span>, iClientNum, <span class="built_in">inet_ntoa</span>(tSocketClientAddr.sin_addr));<span class="comment">// inet_ntoa 将地址信息转换为我们能看懂的字符串</span></span><br><span class="line">            <span class="comment">// 用子进程去接受数据</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == fork())&#123;</span><br><span class="line">                <span class="comment">// child</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 接受客户端发来的数据并显示出来</span></span><br><span class="line">                    iRecvLen = <span class="built_in">recv</span>(iSocketClient, ucRecvBuf, <span class="number">999</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(iRecvLen &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// 接受出错</span></span><br><span class="line">                        <span class="built_in">close</span>(iSocketClient);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// 接受成功，打印缓冲区的消息</span></span><br><span class="line">                        ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;Get Msg From Client %d: %s\n&quot;</span>, iClientNum, ucRecvBuf);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(iSocketServer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>客户端流程：</strong></p>
<ol>
<li>调用<strong>socket</strong>得到一个客户端句柄；</li>
<li>调用<strong>connect</strong>函数让服务端连接到客户端句柄，传入服务端的地址信息；</li>
<li>连接成功后，在while(1)中先用<strong>fgets</strong>从标准输入得到数据存储缓冲区，再调用<strong>send</strong>函数将缓冲区的数据发送出去。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	包含的系统调用：</span></span><br><span class="line"><span class="comment">	socket</span></span><br><span class="line"><span class="comment">	connect</span></span><br><span class="line"><span class="comment">    send/recv</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// client.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> iSocketClient;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;<span class="comment">// 服务端地址信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketClientAddr;<span class="comment">// 客户端地址信息</span></span><br><span class="line">    <span class="type">int</span> iRet;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> iSendLen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iSocketClient = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一下结构体</span></span><br><span class="line">    tSocketServerAddr.sin_family = AF_INET;<span class="comment">// 进程间通信还是Internet</span></span><br><span class="line">    tSocketServerAddr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);<span class="comment">// 要监听的端口号 host to net, short,字节序的转换</span></span><br><span class="line">    <span class="comment">// tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// 本机上所有的ip</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">inet_aton</span>(argv[<span class="number">1</span>], &amp;tSocketServerAddr.sin_addr))<span class="comment">// 将命令行输入的服务端ip存到结构体里</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;invalid server_ip\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);<span class="comment">// 设置为0，8字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为客户端fd连接服务端地址信息</span></span><br><span class="line">    iRet = <span class="built_in">connect</span>(iSocketClient, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == iRet)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 从标准输入获得数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fgets</span>(ucSendBuf, <span class="number">999</span>, stdin))&#123;</span><br><span class="line">            <span class="comment">// 如果获得了数据，用send发送数据</span></span><br><span class="line">            iSendLen = <span class="built_in">send</span>(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(iSendLen &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 发送出错</span></span><br><span class="line">                <span class="built_in">close</span>(iSocketClient);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行写好的客户端和服务端程序</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.先运行服务端</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./server</span></span><br><span class="line">2.(另一个终端)运行客户端加服务端ip</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">./client 192.168.1.123</span></span><br><span class="line">3.(连接成功)服务端收到连接成功的信息</span><br><span class="line">4.(客户端发送数据)发送abc</span><br><span class="line">5.(服务端接受数据)从client 0收到abc</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>关于僵尸进程——子进程退出</strong></p>
<p>是指一个完成执行的子进程，这个<strong>子进程通过系统调用exit或其他方式退出后</strong>，<strong>父进程还没有通过wait或waitpid等系统调用来回收它的资源和状态信息</strong>，这时候会留下一个僵尸进程，用ps命令可以看到进程状态显示为“Z”，它不占内存和cpu，但是占用进程表项。</p>
<p>通常的危害就是占用了进程号，增加了os的管理负担。</p>
<p><strong>如何避免？</strong></p>
<ul>
<li>在父进程中，在子进程结束时调用wait或wait系统调用来获取子进程的退出状态并让os回收资源。</li>
<li>用SIGCHLD信号，父进程注册一个信号处理函数来处理SIGCHLD信号。</li>
<li>或者让父进程在子进程之前退出，一般不用，此时子进程会被init进程接管并清理掉。用kill -9 父进程pid来杀死父进程。</li>
</ul>
<p><strong>SIGCHLD信号</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在一个程序的开始调用：</span><br><span class="line"><span class="built_in">signal</span>(SIGCHLD,SIG_IGN);</span><br><span class="line">意思是调用signal将SIGCHLD的配置设置为忽略，就不会产生僵尸进程了。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h3><p><strong>服务端流程：</strong></p>
<ol>
<li>调用<strong>socket</strong>获得一个服务端句柄；</li>
<li>将ip和端口，调用<strong>bind</strong>绑定这个服务端句柄；</li>
<li>直接使用<strong>recvfrom</strong>接受数据。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * bind</span></span><br><span class="line"><span class="comment"> * sendto/recvfrom</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketServer;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketClientAddr;</span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">int</span> iAddrLen;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iRecvLen;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucRecvBuf[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> iClientNum = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	iSocketServer = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iSocketServer)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;socket error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">	</span><br><span class="line">	iRet = <span class="built_in">bind</span>(iSocketServer, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;bind error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		iAddrLen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">		iRecvLen = <span class="built_in">recvfrom</span>(iSocketServer, ucRecvBuf, <span class="number">999</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen);</span><br><span class="line">		<span class="keyword">if</span> (iRecvLen &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ucRecvBuf[iRecvLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Get Msg From %s : %s\n&quot;</span>, <span class="built_in">inet_ntoa</span>(tSocketClientAddr.sin_addr), ucRecvBuf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">close</span>(iSocketServer);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>客户端流程：</strong></p>
<ol>
<li>调用<strong>socket</strong>获得一个客户端句柄；</li>
<li>为客户端句柄，调用<strong>connect</strong>连接服务端地址信息；</li>
<li>直接使用<strong>send&#x2F;sendto</strong>发送数据。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* socket</span></span><br><span class="line"><span class="comment"> * connect</span></span><br><span class="line"><span class="comment"> * send/recv</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8888</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> iSocketClient;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> tSocketServerAddr;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> iRet;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> ucSendBuf[<span class="number">1000</span>];</span><br><span class="line">	<span class="type">int</span> iSendLen;</span><br><span class="line">	<span class="type">int</span> iAddrLen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s &lt;server_ip&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	iSocketClient = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	tSocketServerAddr.sin_family      = AF_INET;</span><br><span class="line">	tSocketServerAddr.sin_port        = <span class="built_in">htons</span>(SERVER_PORT);  <span class="comment">/* host to net, short */</span></span><br><span class="line"> 	<span class="comment">//tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line"> 	<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">inet_aton</span>(argv[<span class="number">1</span>], &amp;tSocketServerAddr.sin_addr))</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;invalid server_ip\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(tSocketServerAddr.sin_zero, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	iRet = <span class="built_in">connect</span>(iSocketClient, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr));	</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == iRet)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fgets</span>(ucSendBuf, <span class="number">999</span>, stdin))</span><br><span class="line">		&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">			iSendLen = <span class="built_in">send</span>(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">			iAddrLen = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">			iSendLen = <span class="built_in">sendto</span>(iSocketClient, ucSendBuf, <span class="built_in">strlen</span>(ucSendBuf), <span class="number">0</span>,</span><br><span class="line">			                      (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;tSocketServerAddr, iAddrLen);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			<span class="keyword">if</span> (iSendLen &lt;= <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">close</span>(iSocketClient);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行和TCP一样</strong></p>
<hr>
<p><strong>服务器和客户机的信息函数</strong></p>
<p><strong>3.1 字节转换函数</strong></p>
<p><em>在网络上面有着许多类型的机器</em><em>,<strong>这些机器在表示数据的字节顺序是不同的,* *比如</strong>i386<strong>芯片是低字节在内存地址的低端</strong>,<br><strong>高字节在高端</strong>,<strong>而</strong>alpha*<em>芯片却相反，</em>为了统一起来*</em>,<strong>在</strong>Linux<strong>下面</strong>,*<em>有专门的字节转换函数</em>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span><span class="params">(unisgned <span class="type">short</span> <span class="type">int</span> hostshort)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort)</span></span></span><br></pre></td></tr></table></figure>

<p>在这四个转换函数中,h 代表host, n 代表 network.</p>
<p>s 代表short ，l 代表long<br>第一个函数的意义是将本机器上的long数据转化为网络上的long. 其他几个函数的意义也差不多.</p>
<p><strong>3.2 IP和域名的转换</strong><br>在网络上标志一台机器可以用IP或者是用域名.那么我们怎么去进行转换呢?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyname</span>(<span class="type">const</span> <span class="type">char</span> *hostname)</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span> *<span class="built_in">gethostbyaddr</span>(<span class="type">const</span> <span class="type">char</span> *addr,<span class="type">int</span> len,<span class="type">int</span> type)</span><br><span class="line"><span class="comment">// struct hostent的定义：</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hostent</span>&#123;</span><br><span class="line">        <span class="type">char</span> *h_name;           <span class="comment">/* 主机的正式名称  */</span></span><br><span class="line">        <span class="type">char</span> *h_aliases;        <span class="comment">/* 主机的别名 */</span></span><br><span class="line">        <span class="type">int</span>   h_addrtype;       <span class="comment">/* 主机的地址类型  AF_INET*/</span></span><br><span class="line">        <span class="type">int</span>   h_length;         <span class="comment">/* 主机的地址长度  对于IP4 是4字节32位*/</span></span><br><span class="line">        <span class="type">char</span> **h_addr_list;     <span class="comment">/* 主机的IP地址列表 */</span></span><br><span class="line">        &#125;</span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> h_addr h_addr_list[0]  <span class="comment">/* 主机的第一个IP地址*/</span></span></span><br><span class="line"></span><br><span class="line">gethostbyname可以将机器名(如 linux.yessun.com)转换为一个结构指针.在这个结构里面储存了域名的信息</span><br><span class="line">gethostbyaddr可以将一个<span class="number">32</span>位的IP地址(C0A80001)转换为结构指针.</span><br><span class="line">这两个函数失败时返回<span class="literal">NULL</span> 且设置h_errno错误变量,调用<span class="built_in">h_strerror</span>()可以得到详细的出错信息</span><br></pre></td></tr></table></figure>

<p><strong>3.3 字符串的IP和32位的IP转换.</strong><br>在网络上面我们用的IP都是数字加点(192.168.0.1)构成的, 而在struct in_addr结构中用的是32位的IP,<br>我们上面那个32位IP(C0A80001)是的192.168.0.1 为了转换我们可以使用下面两个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp,<span class="keyword">struct</span> in_addr *inp)</span></span></span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span></span><br></pre></td></tr></table></figure>

<p>函数里面 a 代表 ascii n 代表network.第一个函数表示将a.b.c.d的IP转换为32位的IP,<br>存储在 inp指针里面.第二个是将32位IP转换为a.b.c.d的格式.</p>
<p><strong>3.4 服务信息函数</strong><br>在网络程序里面我们有时候需要知道端口.IP和服务信息.这个时候我们可以使用以下几个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsockname</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *localaddr,<span class="type">int</span> *addrlen)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(<span class="type">int</span> sockfd,<span class="keyword">struct</span> sockaddr *peeraddr, <span class="type">int</span> *addrlen)</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *servname,<span class="type">const</span> <span class="type">char</span> *protoname)</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> servent *<span class="title">getservbyport</span><span class="params">(<span class="type">int</span> port,<span class="type">const</span> <span class="type">char</span> *protoname)</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> servent</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                <span class="type">char</span> *s_name;          <span class="comment">/* 正式服务名 */</span></span><br><span class="line">                <span class="type">char</span> **s_aliases;      <span class="comment">/* 别名列表 */</span>  </span><br><span class="line">                <span class="type">int</span> s_port;            <span class="comment">/* 端口号 */</span></span><br><span class="line">                <span class="type">char</span> *s_proto;         <span class="comment">/* 使用的协议 */</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>一般我们很少用这几个函数.对应客户端,当我们要得到连接的端口号时在connect调用成功后使用可得到<br>系统分配的端口号.对于服务端,我们用INADDR_ANY填充后,为了得到连接的IP我们可以在accept调用成功后 使用而得到IP地址.<br>在网络上有许多的默认端口和服务,比如端口21对ftp80对应WWW.为了得到指定的端口号的服务 我们可以调用第四个函数,<br>相反为了得到端口号可以调用第三个函数.</p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/05/Linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Linux基础和常用命令"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-05T11:00:00.000Z" title="2025/1/5 19:00:00">2025-01-05</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:13:41.167Z" title="2025/3/24 23:13:41">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">5 分钟读完 (大约677个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/05/Linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux基础和常用命令</a></p><div class="content"><h3 id="Linux基础和常用命令"><a href="#Linux基础和常用命令" class="headerlink" title="Linux基础和常用命令"></a>Linux基础和常用命令</h3><hr>
<p><strong>Linux目录和具体内容</strong></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214529070.png" alt="image-20250322214529070"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214816887.png" alt="image-20250322214816887"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214824576.png" alt="image-20250322214824576"></p>
<hr>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214843127.png" alt="image-20250322214843127"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214916589.png" alt="image-20250322214916589"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322214946293.png" alt="image-20250322214946293"></p>
<h3 id="2-3-2-目录-文件操作命令"><a href="#2-3-2-目录-文件操作命令" class="headerlink" title="2.3.2 目录&#x2F;文件操作命令"></a>2.3.2 目录&#x2F;文件操作命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1. pwd —— 打印当前路径</span><br><span class="line">2. cd —— 切换路径</span><br><span class="line">	1.1 cd - —— 上次目录</span><br><span class="line">	1.2 cd ~ —— 进入家目录</span><br><span class="line">3. mkdir —— 创建目录</span><br><span class="line">4. rmdir —— 删除目录</span><br><span class="line">5. ls —— 列出目录内容</span><br><span class="line">	1.1 ls -a —— 列出所有文件，包括隐藏文件</span><br><span class="line">	1.2 ls -l / ll —— 以详细列表的形式列出目录内容</span><br><span class="line">	1.3 ls -h —— 以人类可读的方式列出来</span><br><span class="line">6. cp —— 复制文件或目录</span><br><span class="line">	6.1 cp -r 递归地复制所有文件</span><br><span class="line">	6.2 cp -f 强制覆盖 -d 作为链接文件复制</span><br><span class="line">7. rm —— 删除文件或目录 -r -f</span><br><span class="line">8. cat —— 打印文件内容到标准输出</span><br><span class="line">9. touch —— 修改文件时间或创建空文件</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215618803.png" alt="image-20250322215618803"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215625921.png" alt="image-20250322215625921"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215640632.png" alt="image-20250322215640632"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215653544.png" alt="image-20250322215653544"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215741821.png" alt="image-20250322215741821"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215754124.png" alt="image-20250322215754124"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215859534.png" alt="image-20250322215859534"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322215907464.png" alt="image-20250322215907464"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220057558.png" alt="image-20250322220057558"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220234675.png" alt="image-20250322220234675"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220300186.png" alt="image-20250322220300186"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220311722.png" alt="image-20250322220311722"></p>
<hr>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220532075.png" alt="image-20250322220532075"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220617300.png" alt="image-20250322220617300"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322220753012.png" alt="image-20250322220753012"></p>
<hr>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222005809.png" alt="image-20250322222005809"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222125415.png" alt="image-20250322222125415"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222302956.png" alt="image-20250322222302956"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222435024.png" alt="image-20250322222435024"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222532178.png" alt="image-20250322222532178"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222547172.png" alt="image-20250322222547172"></p>
<hr>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222625095.png" alt="image-20250322222625095"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222724248.png" alt="image-20250322222724248"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222742356.png" alt="image-20250322222742356"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222851537.png" alt="image-20250322222851537"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222922265.png" alt="image-20250322222922265"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322222942706.png" alt="image-20250322222942706"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322223028376.png" alt="image-20250322223028376"></p>
<hr>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322223049443.png" alt="image-20250322223049443"></p>
<h3 id="就是记事本"><a href="#就是记事本" class="headerlink" title="就是记事本"></a>就是记事本</h3><p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322223119393.png" alt="image-20250322223119393"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322223144752.png" alt="image-20250322223144752"></p>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250322223212571.png" alt="image-20250322223212571"></p>
<hr>
<h3 id="su命令-切换当前用户"><a href="#su命令-切换当前用户" class="headerlink" title="su命令 切换当前用户"></a>su命令 切换当前用户</h3><hr>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/05/modern%20C++%20%E6%96%B0%E7%89%B9%E6%80%A7/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="modern C++"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-05T11:00:00.000Z" title="2025/1/5 19:00:00">2025-01-05</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:14:05.606Z" title="2025/3/24 23:14:05">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">16 分钟读完 (大约2471个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/05/modern%20C++%20%E6%96%B0%E7%89%B9%E6%80%A7/">modern C++</a></p><div class="content"><h3 id="modern-C-新特性"><a href="#modern-C-新特性" class="headerlink" title="modern C++ 新特性"></a>modern C++ 新特性</h3><hr>
<p><strong>1. C++11 委托构造函数</strong></p>
<p>允许一个构造函数调用同一个类中的另一个构造函数来初始化对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> param1, <span class="type">int</span> param2) &#123;</span><br><span class="line">        <span class="comment">// 构造函数的具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> param) : <span class="built_in">MyClass</span>(param, <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 委托给另一个构造函数完成初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不能同时使用委托构造函数和成员初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> param) : <span class="built_in">MyClass</span>(param, <span class="number">0</span>), <span class="built_in">param_</span>(param) &#123; <span class="comment">// 错误：不能同时使用委托构造函数和成员初始化列表</span></span><br></pre></td></tr></table></figure>

<p>可以形成一个链，叫委托链，一层一层调用，但是不能互相调用，形成调用闭环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> param1, <span class="type">int</span> param2, <span class="type">int</span> param3) : <span class="built_in">param1_</span>(param1), <span class="built_in">param2_</span>(param2), <span class="built_in">param3_</span>(param3) &#123;</span><br><span class="line">       <span class="comment">// A：构造函数</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> param1, <span class="type">int</span> param2) : <span class="built_in">MyClass</span>(param1, param2, <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// B：委托构造函数，调用A</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">MyClass</span>(<span class="type">int</span> param1) : <span class="built_in">MyClass</span>(param1, <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// C: 委托构造函数，调用B</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong></p>
<ul>
<li>减少代码重复，避免在多个构造函数之间重复相同的初始化代码</li>
<li>修改类的初始化逻辑时，只需要在一个地方进行修改，避免重复</li>
<li>如果类之前有多个构造函数，委托构造函数可以简化这些构造函数的实现，尤其是重复的初始化步骤</li>
</ul>
<hr>
<p><strong>2. C++11 类内初始化</strong></p>
<p>以前如果要对结构体或者类成员变量进行初始化——使用初始化列表或者构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">float</span> f;</span><br><span class="line">	<span class="type">bool</span> b;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Data</span>():<span class="built_in">i</span>(<span class="number">0</span>),<span class="built_in">f</span>(<span class="number">0</span>),<span class="built_in">b</span>(<span class="literal">true</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++11后，类成员变量的初始化可以直接赋值，类似普通变量初始化，定义的时候直接初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="type">float</span> f = <span class="number">2.0</span>;</span><br><span class="line">	<span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3. 空指针nullptr</strong></p>
<p>传统C++中，使用大写NULL的宏 代表空指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br></pre></td></tr></table></figure>

<p>C++在编译时有一些类型检查，可以避免一些错误，但是宏是预编译的，在编译之前进行的是简单地语句替换，编译器就不能进行类型检查，可能会出错：</p>
<p>比如我们可以给int和float赋给NULL，这时候如果我们重载两个同名函数，调用的时候编译器不知道具体调用哪个函数，因为宏定义的语句替换后，int和float是0，是合法的。</p>
<p><strong>所以在C++11后，对任何空指针都推荐使用nullptr表示，此时如果将nullptr赋给int，编译器会报错</strong></p>
<hr>
<p><strong>4. 枚举类 enum class 对旧枚举类的增强</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Number</span> &#123; One, Two, Three&#125;;<span class="comment">// 旧的</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Number</span> &#123; One, Two, Three&#125;;<span class="comment">// 新的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Number num = Number::One;<span class="comment">// 枚举类的使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能避免命名冲突：定义两个枚举类，里面具有相同名字的值都是可以的</p>
<hr>
<p><strong>5. C++11 类型推导 auto</strong></p>
<p>比如对一个vector的遍历，for循环中需要定义一个很长数据类型的迭代器，此时可以用auto，让编译器自己推导：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = numbers.<span class="built_in">cbegin</span>(); it != numbers.<span class="built_in">cend</span>(); ++it)</span><br><span class="line">    <span class="comment">// auto 可以代替vector&lt;int&gt;::const_iterator </span></span><br></pre></td></tr></table></figure>

<p>而且可以推导任意类型变量——不推荐，可读性差：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">1.5f</span>;</span><br><span class="line"><span class="keyword">auto</span> c = a + b;</span><br></pre></td></tr></table></figure>

<p>auto还可以作为函数的返回值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T x, U y)</span></span>&#123;<span class="keyword">return</span> x + y&#125;;<span class="comment">// C++ 14提供的新特性</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x + y)</span></span>&#123;<span class="keyword">return</span> x + y&#125;;<span class="comment">// C++ 11的老特性</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">decltype 是 C++11 引入的一个关键字，用于获取表达式的类型。</span></span><br><span class="line"><span class="comment">decltype(expression)</span></span><br><span class="line"><span class="comment">返回expression的类型，而不是表达式的值，一般这么用：</span></span><br><span class="line"><span class="comment">int a = 10;</span></span><br><span class="line"><span class="comment">decltype(a) b = a; </span></span><br><span class="line"><span class="comment">其中，b的类型是int，由decltype返回的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>6. C++11 常量表达式 constexpr 任何表达式都行 甚至是递归函数</strong> </p>
<p><strong>将 运行时 的计算 提前到 编译时来做性能优化</strong></p>
<p>比如，有一个计算幂次方的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">constexpr int pow(int x, int y)&#123;&#125;;// 在开头加上constexpr，表示这个表达式会在编译时被计算</span><br><span class="line">// 这时候，在需要计算常量的场景可以使用</span><br><span class="line">int a[pow(2,4)] = &#123;&#125;;</span><br><span class="line">// 数组的数量是一个常量，如果传入一个变量，则会报错，但是加了constexpr，表达式会在编译时被计算</span><br><span class="line">// 相当于编译器将这里计算成16</span><br><span class="line">int a[16] = &#123;&#125;；</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>7. C++11 初始化列表</strong></p>
<p>所有标准库中的容器都可以使用类似于数组初始化的语法来初始化，而不需要用多次push_back：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 也支持嵌套</span></span><br><span class="line">vector&lt;set&lt;<span class="type">int</span>&gt;&gt; v = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>8. 基于范围的for循环</strong></p>
<p>对于任何标准库容器，可以使用类似java的语法来遍历其中的元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x: nums)&#123;</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在C++ 17以后，可以同时配合结构化绑定(Structured Bindings)将map的遍历写成如下：</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; numMap = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span> [key, val] : numMap)&#123;</span><br><span class="line">	cout &lt;&lt; key &lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比老式写法（迭代器）简洁非常多</p>
<hr>
<p><strong>9. C++11 智能指针 unique ptr</strong></p>
<p>用于自动管理动态分配的资源，如堆上的内存，核心作用是确保动态分配的对象在离开作用域时能够自动释放内存，从而避免内存泄露等问题。在程序逻辑复杂的时候十分好用。</p>
<ul>
<li>有唯一性：不会有两个智能指针同时指向同一个对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SomeData</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在堆上申请一块内存 new</span></span><br><span class="line">    SomeData* data = <span class="keyword">new</span> SomeData;<span class="comment">// 传统写法</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;SomeDate&gt; <span class="title">data</span><span class="params">(<span class="keyword">new</span> SomeData)</span></span>;<span class="comment">// 智能指针写法 new</span></span><br><span class="line">    <span class="comment">// 用std::make_unique来创建智能指针更安全，避免重复的new表达式和野指针（构造函数出现异常）</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">make_unique</span>&lt;SomeData&gt;();<span class="comment">// 传入SomeData的构造函数</span></span><br><span class="line">    <span class="comment">// 可以用熟悉的语法访问这个智能指针指向的对象</span></span><br><span class="line">    data-&gt;a = <span class="number">1</span>;</span><br><span class="line">    data-&gt;b = <span class="number">2</span>;</span><br><span class="line">    data-&gt;c = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 不需要用delete来释放内存，当程序离开智能指针的作用域时，对象的内存就会自动释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不适合需要指针在不同函数间传递的场景</li>
<li>不适合需要多个指针指向同一个对象的智能指针</li>
</ul>
<p>不要使用unique_ptr，而是shared_ptr。</p>
<hr>
<p><strong>10. C++11 Lambda 表达式</strong></p>
<p>本质上是一个匿名函数（对象），可以用很简洁的语法快速定义一个临时的匿名函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// algorithm中定义了很多算法，如排序sorting、搜索searching、排列permutation、翻转reversing等等</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"><span class="comment">//使用find_if寻找偶数，第三个参数使用lambda表达式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[]()&#123;&#125;;是lambda的语法，本质是个函数对象</span></span><br><span class="line"><span class="comment">[]用于变量的捕获，()里是函数参数，&#123;&#125;里是函数体</span></span><br><span class="line"><span class="comment">变量的捕获意思是将lambda表达式外部的变量复制到内部，并且只在内部生效，可以在内部修改而不影响外部变量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>lambda表达式可以让函数更简洁，尤其是在有回调函数的地方。</p>
<hr>
<p><strong>11. 右值引用</strong></p>
<p>在C++中，左右值不能通过位置进行判断，可以说能够取到地址的就是左值，此时可以简单理解为：</p>
<p>左值一般是指：一个指向特定内存，具有名称的值，生命周期长，也叫具名对象。右值则反之。</p>
<p><strong>左值引用和右值引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于常量左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;x1 = <span class="number">7</span>; <span class="comment">// 编译错误</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;x = <span class="number">11</span>;<span class="comment">// 编译成功，常见于拷贝构造函数</span></span><br><span class="line"><span class="comment">// 右值引用基本语法</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 意义在于能够延长右值的生命周期，优化性能</span></span><br><span class="line"><span class="function">X <span class="title">make_x</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X x1;</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    没有进行右值引用时会有3次构造：</span></span><br><span class="line"><span class="comment">    	1. make_x函数中x1会默认构造一次</span></span><br><span class="line"><span class="comment">    	2. return x1会复制构造产生临时对象</span></span><br><span class="line"><span class="comment">    	3. X x2 = make_x()会使用复制构造将临时对象复制到x2，然后临时对象被销毁</span></span><br><span class="line"><span class="comment">    	现在的编译器会进行优化，避免多次复制构造</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    X &amp;&amp;x2 = <span class="built_in">make_x</span>();<span class="comment">// make_x()返回一个右值，但是使用了右值引用，引用了这个右值</span></span><br><span class="line">    x<span class="number">2.</span><span class="built_in">show</span>();<span class="comment">// 此时x2引用了一个右值，将返回的这个右值x1的生命周期延长了，使其可以调用show()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，使用了右值引用后，复制构造次数会减少，这也就是右值引用的终极目标：减少对象复制，提升程序性能，而不仅仅是延长右值（临时对象）的生命周期。</p>
<hr>
<p><strong>C++的指针为什么危险？</strong></p>
<p>指针是一个很灵活的工具，可以对内存直接操作，所以可能导致程序崩溃、内存泄露、数据损坏等问题：</p>
<ol>
<li>野指针 可能会有产生指向未知内存地址的指针，通常是没有正确初始化或错误修改导致的</li>
<li>悬挂指针 意思是指向已经被释放的内存的指针，危险在于被释放后被使用会导致一些问题</li>
<li>内存泄漏 我们用动态分配出的内存，让指针指向这块内存，但是如果没有正确释放的话可能会导致内存泄漏</li>
<li>多次释放 对动态分配的内存多次释放，导致程序崩溃</li>
<li>指针越界 指访问数组或内存块之外的内存，导致程序崩溃或数据损坏</li>
<li>指针类型不匹配 指针赋值的时候类型转换错误，可能导致错误的内存访问</li>
<li>错误的使用指针 比如空指针和未初始化的指针</li>
</ol>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/03/GPIO%E6%8E%A5%E5%8F%A3/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="GPIO接口"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-03T11:00:00.000Z" title="2025/1/3 19:00:00">2025-01-03</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:12:27.608Z" title="2025/3/24 23:12:27">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">1 分钟读完 (大约167个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/03/GPIO%E6%8E%A5%E5%8F%A3/">GPIO接口</a></p><div class="content"><h3 id="GPIO接口"><a href="#GPIO接口" class="headerlink" title="GPIO接口"></a>GPIO接口</h3><hr>
<p>GPIO：通用输入输出接口，在开发板上常以引脚（pin）的方式出现。</p>
<p>两种使能：时钟或者供电</p>
<p>模式：可用于GPIO或者其他比如UART、I2C或SPI的接口</p>
<p>GPIO模式时，可以对其进行编程，主要是对其寄存器进行操作，使其输出高低电平。</p>
<p>修改方式：</p>
<ol>
<li>直接读写：读出、修改bit位、写入；</li>
<li>使用设置和清除协议：对set_reg、clr_reg或data_reg寄存器进行操作以统一地修改。</li>
</ol>
<p><img src="C:\Users\BONESKEEP\AppData\Roaming\Typora\typora-user-images\image-20250319190543464.png" alt="image-20250319190543464"></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/03/Linux%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Linux编译调试工具链及常用命令"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-03T11:00:00.000Z" title="2025/1/3 19:00:00">2025-01-03</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:13:19.015Z" title="2025/3/24 23:13:19">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">4 分钟读完 (大约597个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/03/Linux%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Linux编译调试工具链及常用命令</a></p><div class="content"><h3 id="Linux编译调试工具链及常用命令"><a href="#Linux编译调试工具链及常用命令" class="headerlink" title="Linux编译调试工具链及常用命令"></a>Linux编译调试工具链及常用命令</h3><hr>
<p><strong>Linux常用命令</strong></p>
<hr>
<p><strong>Git</strong>——代码管理和协作开发工具</p>
<p>常用的git命令：</p>
<ol>
<li><p>配置</p>
<ol>
<li>git config –global user.name “name”</li>
<li>git config –globle user.email “<a href="mailto:&#110;&#97;&#109;&#x65;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;">&#110;&#97;&#109;&#x65;&#x40;&#101;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109;</a>“</li>
</ol>
</li>
<li><p>仓库操作<br>1. git init 在当前目录初始化一个新的git仓库，会生成一个.git隐藏目录，存放配置和数据<br>1. git clone 克隆一个已有的仓库地址到本地，一般通过这个拉取github上的远程仓库</p>
</li>
<li><p>分支操作</p>
<ol>
<li>git branch 查看当前仓库的所有分支，一般会有一个默认分支main</li>
<li>git branch [分支名] 创建分支</li>
<li>git checkout [分支名] 切换分支</li>
<li>git merge [分支名] 将指定分支的更改合并到当前分支</li>
<li>git branch -d [分支名] 删除指定分支</li>
</ol>
</li>
<li><p>提交操作</p>
<ol>
<li>git add [文件名] 将文件添加到暂存区</li>
<li>git status 查看仓库状态，会显式文件的修改信息</li>
<li>git commit -m “提交信息” 将暂存区的修改提交到本地仓库，并且描述提交信息，方便之后查看</li>
<li>git log 查看提交日志</li>
</ol>
</li>
<li><p>远程仓库操作</p>
<ol>
<li>git remote -v 查看关联的远程仓库</li>
<li>git push [远程仓库名] [分支名] 将本地分支更改推送到远程仓库</li>
<li>git pull [远程仓库名] [分支名] 从远程仓库拉取最新更改合并到当前分支</li>
</ol>
</li>
<li><p>其他操作</p>
<ol>
<li>查看分支差异git diff [1] [2]</li>
<li>查看文件历史git blame</li>
<li>回退到之前的提交 git reset –hard [提交哈希值]</li>
</ol>
</li>
</ol>
<p><strong>一般的开发流程：</strong></p>
<ol>
<li>克隆仓库 git clone</li>
<li>进入目录后用git branch查看分支，根据情况branch创建或checkout切换分支</li>
<li>在分支内进行开发，写代码</li>
<li>写完之后可以git statue查看修改状态，然后将修改git add提交到暂存区，再git commit 提交更改</li>
<li>将本地的更改用git push推送到远程仓库，之后可以用git log查看日志</li>
</ol>
<p><strong>冲突的处理</strong></p>
<ol>
<li>合并或拉取的时候有冲突一般是修改没提交，要手动添加到暂存区或者commit提交</li>
<li>或者暂时用git add标记一下冲突的文件</li>
</ol>
<hr>
<p><strong>GCC编译命令</strong></p>
<hr>
<p><strong>GDB调试流程</strong></p>
<hr>
<p><strong>Makefile语法及常用编译流程</strong></p>
<hr>
<p><strong>CMake语法及常用编译流程</strong></p>
</div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2025/01/02/GCC%E7%BC%96%E8%AF%91/"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="GCC编译"></a></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-02T11:00:00.000Z" title="2025/1/2 19:00:00">2025-01-02</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:00:18.394Z" title="2025/3/24 23:00:18">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">1 小时读完 (大约10745个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2025/01/02/GCC%E7%BC%96%E8%AF%91/">GCC编译</a></p><div class="content"><h3 id="GCC编译"><a href="#GCC编译" class="headerlink" title="GCC编译"></a>GCC编译</h3><hr>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>GCC全称是GNU编辑器套件，是一个多语言编译器，主要的特点就是跨平台，支持多种编程语言和处理器架构。</p>
<p>在linux环境下，主要还是直接使用编译工具，在编译的时候要添加一些编译选项。</p>
<hr>
<h3 id="2-编译过程"><a href="#2-编译过程" class="headerlink" title="2.编译过程"></a>2.编译过程</h3><p>一个C&#x2F;C++文件要经过**预处理(preprocessing)、编译(compilation)、汇编(assembly)和链接(linking)**等4步才能变成可执行文件。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/71f0ec35af324c86a669ff47d71a3a01.png#pic_center" alt="在这里插入图片描述"></p>
<p>通过不同的GCC选项可以控制这些过程：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/67a45f9bbcea4db99f3501d9b35c4f77.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>在日常交流中通常使用“编译”统称这 4 个步骤。</strong></p>
<h4 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h4><p>C&#x2F;C++源文件中，以“#”开头的命令被称为预处理命令，如包含<strong>命令“#include”</strong>、<strong>宏定义命令“#define”</strong>、<strong>条件编译命令“#if”、“#ifdef”等</strong>。预处理就是将要<strong>包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码</strong>，最后<strong>将这些东西输出到一个“.i”文件中等待进一步处理</strong>。</p>
<p>使用cc1命令将hello.c文件预处理生成hello.i文件：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/547e57bc7b7f4e558269cf6f8c32f01f.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h4><p>编译就是把C&#x2F;C++代码(比如<strong>上述的“.i”文件</strong>)<strong>“翻译”成汇编代码</strong>，所用到的工具为cc1(它的名字就是cc1，x86有自己的cc1命令，ARM板也有自己的cc1命令)。</p>
<p>使用cc1命令将hello.i文件编译生成hello.s文件：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/60b8a53f4e024a788442a7b865c8ba64.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h4><p>汇编就是将第二步输出的<strong>汇编代码翻译成符合一定格式的机器代码</strong>，在<strong>Linux</strong>系统上一般表现为<strong>ELF目标文件(OBJ文件)<strong>，用到的</strong>工具为as</strong>。x86有自己的as命令，ARM版也有自己的as命令，也可能是xxxx-as（比如armlinux-as）。<br><strong>“反汇编”是指将机器代码转换为汇编代码，这在调试程序时常常用到。</strong><br>使用as命令将hello.s文件汇编生成hello.o文件：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/ca58cca22fd84379956617d3d65f5cb6.png#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h4><p>链接就是将上步生成的<strong>OBJ文件和系统库的OBJ文件、库文件链接起来</strong>，最终<strong>生成</strong>了可以<strong>在特定平台运行</strong>的<strong>可执行文件</strong>，用到的<strong>工具为ld或collect2</strong>。</p>
<p>使用collect2命令将hello.o文件链接生成hello可执行文件，并运行hello程序：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/8743abbfa0b24154854b060b32b47959.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>使用<code>gcc -o hello hello.c</code>一条命令可以完成预处理、编译、汇编和链接4个步骤，直接生成可执行文件程序：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/8a62a4f870b44d6ebaf19d9383ee29b0.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="3-编译多个文件"><a href="#3-编译多个文件" class="headerlink" title="3. 编译多个文件"></a>3. 编译多个文件</h3><p>假设当前目录下有3个文件：main.c、sub.c、sub.h：</p>
<p>编译这3个文件有2种方法：</p>
<p>1、一起编译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o test main.c sub.c</span><br></pre></td></tr></table></figure>

<p>2、分开编译再链接到一起：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">gcc -o test main.o sub.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-制作和使用动态库"><a href="#4-制作和使用动态库" class="headerlink" title="4. 制作和使用动态库"></a>4. 制作和使用动态库</h3><p>在C语言中，<strong>动态库（Dynamic Library）是一种可执行文件或库的一部分</strong>，它在<strong>程序运行时被加载和链接</strong>。动态库提供了一个灵活的方式来组织和管理代码，<strong>使多个程序可以共享相同的代码段</strong>，从而<strong>节省内存和磁盘空间</strong>。</p>
<p>还是以main.c、sub.c、sub.h三个文件为例，制作和使用动态库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">gcc -shared -o libsub.so sub.o sub2.o sub3.o(可以使用多个.o 生成动态库)</span><br><span class="line">gcc -o test main.o -lsub -L /libsub.so/所在目录/</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/8d1a1b8dea2c44c6b1a800f517ec9482.png#pic_center" alt="在这里插入图片描述"></p>
<p>2、使用动态库</p>
<p>使用动态库有2种方法：</p>
<p>1）把libsub.so放到Ubuntu的&#x2F;lib目录中，然后就能执行test3程序了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp libsub.so /lib</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/d7818727dad4408a9daf2f5db091f4fd.png#pic_center" alt="在这里插入图片描述"></p>
<p>2）如果不想把libsub.so放到&#x2F;lib，也可以放在自己指定的目录下，配置环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/7021713564784ea3a5148c6c406e6d12.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="5-制作、使用静态库"><a href="#5-制作、使用静态库" class="headerlink" title="5. 制作、使用静态库"></a>5. 制作、使用静态库</h3><p>静态库（Static Library）是一种<strong>包含多个编译好的目标文件（.o 文件）的集合</strong>，这些目标文件<strong>在链接阶段被合并到最终的可执行文件中</strong>。</p>
<p>在Linux系统中，静态库通常以<code>.a</code>（archive）文件的形式存在。在Windows系统中，静态库则以<code>.lib</code>文件的形式存在。静态库安全、独立，不依赖外部库文件，可移植性强。</p>
<hr>
<p><strong>静态库（Static Library）和动态库（Dynamic Library）都是用于组织和管理代码的库文件，但它们在使用方式、链接时机、更新方式等方面存在明显的区别。</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>静态库</th>
<th>动态库</th>
</tr>
</thead>
<tbody><tr>
<td>链接时机</td>
<td>在编译阶段，静态库中的目标文件会被直接嵌入到最终生成的可执行文件中。</td>
<td>在编译阶段，动态库中的函数只是被标记为需要在运行时加载。在程序运行时，动态库才会被加载到内存中，并与程序进行链接。</td>
</tr>
<tr>
<td>文件大小</td>
<td>可执行文件通常较大。</td>
<td>生成的可执行文件相对较小。</td>
</tr>
<tr>
<td>内存占用</td>
<td>在程序运行时全部存在于内存中，因此内存占用较大。</td>
<td>内存占用相对较小。动态库的代码在内存中只需加载一次，所有使用该库的程序都可以共享这段内存。</td>
</tr>
<tr>
<td>更新</td>
<td>更新静态库需要重新编译和链接整个程序才能生效。</td>
<td>只要不改变动态库的接口（ABI），更新后的动态库可以直接被现有的程序使用。</td>
</tr>
<tr>
<td>依赖关系</td>
<td>不需要额外的依赖文件。</td>
<td>需要确保动态库文件存在于系统中，并且系统知道如何找到这些文件（通过环境变量或库路径配置）。</td>
</tr>
<tr>
<td>安全性</td>
<td>不容易被其他程序篡改或替换。</td>
<td>动态库是一个独立的文件，如果被恶意替换，可能会影响程序的正常运行。</td>
</tr>
<tr>
<td>跨平台性</td>
<td>通常与特定的编译器和平台绑定，跨平台时需要重新编译。</td>
<td>跨平台时只需要确保新平台上有对应的动态库版本即可。</td>
</tr>
</tbody></table>
<p>还是以main.c、sub.c、sub.h三个文件为例，制作和使用静态库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -o main.o main.c</span><br><span class="line">gcc -c -o sub.o sub.c</span><br><span class="line">ar crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o 生成静态库)</span><br><span class="line">gcc -o test main.o libsub.a (如果.a 不在当前目录下，需要指定它的绝对或相对路径)</span><br></pre></td></tr></table></figure>

<p>移动静态库位置后，链接时需要指定静态库的路径。</p>
<h3 id="6-常用编译选项"><a href="#6-常用编译选项" class="headerlink" title="6. 常用编译选项"></a>6. 常用编译选项</h3><h4 id="6-1-很好用的编译选项"><a href="#6-1-很好用的编译选项" class="headerlink" title="6.1 很好用的编译选项"></a>6.1 很好用的编译选项</h4><ul>
<li><pre><code>gcc -E main.c // 查看预处理结果，比如头文件是哪个
gcc -E -dM main.c &gt; 1.txt // 把所有的宏展开，存在 1.txt 里
gcc -Wp,-MD,abc.dep -c -o main.o main.c // 生成依赖文件 abc.dep，一般Makefile会用到
echo &#39;main()&#123;&#125;&#39;| gcc -E -v - // 它会列出头文件目录、库目录(LIBRARY_PATH)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.2 GCC总体选项(OverallOption)</span><br><span class="line"></span><br><span class="line">1、**-c**</span><br><span class="line">**预处理、编译和汇编源文件，但是不作链接，编译器根据源文件生成OBJ文件**。缺省（默认）情况下，GCC通过用`.o`替换源文件名的后缀`.c`，`.i`，`.s`等，产生OBJ文件名。可以使用-o选项选择其他名字。GCC忽略-c选项后面任何无法识别的输入文件。</span><br><span class="line"></span><br><span class="line">2、**-S**</span><br><span class="line">**编译后即停止，不进行汇编**。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。缺省情况下，GCC通过用`.s`替换源文件名后缀`.c`，`.i`等等，产生汇编文件名。可以使用-o选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</span><br><span class="line"></span><br><span class="line">3、**-E**</span><br><span class="line">**预处理后即停止，不进行编译**。预处理后的代码送往标准输出。</span><br><span class="line"></span><br><span class="line">4、**-o file**</span><br><span class="line">**指定输出文件为file**。无论是预处理、编译、汇编还是链接，这个选项都可以使用。如果没有使用`-o`选项，默认的输出结果是：可执行文件为`a.out`；修改输入文件的名称是`source.suffix`，则它的OBJ文件是`source.o`，汇编文件是`source.s`，而预处理后的C源代码送往标准输出。</span><br><span class="line"></span><br><span class="line">5、**-v**</span><br><span class="line"></span><br><span class="line">**显示**制作GCC工具自身时的**配置命令**；同时**显示编译器驱动程序、预处理器、编译器的版本号**。</span><br><span class="line"></span><br><span class="line">#### 6.3 警告选项(Warning Option)-Wall</span><br><span class="line"></span><br><span class="line">这个选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明之前就使用的函数、局部变量除了声明就没再使用等。</span><br><span class="line"></span><br><span class="line">#### 6.4 调试选项(Debugging Option)-g</span><br><span class="line"></span><br><span class="line">以操作系统的本地格式(stabs，COFF，XCOFF，或DWARF)产生调试信息，**GDB能够使用这些调试信息**。在大多数使用stabs格式的系统上，`-g`选项加入**只有GDB才使用的额外调试信息**。可以使用下面的选项来生成额外的信息：`-gstabs+`，`-gstabs`，`-gxcoff+`，`-gxcoff`，`-gdwarf+`或`-gdwarf`，具体用法请读者参考GCC手册。</span><br><span class="line"></span><br><span class="line">#### 6.5 优化选项(Optimization Option)</span><br><span class="line"></span><br><span class="line">**1、-O或者-O1**</span><br><span class="line"></span><br><span class="line">**优化：对于大函数，优化编译的过程将占用稍微多的时间和相当大的内存**。不使用`-O&#x27;或`-O1’选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的：如果在两条语句之间用断点中止程序，可以对任何变量重新赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确地获取你所期待的结果。</span><br><span class="line"></span><br><span class="line">**不使用`-O&#x27;或`-O1’选项时，只有声明了register的变量才分配使用寄存器**</span><br><span class="line"></span><br><span class="line">**使用了`-O&#x27;或`-O1’选项，编译器会试图减少目标码的大小和执行时间**。如果指定了`-O`或`-O1`选项,，`-fthread-jumps`和`-fdefer-pop`选项将被打开。在有delayslot的机器上，`-fdelayed-branch`选项将被打开。在即使没有帧指针(frame pointer)也支持调试的机器上，`-fomit-framepointer`选项将被打开。某些机器上还可能会打开其他选项。</span><br><span class="line"></span><br><span class="line">**2、-O2**</span><br><span class="line"></span><br><span class="line">**多优化一些**。**除了涉及空间和速度交换的优化选项**，**执行几乎所有的优化工作**。例如不进行循环展开(loop unrolling)和函数内嵌(inlining)。和`-O`或`-O1`选项比较，这个选项既增加了编译时间，也提高了生成代码的运行效果。</span><br><span class="line"></span><br><span class="line">**3、-O3**</span><br><span class="line"></span><br><span class="line">优化的更多。除了打开`-O2`所做的一切，它还打开了`-finline-functions`选项。</span><br><span class="line"></span><br><span class="line">**4、-O0**</span><br><span class="line"></span><br><span class="line">不优化。</span><br><span class="line">如果指定了多个`-O`选项，不管带不带数字，生效的是最后一个选项。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在一般应用中，经常使用-O2选项。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.6 链接器选项(Linker Option)</span><br><span class="line"></span><br><span class="line">**1、object-file-name**</span><br><span class="line"></span><br><span class="line">如果某些文件**没有特别明确的后缀**(a special recognized suffix)，GCC**就认为他们是OBJ文件或库文件**(根据文件内容,链接器能够区分OBJ文件和库文件)。如果GCC执行链接操作，这些OBJ文件将成为链接器的输入文件。</span><br><span class="line"></span><br><span class="line">比如上面的`gcc -o test main.o sub.o`中，`main.o`、`sub.o`就是输入的文件。</span><br><span class="line"></span><br><span class="line">**2、-llibrary**</span><br><span class="line"></span><br><span class="line">链接名为library的库文件。链接器在标准搜索目录中寻找这个库文件，库文件的真正名字是`liblibrary.a`。搜索目录除了一些系统标准目录外，还包括**用户以`-L`选项指定的路径**。一般说来用这个方法找到的文件是库文件──即由OBJ文件组成的归档文件(archive file)。</span><br><span class="line"></span><br><span class="line">链接器处理归档文件的方法是：扫描归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果链接器找到普通的OBJ文件，而不是库文件，就把这个OBJ文件按平常方式链接进来。</span><br><span class="line"></span><br><span class="line">**指定`-l`选项和指定文件名的唯一区别**是，`-l`选项用`lib`和`.a`把library包裹起来，而且搜索一些目录。</span><br><span class="line"></span><br><span class="line">即使不明显地使用-llibrary选项，一些默认的库也被链接进去，可以使用-v选项看到这点：</span><br><span class="line"></span><br><span class="line">**3、-nostartfiles**</span><br><span class="line"></span><br><span class="line">不链接系统标准启动文件，而标准库文件仍然正常使用：</span><br><span class="line"></span><br><span class="line">启动文件crt1.o、crti.o、crtend.o、crtn.o没有被链接进去。需要说明的是，对于一般应用程序，这些启动文件是必需的，这里仅是作为例子(这样编译出来的test文件无法执行)。**在编译bootloader、内核时，将用到这个选项**。</span><br><span class="line"></span><br><span class="line">**4、-nostdlib**</span><br><span class="line"></span><br><span class="line">不链接系统标准启动文件和标准库文件，只把指定的文件传递给链接器。这个选项**常用于编译内核、bootloader等程序，它们不需要启动文件、标准库文件，它们用到的很多函数是自包含的。**</span><br><span class="line"></span><br><span class="line">**5、-static**</span><br><span class="line"></span><br><span class="line">在支持动态链接(dynamicl inking)的系统上，阻止链接共享库。</span><br><span class="line">仍以options程序为例，是否使用-static选项编译出来的可执行程序大小相差巨大：</span><br><span class="line"></span><br><span class="line">其中test6文件为8360字节，test7_static文件为845304字节。当不使用-static编译文件时，程序执行前要链接共享库文件，所以还需要将共享库文件放入文件系统中。</span><br><span class="line"></span><br><span class="line">**6、-shared**</span><br><span class="line"></span><br><span class="line">生成一个共享OBJ文件，它可以和其他OBJ文件链接产生可执行文件。只有部分系统支持该选项。</span><br><span class="line">当**不想以源代码发布程序时**，可以使用-shared选项生成库文件，比如对于options程序，可以如下制作库文件：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
gcc -c -o sub.o sub.c
gcc -shared -o libsub.so sub.o
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以后要使用sub.c中的函数sub_fun时，在链接程序时，指定引脚libsub.so即可，比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
gcc -o test main.o -lsub -L /libsub.so/所在的目录/
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以将多个文件制作为一个库文件，比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
gcc -shared -o libsub.so sub.o sub2.o sub3.o
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**7、-Xlinker option**</span><br><span class="line"></span><br><span class="line">把选项option传递给链接器。可以用来传递系统特定的链接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次`-Xlinker`，一次传递选项，另一次传递其参数。例如，如果传递`-assert definitions`，要成`-Xlinker -assert -Xlinker definitions`，而不能写成`-Xlinker &quot;-assert definitions&quot;`，因为这样会把整个字符串当做一个参数传递，显然这不是链接器期待的。</span><br><span class="line"></span><br><span class="line">**8、-Wl,option**</span><br><span class="line"></span><br><span class="line">把选项option传递给链接器。如果option中含有逗号，就在逗号处分割成多个选项。链接器通常是通过gcc、arm-linux-gcc等命令间接启动的，要向它传入参数时，参数前面加上`-Wl,`。</span><br><span class="line"></span><br><span class="line">**9、-u symbol**</span><br><span class="line"></span><br><span class="line">使链接器认为取消了symbol的符号定义，从而链接库模块以取得定义。可以使用多个`-u`选项，各自跟上不同的符号，使得链接器调入附加的库模块。</span><br><span class="line"></span><br><span class="line">#### 6.7 目录选项(Directory Option)</span><br><span class="line"></span><br><span class="line">**1、-Idir**</span><br><span class="line"></span><br><span class="line">**在头文件的搜索路径列表中添加dir目录。**</span><br><span class="line">头文件的搜索方法为：如果以“#include &lt; &gt;”包含文件，则只在标准库目录开始搜索(包括使用-Idir选项定义的目录)；如果以“#include “ ””包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</span><br><span class="line"></span><br><span class="line">**2、-I-**</span><br><span class="line"></span><br><span class="line">任何在`-I-`前面用`-I`选项指定的搜索路径只适用于`#include&quot;file&quot;`这种情况；它们不能用来搜索`#include&lt;file&gt;`包含的头文件。如果用`-I`选项指定的搜索路径位于`-I-`选项后面，就可以在这些路径中搜索所有的`#include`指令(一般说来-I选项就是这么用的)。还有，`-I-`选项能够阻止当前目录(存放当前输入文件的地方)成为搜索`#include&quot;file&quot;`的第一选择。</span><br><span class="line">`-I-`不影响使用系统标准目录，因此，`-I-`和`-nostdinc`是不同的选项。</span><br><span class="line"></span><br><span class="line">**3、-Ldir**</span><br><span class="line"></span><br><span class="line">在`-l`选项的搜索路径列表中添加dir目录。仍使用options程序进行说明，先制作库文件 libsub. a：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f1392a8ddd9049d0811d0fdd32a1d026.png#pic_center)</span><br><span class="line"></span><br><span class="line">**4、-Bprefix**</span><br><span class="line"></span><br><span class="line">这个选项指出**在何处寻找可执行文件，库文件，以及编译器自己的数据文件**。编译器驱动程序需要使用某些工具，比如：`cpp`，`cc1`(或C++的`cc1plus`)，`as`和`ld`。它把prefix当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。</span><br><span class="line"></span><br><span class="line">对于要运行的工具，**编译器驱动程序**首先试着加上`-B`前缀(如果存在)，如果没有找到文件，或没有指定`-B`选项，编译器接着会试验两个标准前缀`/usr/lib/gcc/`和`/usr/local/lib/gcc-lib/`。如果仍然没能够找到所需文件，编译器就在`PATH`环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时(run-time)支持文件`libgcc.a`也在`-B`前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找，仅此而已。如果上述方法没有找到这个文件，就不链接它了。多数情况的多数机器上，`libgcc.a`并非必不可少。</span><br><span class="line"></span><br><span class="line">可以通过环境变量GCC_EXEC_PREFIX获得近似的效果；如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了`-B`选项和GCC_EXEC_PREFIX变量，编译器首先使用`-B`选项，然后才尝试环境变量值。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### make和makefile</span><br><span class="line"></span><br><span class="line">**make是一个命令，makefile是一个文件。**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1.make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。
2.makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们先创建一个文件mycode.c,在里面写好程序</span><br><span class="line"></span><br><span class="line">![image-20221119154527481](https://img-blog.csdnimg.cn/img_convert/7d067c41e6d281aa7f98198c51bfb630.png)</span><br><span class="line"></span><br><span class="line">再创建一个文件，文件名为Makefile（makefile也可）；然后在里面写</span><br><span class="line"></span><br><span class="line">![image-20221119154657036](https://img-blog.csdnimg.cn/img_convert/a5467f8891f1ad5276fdcd68f42886ec.png)</span><br><span class="line"></span><br><span class="line">**Makefile文件的第一行要写依赖关系**【儿子：爸爸 —即儿子依赖爸爸—即前者依赖后者】</span><br><span class="line"></span><br><span class="line">**第二行要以table键开头！**</span><br><span class="line"></span><br><span class="line">**第二行写依赖方法**【儿子为什么要依赖爸爸呢？—以这个代码为例编译mycode.c形成mycode—mycode的产生得由mycode.c来决定！】</span><br><span class="line"></span><br><span class="line">然后我们出去make一下，发现执行了依赖方法的代码，然后我们去运行可执行程序发现可以运行</span><br><span class="line"></span><br><span class="line">![image-20221119155601211](https://img-blog.csdnimg.cn/img_convert/04e16bc62ee3b7a4b0ca8e9e7b7de75e.png)</span><br><span class="line"></span><br><span class="line">然后我们再加点东西进去</span><br><span class="line"></span><br><span class="line">![image-20221119155759553](https://img-blog.csdnimg.cn/img_convert/f505e57f08ab5c76756c77a228cdcb5f.png)</span><br><span class="line"></span><br><span class="line">首先我们来看这个**clean**这里也是一个依赖关系，但clean冒号后面没有接东西说明clean不依赖任何文件或程序。</span><br><span class="line"></span><br><span class="line">然后**它的依赖方法是删除mycode**</span><br><span class="line"></span><br><span class="line">我们出去执行，发现它确实能执行</span><br><span class="line"></span><br><span class="line">![image-20221119160134125](https://img-blog.csdnimg.cn/img_convert/32726d88ea25b3859d4240beb7f9d790.png)</span><br><span class="line"></span><br><span class="line">但这次clean前面有个.**PHONY:clean** 这里又与上面mycode的依赖关系和方法有什么区别呢？</span><br><span class="line"></span><br><span class="line">我们连续make，发现后面的都提示mycode已经是最新的了，不需要再编译了</span><br><span class="line"></span><br><span class="line">![image-20221119160355686](https://img-blog.csdnimg.cn/img_convert/1847338b9d6e36b37d795e2c15f027b5.png)</span><br><span class="line"></span><br><span class="line">但是我们连续make clean，就算mycode已经被删除了，还是能执行make clean，那是为什么呢？</span><br><span class="line"></span><br><span class="line">![image-20221119160617497](https://img-blog.csdnimg.cn/img_convert/9f14660866dd5fce60126eab4a7c1ed1.png)</span><br><span class="line"></span><br><span class="line">别急，我们先来看这个—mycode.c的时间</span><br><span class="line"></span><br><span class="line">![image-20221119161133373](https://img-blog.csdnimg.cn/img_convert/f8bdbf1128ab070b5604602d1002206b.png)</span><br><span class="line"></span><br><span class="line">###### stat 查看文件或目录时间</span><br><span class="line"></span><br><span class="line">| Access     | 文件访问的时间—新版的系统对更新频率做了修正，访问过一段时间或者访问了多次才会改变 |</span><br><span class="line">| ---------- | ------------------------------------------------------------ |</span><br><span class="line">| **Modify** | **内容修改时间—内容改变时间随之改变**                        |</span><br><span class="line">| **Change** | **文件属性修改时间—文件属性改变时间随之改变（内容修改了文件属性也会变-比如文件大小等等）** |</span><br><span class="line"></span><br><span class="line">然后我们改变一下mycode.c的内容</span><br><span class="line"></span><br><span class="line">![image-20221119162439503](https://img-blog.csdnimg.cn/img_convert/e0fbbb897634400c2341f19176a80f2e.png)</span><br><span class="line"></span><br><span class="line">我们发现时间变了。</span><br><span class="line"></span><br><span class="line">**是否能make 是根据依赖关系两边的文件时间改变而决定的。**</span><br><span class="line"></span><br><span class="line">我们知道**编译文件产生目标文件，所以编译文件修改时间在目标文件修改时间之前**。比如编译mycode.c产生mycode，那么mycode.c的修改时间肯定在mycode的修改时间之前，如果是这样那么**Makefile文件识别到这样就不需要在make了**。</span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br><span class="line">![img](https://i-blog.csdnimg.cn/direct/ad69edd1bd194a17916ea49eacb7d70a.png)</span><br><span class="line"></span><br><span class="line">**依赖关系**</span><br><span class="line"></span><br><span class="line">- 上面的文件hello，它依赖hello.o</span><br><span class="line">- hello.o，它依赖hello.s</span><br><span class="line">- hello.s，它依赖hello.i</span><br><span class="line">- hello.i，它依赖hello.c</span><br><span class="line"></span><br><span class="line">**依赖方法**</span><br><span class="line"></span><br><span class="line">- **gcc hello.\* -option hello.\*，就是与之对应的依赖关系**</span><br><span class="line"></span><br><span class="line">### 原理</span><br><span class="line"></span><br></pre></td></tr></table></figure>
make是如何工作的,在默认的方式下，也就是我们只输入make命令。那么，
</code></pre>
</li>
</ul>
<ol>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>2.对于不生成实际文件的目标（如 all、clean），使用 .PHONY 明确声明。all 是伪目标，不生成实际文件，它的作用是触发 hello 的构建。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。<br>3.如果hello文件不存在，或是hello所依赖的后面的hello.o文件的文件修改时间要比hello这个文件新（可以用 touch 测试），那么，他就会执行后面所定义的命令来生成hello这个文件。</li>
<li>如果hello所依赖的hello.o文件不存在，那么make会在当前文件中找目标为hello.o文件的依赖性，如果找到则再根据那一个规则生成hello.o文件。（这有点像一个堆栈的过程）</li>
<li>当然，你的C文件和H文件是存在的啦，于是make会生成 hello.o 文件，然后再用 hello.o 文件声明make的终极任务，也就是执行文件hello了。</li>
<li>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。</li>
<li>在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。</li>
<li>make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。<br>makefile 的核心：目标、依赖、命令。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### **不改变代码，只可以make一次**</span><br><span class="line"></span><br><span class="line">- 因为提供编译效率</span><br><span class="line">- 怎么做到：**一定是源文件形成可执行文件**，先有源文件，才有可执行文件，一般而言，**源文件的最近修改时间是比可执行文件要老**的。</span><br><span class="line">- 如果我们更改了源文件，历史上曾经还有可执行文件，那么源文件的最近修改时间一定比可执行程序要新！</span><br><span class="line">         只需要比较可执行程序的最近修改时间 和 源文件的最近可修改时间：</span><br><span class="line">         .exe 新于 .c  源文件是老的，不需要重新编译</span><br><span class="line">         **.exe 老于 .c  源文件是新的，需要重新编译**</span><br><span class="line"></span><br><span class="line">### 项目清理</span><br><span class="line"></span><br><span class="line">- 像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</span><br><span class="line">- 但是一般我们这种clean的目标文件，我们将它设置为伪目标,用 .PHONY 修饰,伪目标的特性是，总是被执行的。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 2.Linux调试器-gdb使用</span><br><span class="line"></span><br><span class="line">### 1、背景</span><br><span class="line"></span><br><span class="line">- 程序发布的方式有两种，debug模式和release模式</span><br><span class="line">- Linux gcc/g++出来的二进制程序，默认是release模式</span><br><span class="line">- 要使用gdb调试，必须在源代码生成二进制程序的时候，加上-g选项</span><br><span class="line"></span><br><span class="line">![img](https://i-blog.csdnimg.cn/direct/9382b703269348b99c6a488b4464ac6e.png)</span><br><span class="line"></span><br><span class="line">### 2、使用</span><br><span class="line"></span><br><span class="line">gdb binFill</span><br><span class="line"></span><br><span class="line">![img](https://i-blog.csdnimg.cn/direct/a6114a60c15748a69a8135c897dce9c6.png)</span><br><span class="line"></span><br><span class="line">退出：ctrl+d / quit</span><br><span class="line">调试命令：</span><br><span class="line"></span><br><span class="line">- list / l 行号：显示源代码，接着上次的位置往下列，每次列10行</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/9cbd1857123442239a1f7c4c8d97f10f.png&quot; alt=&quot;img&quot; style=&quot;zoom: 50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- list / l 函数名：列出某个函数的源代码</span><br><span class="line"></span><br><span class="line">  &lt;img src=&quot;https://i-blog.csdnimg.cn/direct/523ac22af7bd469290afc07bacb5e629.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- r / run：运行程序![img](https://i-blog.csdnimg.cn/direct/ac987f5a20c143fe8e40eef0c122d9fb.png)</span><br><span class="line"></span><br><span class="line">- break(b) 行号：在某一行设置断点：![img](https://i-blog.csdnimg.cn/direct/47778a22c310467b8c44bba359851926.png)</span><br><span class="line"></span><br><span class="line">- n / next：单条执行（逐过程进行）：![img](https://i-blog.csdnimg.cn/direct/f8b80ce0bdf9437f9a12b33f4a98954b.png)</span><br><span class="line"></span><br><span class="line">- s / step：进入函数调用（逐语句进行）：![img](https://i-blog.csdnimg.cn/direct/be272d3dbd0c40c7a7dbafa5c59f6ae2.png)</span><br><span class="line"></span><br><span class="line">- break 函数名：在某个函数开头设置断点![img](https://i-blog.csdnimg.cn/direct/cd4f9500f18d47869a197a51b12ef491.png)</span><br><span class="line"></span><br><span class="line">- info break(b)：查看断点信息&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/2e7e4eeb9d4e45a4b1ec5034556d9e7b.png&quot; alt=&quot;img&quot; style=&quot;zoom:150%;&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1.Num：断点编号。<br>2.Type：断点类型（普通断点）。<br>3.Disp：断点处置方式（keep 表示断点会一直保留，即使程序重新启动）。<br>4.Enb：是否启用（y 表示启用）。<br>5.Address：断点对应的内存地址。<br>6.What：断点的具体位置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- finish：执行到当前函数返回，然后停下来等待命令（可以查看问题出现在哪个函数）![img](https://i-blog.csdnimg.cn/direct/83a25d6769d94a81a9fe1ed36b94759f.png)</span><br><span class="line"></span><br><span class="line">- print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/278c41087d30454f9bd040a9208b31a0.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">- set var：修改变量的值，快速到达某次循环![img](https://i-blog.csdnimg.cn/direct/84499600bb944a019ccb6f58e4ceb418.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
continue(c)：从当前位置开始连续而非单步执行(直接到下一个断点)<br>run(r)：从开始连续而非单步执行<br>delete breakpoints：删除所有断点<br>delete breakpoint n：删除序号为n的断点<br>disable breakpoints：禁用断点<br>enable breakpoint：启动断点<br>info breakpoints(i b):查看当前设置了哪些断点<br>display 变量名：跟踪查看一个变量，每次停下来都显示它的值<br>undisplay：取消对先前设置的哪些变量的跟踪<br>until x行号：跳至x行(可以跳出循环）<br>breaktrace(bt)：查看各级函数调用及参数<br>info(i) locals：查看当前栈帧局部变量的值<br>quit(q)：退出gdb<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 交叉编译</span><br><span class="line"></span><br><span class="line">交叉编译是指**在一个平台上编译代码，使其能够在另一个不同的平台上运行的过程**。</span><br><span class="line"></span><br><span class="line">交叉编译是使用一种编译器（称为交叉编译器），该编译器在宿主机（host）上运行，但生成的目标代码却可以在目标机（target）上运行。宿主机和目标机通常有不同的硬件架构和操作系统环境。</span><br><span class="line"></span><br><span class="line">一般应用在：</span><br><span class="line"></span><br><span class="line">- **嵌入式系统**：如物联网设备、路由器、工业控制器等。</span><br><span class="line">- **移动设备**：如智能手机、平板电脑等。</span><br><span class="line">- **特定架构的服务器**：如ARM服务器。</span><br><span class="line">- **操作系统开发**：如为不同架构编译Linux内核。</span><br><span class="line"></span><br><span class="line">一些特点：</span><br><span class="line"></span><br><span class="line">- 忽略硬件限制：目标机可能资源有限（如内存、CPU），无法运行完整的编译环境。</span><br><span class="line"></span><br><span class="line">- 避免操作系统差异：目标机可能运行的是实时操作系统、嵌入式系统或其他特殊的操作系统，这些系统可能不具备完整的开发工具链。</span><br><span class="line"></span><br><span class="line">- 增加开发便利性：在功能强大的宿主机上进行开发和测试更加方便，可以使用丰富的调试工具和IDE。</span><br><span class="line"></span><br><span class="line">- 提升优化和调试效果：宿主机上的高级开发工具可以帮助更好地优化和调试代码。</span><br><span class="line"></span><br><span class="line">### 3. 交叉编译器</span><br><span class="line"></span><br><span class="line">交叉编译器是专门为生成目标平台机器码而设计的编译器。一个典型的交叉编译器通常包含以下几个组件：</span><br><span class="line"></span><br><span class="line">- **编译器**（如GCC）：用于将**源代码编译成汇编代码**。</span><br><span class="line">- **汇编器**：将**汇编代码转换为目标机的机器码**。</span><br><span class="line">- **链接器**：**将多个目标文件链接成最终的可执行文件**。</span><br><span class="line">- **其他工具**：如**ar（静态库管理工具）、ranlib（更新静态库索引）、strip（去除调试信息）**等。</span><br><span class="line"></span><br><span class="line">### 4. 交叉编译工具链</span><br><span class="line"></span><br><span class="line">交叉编译工具链是一套工具的集合，包含了编译器、链接器、汇编器等工具，以及相关的库文件和系统头文件。工具链通常针对特定的目标平台定制，例如：</span><br><span class="line"></span><br><span class="line">- **ARM交叉编译工具链**：用于编译ARM架构的代码。</span><br><span class="line">- **MIPS交叉编译工具链**：用于编译MIPS架构的代码。</span><br><span class="line">- **x86交叉编译工具链**：用于编译x86架构的代码。</span><br><span class="line"></span><br><span class="line">### 5. 交叉编译的一般步骤</span><br><span class="line"></span><br><span class="line">- **准备工具链**：获取适用于目标平台的交叉编译工具链。</span><br><span class="line">- **配置环境**：设置环境变量，确保编译器知道工具链的位置。</span><br><span class="line">- **编写Makefile或配置工具**：使用适当的配置工具（如autotools、CMake等）来生成Makefile，确保这些工具能够识别交叉编译器。</span><br><span class="line">- **编译源代码**：运行编译命令，生成目标平台的二进制文件。</span><br><span class="line">- **测试和调试**：在目标平台上测试生成的二进制文件，并进行必要的调试。</span><br><span class="line"></span><br><span class="line">开发板编译工具链的例子：</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">arm-buildroot-linux-gnueabihf-gcc -o hello hello.c</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>可以用file命令查看文件的类型</strong></p>
<hr>
<h3 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h3><h2 id="1-什么是CMake"><a href="#1-什么是CMake" class="headerlink" title="1.什么是CMake"></a>1.什么是CMake</h2><p>不同的IDE所集成的make工具所遵循的规范和标准都不同，也就导致其语法、格式不同，也就不能很好的跨平台编译，会再次使得工作繁琐起来。</p>
<p> 那么cmake为了解决这个问题而诞生了，其<strong>允许开发者指定整个工程的编译流程</strong>，在根据编译平台，生成本地化的Makefile和工程文件，最后用户只需make编译即可</p>
<p>简而言之，<em><strong>*可以把cmake看成一款自动生成 Makefile的工具，所以编译流程就变成了：cmake—&gt;make–&gt;用户代码–&gt;可执行文件*</strong></em></p>
<h2 id="2-CMakeflie的安装和版本的查看"><a href="#2-CMakeflie的安装和版本的查看" class="headerlink" title="2.CMakeflie的安装和版本的查看"></a><strong>2.CMakeflie的安装和版本的查看</strong></h2><p>首先我们需要安装我们的CMake</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install cmake</span><br></pre></td></tr></table></figure>

<p>然后我们可以通过</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -version</span><br></pre></td></tr></table></figure>

<p> 来查看自己的cmake的版本</p>
<p><img src="https://i-blog.csdnimg.cn/direct/dab70e1b979c45d9a9050b5beb6239a1.png" alt="img"></p>
<h2 id="3-几个简单示例"><a href="#3-几个简单示例" class="headerlink" title="3.几个简单示例"></a>3.几个简单示例</h2><p>事实上，cmake的用法特别简单</p>
<ol>
<li><em><strong>*编写CMakeLists.txt*</strong></em></li>
<li><em><strong>*执行命令cmake .*</strong></em></li>
<li><em><strong>*执行命令make*</strong></em></li>
<li><em><strong>*运行执行程序*</strong></em></li>
</ol>
<p>看几个例子来 </p>
<h3 id="3-1-编译一个-cc文件"><a href="#3-1-编译一个-cc文件" class="headerlink" title="3.1.编译一个.cc文件"></a>3.1.编译一个.cc文件</h3><p><img src="https://i-blog.csdnimg.cn/direct/c21117296bc34c48a3f55778cc5ddd5d.png" alt="img"></p>
<p>首先让我们从最简单的代码入手，先来体验下cmake是如何操作的。编写main.cc，如下，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main.cc相同目录下<strong>编写CMakeLists.txt</strong>，内容如下，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cc)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行意思是表示cmake的最低版本要求是2.8，我们安装的是3.20.2；</li>
<li>第二行是表示本工程信息，也就是工程名叫demo；</li>
<li>第三行比较关键，表示最终要生成的elf文件的名字叫main，使用的源文件是main.cc</li>
</ul>
<p>在终端下切到main.cc所在的目录下，然后输入以下命令运行下面这个命令</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<p>执行之后，就会有下面这样子的情况发生 </p>
<p><img src="https://i-blog.csdnimg.cn/direct/5e1b2fbdedd64cb986e3f8ee66dea40d.png" alt="img"></p>
<p>我们再看看当前目录下面 </p>
<p><img src="https://i-blog.csdnimg.cn/direct/090fbf84c3ef4b659efc7b9af620048c.png" alt="img"></p>
<p>我们发现当前目录下面有Makefile了，我们打开看看</p>
<p><img src="https://i-blog.csdnimg.cn/direct/0e3fc7094e4143938812c7f0154401c2.png" alt="img"></p>
<p>好像不认识啊 ，这个我们不管，我们退出来make一下 </p>
<p><img src="https://i-blog.csdnimg.cn/direct/86731ad48ad447e9a9223ac4fe291388.png" alt="img"></p>
<p>完美啊！</p>
<h3 id="3-2-编译一个-hpp文件和一个-cc文件"><a href="#3-2-编译一个-hpp文件和一个-cc文件" class="headerlink" title="3.2.编译一个.hpp文件和一个.cc文件"></a>3.2.编译一个.hpp文件和一个.cc文件</h3><p>接下来我将编译一个.hpp文件和一个.cc文件</p>
<p><img src="https://i-blog.csdnimg.cn/direct/5ca0fe64dbc34b3c960ff1e9c474a3c2.png" alt="img"></p>
<blockquote>
<p>method.hpp</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::cout&lt;&lt;<span class="string">&quot;hello world!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main.cc </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;method.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Printf</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> CMakeLists.txt</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span>(demo)  </span><br><span class="line"></span><br><span class="line"># 添加可执行文件，只需要列出源文件，头文件不需要列出  </span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cc)</span><br><span class="line">  </span><br><span class="line"><span class="meta"># method.hpp 是 main.cc 依赖的头文件，确保它位于正确的路径下  </span></span><br><span class="line"># CMake 会自动处理包含路径（如果设置了正确的包含目录）  </span><br><span class="line"># 如果需要，可以使用 include_directories 来指定头文件搜索路径  </span><br><span class="line"># <span class="built_in">include_directories</span>(path/to/headers)  </span><br><span class="line"># 但头文件和源文件在同一目录下，通常不需要这样做</span><br></pre></td></tr></table></figure>

<p>我们执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/74e0925be2804cd9b5fa0ae9617fc5bd.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/d9be1e3e9a8f4b3b997661a0f0d1904f.png" alt="img"></p>
<p>完美！</p>
<h3 id="3-3-编译一个-hpp文件和两个-cc文件"><a href="#3-3-编译一个-hpp文件和两个-cc文件" class="headerlink" title="3.3.编译一个.hpp文件和两个.cc文件"></a>3.3.编译一个.hpp文件和两个.cc文件</h3><p>接下来进入稍微复杂的例子：这次我们决定编译一个.h文件和两个.cc文件</p>
<p><img src="https://i-blog.csdnimg.cn/direct/3fe1de1eb3a14c7d8ef32909974b73cb.png" alt="img"></p>
<blockquote>
<p>method.hpp</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>method.cc </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;method.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> main.cc</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;method.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Printf</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>我们现在就来编写CMakeLists.txt</strong></p>
<blockquote>
<p>CMakeLists.txt</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cc method.cc)</span><br></pre></td></tr></table></figure>

<p><strong>注意我这里只是在main.cc后面加路method.cc</strong> </p>
<p><strong>我们使用一下</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/243ace094075485d8055cca287dfcbff.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/3597d2a27f91426ebb3e036d0d0aef99.png" alt="img"></p>
<p>完美啊！！ </p>
<h3 id="3-4-编译两个-hpp文件和一个-cc文件"><a href="#3-4-编译两个-hpp文件和一个-cc文件" class="headerlink" title="3.4.编译两个.hpp文件和一个.cc文件"></a>3.4.编译两个.hpp文件和一个.cc文件</h3><p>接下来我们将使用method.hpp，way.hpp，main.cc文件来编译</p>
<p><img src="https://i-blog.csdnimg.cn/direct/75d7e95da5ce41b5a13c0bc775975482.png" alt="img"></p>
<blockquote>
<p>way.hpp </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Printf1&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>method.hpp </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Printf2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Printf2&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> main.cc</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;way.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;method.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Printf1</span>();</span><br><span class="line">    <span class="built_in">Printf2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> CMakeLists.txt</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">project</span> (demo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(main main.cc)</span><br></pre></td></tr></table></figure>

<p> 注意：因为我这里只有一个源文件，所以我们写一个main.cc就好</p>
<p>我们执行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/eb0b44c1ff8c46439a29a00cd1ddd6b9.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/5026b4d3cf4e4f0faeba3394398dd7e7.png" alt="img"></p>
<p>完美！</p>
<h2 id="4-CMakeLists-txt"><a href="#4-CMakeLists-txt" class="headerlink" title="4.CMakeLists.txt"></a>4.CMakeLists.txt</h2><p>​    编写CMakeLists.txt<strong>最常用的功能就是调用其他的.h头文件和.so&#x2F;.a库文件</strong>，将.cpp&#x2F;.c&#x2F;.cc文件编译成可执行文件或者新的库文件。</p>
<h3 id="4-1-CMakeLists-txt常用的几条指令"><a href="#4-1-CMakeLists-txt常用的几条指令" class="headerlink" title="4.1.CMakeLists.txt常用的几条指令"></a>4.1.CMakeLists.txt常用的几条指令</h3><p>CMakeLists.txt 文件使用一系列的 CMake 指令来描述构建过程。常见的指令包括：</p>
<p><strong>1、指定 CMake 的最低版本要求：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION &lt;version&gt;)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2、定义项目的名称和使用的编程语言：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">project</span>(&lt;project_name&gt; [&lt;language&gt;...])</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">project</span>(MyProject CXX)</span><br></pre></td></tr></table></figure>

<p><strong>3、指定要生成的可执行文件和其源文件：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(&lt;target&gt; &lt;source_files&gt;...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_executable</span>(MyExecutable main.cpp other_file.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>4、创建一个库（静态库或动态库）及其源文件：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(&lt;target&gt; &lt;source_files&gt;...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_library</span>(MyLibrary STATIC library.cpp)</span><br></pre></td></tr></table></figure>

<p><strong>5、链接目标文件与其他库：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(&lt;target&gt; &lt;libraries&gt;...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(MyExecutable MyLibrary)</span><br></pre></td></tr></table></figure>

<p><strong>6、添加头文件搜索路径：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>(&lt;dirs&gt;...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br></pre></td></tr></table></figure>

<p><strong>7、设置变量的值：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(&lt;variable&gt; &lt;value&gt;...)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p><strong>8、设置目标属性：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_include_directories</span>(TARGET target_name</span><br><span class="line">                          [BEFORE | AFTER]</span><br><span class="line">                          [SYSTEM] [PUBLIC | PRIVATE | INTERFACE]</span><br><span class="line">                          [items<span class="number">1.</span>..])</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_include_directories</span>(MyExecutable PRIVATE $&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br></pre></td></tr></table></figure>

<p><strong>9、安装规则：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS target1 [target2 ...]</span><br><span class="line">        [RUNTIME DESTINATION dir]</span><br><span class="line">        [LIBRARY DESTINATION dir]</span><br><span class="line">        [ARCHIVE DESTINATION dir]</span><br><span class="line">        [INCLUDES DESTINATION [dir ...]]</span><br><span class="line">        [PRIVATE_HEADER DESTINATION dir]</span><br><span class="line">        [PUBLIC_HEADER DESTINATION dir])</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">install</span>(TARGETS MyExecutable RUNTIME DESTINATION bin)</span><br></pre></td></tr></table></figure>

<p><strong>10、条件语句 (if, elseif, else, endif 命令)</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression)</span><br><span class="line">  # <span class="function">Commands</span></span><br><span class="line"><span class="function"><span class="title">elseif</span><span class="params">(expression)</span></span></span><br><span class="line"><span class="function">  # Commands</span></span><br><span class="line"><span class="function"><span class="title">else</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  # Commands</span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(CMAKE_BUILD_TYPE STREQUAL <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line">  <span class="built_in">message</span>(<span class="string">&quot;Debug build&quot;</span>)</span><br><span class="line"><span class="built_in">endif</span>()</span><br></pre></td></tr></table></figure>

<p><strong>11、自定义命令 (add_custom_command 命令)：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">   TARGET target</span><br><span class="line">   PRE_BUILD | PRE_LINK | POST_BUILD</span><br><span class="line">   COMMAND command1 [ARGS] [WORKING_DIRECTORY dir]</span><br><span class="line">   [COMMAND command2 [ARGS]]</span><br><span class="line">   [DEPENDS [depend1 [depend2 ...]]]</span><br><span class="line">   [COMMENT comment]</span><br><span class="line">   [VERBATIM]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_custom_command</span>(</span><br><span class="line">   TARGET MyExecutable POST_BUILD</span><br><span class="line">   COMMAND $&#123;CMAKE_COMMAND&#125; -E echo <span class="string">&quot;Build completed.&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><em><strong>*实例*</strong></em></p>
<p>一个简单的 CMakeLists.txt 文件示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="built_in">project</span>(MyProject CXX)</span><br><span class="line"></span><br><span class="line"># 添加源文件</span><br><span class="line"><span class="built_in">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"> </span><br><span class="line"># 设置 C++ 标准</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-2-变量和缓存"><a href="#4-2-变量和缓存" class="headerlink" title="4.2.变量和缓存"></a>4.2.变量和缓存</h3><p>[CMake 使用](<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=CMake">https://so.csdn.net/so/search?q=CMake</a> 使用&amp;spm&#x3D;1001.2101.3001.7020)变量来存储和传递信息，这些变量可以在 CMakeLists.txt 文件中定义和使用。</p>
<p>变量可以分为普通变量和缓存变量。</p>
<h4 id="4-2-1-变量定义与使用"><a href="#4-2-1-变量定义与使用" class="headerlink" title="4.2.1.变量定义与使用"></a>4.2.1.变量定义与使用</h4><p><strong>定义变量：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(MY_VAR <span class="string">&quot;Hello World&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>使用变量：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Variable MY_VAR is $&#123;MY_VAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-缓存变量"><a href="#4-2-2-缓存变量" class="headerlink" title="4.2.2.缓存变量"></a>4.2.2.缓存变量</h4><p>缓存变量存储在 CMake 的缓存文件中，用户可以在 CMake 配置时修改这些值。缓存变量通常用于用户输入的设置，例如编译选项和路径。</p>
<p><strong>定义缓存变量：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>(MY_CACHE_VAR <span class="string">&quot;DefaultValue&quot;</span> CACHE STRING <span class="string">&quot;A cache variable&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>使用缓存变量：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">message</span>(STATUS <span class="string">&quot;Cache variable MY_CACHE_VAR is $&#123;MY_CACHE_VAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-查找库和包"><a href="#4-3-查找库和包" class="headerlink" title="4.3.查找库和包"></a>4.3.查找库和包</h3><p>CMake 可以通过 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=find_package&spm=1001.2101.3001.7020">find_package</a>() 指令自动检测和配置外部库和包。</p>
<p>常用于查找系统安装的库或第三方库。</p>
<h4 id="4-3-1-find-package-指令"><a href="#4-3-1-find-package-指令" class="headerlink" title="4.3.1.find_package() 指令"></a>4.3.1.find_package() 指令</h4><p>基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(Boost REQUIRED)</span><br></pre></td></tr></table></figure>

<p>指定版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(Boost <span class="number">1.70</span> REQUIRED)</span><br></pre></td></tr></table></figure>

<p>查找库并指定路径：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find_package</span>(OpenCV REQUIRED PATHS /path/to/opencv)</span><br></pre></td></tr></table></figure>

<p>使用查找到的库：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">target_link_libraries</span>(MyExecutable Boost::Boost)</span><br></pre></td></tr></table></figure>

<p>设置包含目录和链接目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">include_directories</span>($&#123;Boost_INCLUDE_DIRS&#125;)</span><br><span class="line"><span class="built_in">link_directories</span>($&#123;Boost_LIBRARY_DIRS&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-使用第三方库"><a href="#4-3-2-使用第三方库" class="headerlink" title="4.3.2.使用第三方库"></a>4.3.2.使用第三方库</h4><p>假设你想在项目中使用 Boost 库，CMakeLists.txt 文件可能如下所示：</p>
<p>实例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="built_in">project</span>(MyProject CXX)</span><br><span class="line"> </span><br><span class="line"># 查找 Boost 库</span><br><span class="line"><span class="built_in">find_package</span>(Boost REQUIRED)</span><br><span class="line"> </span><br><span class="line"># 添加源文件</span><br><span class="line"><span class="built_in">add_executable</span>(MyExecutable main.cpp)</span><br><span class="line"> </span><br><span class="line"># 链接 Boost 库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(MyExecutable Boost::Boost)</span><br></pre></td></tr></table></figure>

<p>通过上述内容，用户可以了解 CMakeLists.txt 文件的基本结构和常用指令，掌握如何定义和使用变量，查找和配置外部库，从而能够有效地使用 CMake 管理项目构建过程。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/Linux/page/0/">上一页</a></div><div class="pagination-next"><a href="/categories/Linux/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/Linux/">1</a></li><li><a class="pagination-link" href="/categories/Linux/page/2/">2</a></li><li><a class="pagination-link" href="/categories/Linux/page/3/">3</a></li><li><a class="pagination-link" href="/categories/Linux/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/head_circle.png" alt="BONESKEEP"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">BONESKEEP</p><p class="is-size-6 is-block">硕士研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Lanzhou University of Technology</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">76</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/BONESKEEP" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/BONESKEEP"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="QQ" href="https://qm.qq.com/q/4kKCYBUmaA"><i class="fab fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Mail" href="mailto:coolhui2020@163.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/BONESKEEP" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://boneskeep.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Blog</span></span><span class="level-right"><span class="level-item tag">boneskeep.github.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Game/Games101/"><span class="level-start"><span class="level-item">Games101</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Kunpeng/"><span class="level-start"><span class="level-item">Kunpeng</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Kunpeng/Limb/"><span class="level-start"><span class="level-item">Limb</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">39</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/App/"><span class="level-start"><span class="level-item">App</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/"><span class="level-start"><span class="level-item">学术</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/3DGS/"><span class="level-start"><span class="level-item">3DGS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/NeRF/"><span class="level-start"><span class="level-item">NeRF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"><span class="level-start"><span class="level-item">三维重建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/03/21/2025-3-21-Leetcode-Hot100-No.763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 763. 划分字母区间 贪心 字符串"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-21T11:00:00.000Z">2025-03-21</time></p><p class="title"><a href="/2025/03/21/2025-3-21-Leetcode-Hot100-No.763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/">Leetcode Hot100 763. 划分字母区间 贪心 字符串</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 45. 跳跃游戏 II 贪心算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-20T07:00:00.000Z">2025-03-20</time></p><p class="title"><a href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/">Leetcode Hot100 45. 跳跃游戏 II 贪心算法</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 55. 跳跃游戏 贪心算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-20T03:00:00.000Z">2025-03-20</time></p><p class="title"><a href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/">Leetcode Hot100 55. 跳跃游戏 贪心算法</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/19/2025-3-19-Leetcode-Hot100-No.24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 24. 两两交换链表中的节点 递归/迭代"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-19T11:00:00.000Z">2025-03-19</time></p><p class="title"><a href="/2025/03/19/2025-3-19-Leetcode-Hot100-No.24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">Leetcode Hot100 24. 两两交换链表中的节点 递归/迭代</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/18/2025-3-18-Leetcode-Hot100-No.19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 19. 删除链表的倒数第 N 个结点 栈 双指针"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-18T13:00:00.000Z">2025-03-18</time></p><p class="title"><a href="/2025/03/18/2025-3-18-Leetcode-Hot100-No.19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/">Leetcode Hot100 19. 删除链表的倒数第 N 个结点 栈 双指针</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Games101/"><span class="tag">Games101</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kunpeng/"><span class="tag">Kunpeng</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Leetcode/"><span class="tag">Leetcode</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">39</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E6%9C%AF/"><span class="tag">学术</span><span class="tag">7</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head_circle.png" alt="BONESKEEP&#039; BLOG" height="28"></a><p class="is-size-7"><span>&copy; 2025 BONESKEEP</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Open Source</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>