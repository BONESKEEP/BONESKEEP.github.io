<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>进程间通信 - BONESKEEP&#039; BLOG</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="BONESKEEP&#039; BLOG"><meta name="msapplication-TileImage" content="/img/headlogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="BONESKEEP&#039; BLOG"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="进程间通信 一、进程间通信介绍 进程间通信概念​    进程间通信（Inter-Process Communication, IPC）是指在不同进程之间传递或交换信息的一种机制。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间不能直接访问对方的内存空间，需要通过特定的通信机制来实现数据交换和同步操作。  是什么—— 两个或多个进程实现数据层面的交"><meta property="og:type" content="blog"><meta property="og:title" content="进程间通信"><meta property="og:url" content="https://boneskeep.github.io/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="BONESKEEP&#039; BLOG"><meta property="og:description" content="进程间通信 一、进程间通信介绍 进程间通信概念​    进程间通信（Inter-Process Communication, IPC）是指在不同进程之间传递或交换信息的一种机制。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间不能直接访问对方的内存空间，需要通过特定的通信机制来实现数据交换和同步操作。  是什么—— 两个或多个进程实现数据层面的交"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://boneskeep.github.io/img/leetcode/Shangri-La%20Frontier-01.jpg"><meta property="article:published_time" content="2025-01-08T11:00:00.000Z"><meta property="article:modified_time" content="2025-03-24T15:15:18.849Z"><meta property="article:author" content="BONESKEEP"><meta property="article:tag" content="Linux"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://boneskeep.github.io/img/leetcode/Shangri-La%20Frontier-01.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://boneskeep.github.io/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"},"headline":"进程间通信","image":["https://boneskeep.github.io/img/leetcode/Shangri-La%20Frontier-01.jpg"],"datePublished":"2025-01-08T11:00:00.000Z","dateModified":"2025-03-24T15:15:18.849Z","author":{"@type":"Person","name":"BONESKEEP"},"publisher":{"@type":"Organization","name":"BONESKEEP' BLOG","logo":{"@type":"ImageObject","url":"https://boneskeep.github.io/img/head_circle.png"}},"description":"进程间通信 一、进程间通信介绍 进程间通信概念​    进程间通信（Inter-Process Communication, IPC）是指在不同进程之间传递或交换信息的一种机制。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间不能直接访问对方的内存空间，需要通过特定的通信机制来实现数据交换和同步操作。  是什么—— 两个或多个进程实现数据层面的交"}</script><link rel="canonical" href="https://boneskeep.github.io/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"><link rel="icon" href="/img/headlogo.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/head_circle.png" alt="BONESKEEP&#039; BLOG" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives/">Archives</a><a class="navbar-item" href="/categories/">Categories</a><a class="navbar-item" href="/tags/">Tags</a><a class="navbar-item" href="/about/">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/BONESKEEP">GitHub</a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/BONESKEEP/BONESKEEP.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="进程间通信"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2025-01-08T11:00:00.000Z" title="2025/1/8 19:00:00">2025-01-08</time>发表</span><span class="level-item"><time dateTime="2025-03-24T15:15:18.849Z" title="2025/3/24 23:15:18">2025-03-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Linux/">Linux</a><span> / </span><a class="link-muted" href="/categories/Linux/App/">App</a></span><span class="level-item">2 小时读完 (大约20266个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">进程间通信</h1><div class="content"><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><hr>
<h3 id="一、进程间通信介绍"><a href="#一、进程间通信介绍" class="headerlink" title="一、进程间通信介绍"></a>一、进程间通信介绍</h3><ol>
<li><h3 id="进程间通信概念"><a href="#进程间通信概念" class="headerlink" title="进程间通信概念"></a>进程间通信概念</h3>​    进程间通信（Inter-Process Communication, IPC）是指在<strong>不同进程之间传递或交换信息的一种机制</strong>。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间<strong>不能直接访问对方的内存空间</strong>，需要通过特定的通信机制来实现数据交换和同步操作。</li>
</ol>
<p><strong>是什么——</strong></p>
<p>两个或多个进程实现<strong>数据层面的交互</strong>。因为<strong>进程独立性</strong>的存在，导致<strong>进程通信的成本比较高</strong>。</p>
<p>为什么——</p>
<p>发送基本数据、发送指令、多进程协同等需求</p>
<p><strong>怎么办——</strong></p>
<ul>
<li>进程间通信的本质：<strong>必须让不同的进程看到同一份“资源”</strong>，这里的资源就是指<strong>以特定形式存在的内存空间</strong>。</li>
<li><strong>资源由谁来提供？一般是操作系统。</strong>为什么不是我们两个进程中的一个呢？假设一个进程提供，这个资源就属于该进程所有，因为进程具有独立性！破坏进程独立性，这是操作系统不允许的，所以需要第三方提供空间，所以操作系统就是和事佬。</li>
<li>我们进程访问空间，进行进程间通信，<strong>本质就是访问操作系统</strong>，而<strong>进程代表的是用户</strong>，用户不能直接访问操作系统内核数据，所以操作系统提供了系统调用接口，所以是从操作系统底层设计，从接口设计，<strong>一个独立的通信模块IPC —— 隶属文件系统</strong>。当进程通信变多，显而易见，操作系统需要将他们管理起来，先描述再组织。</li>
</ul>
<ol start="2">
<li><h3 id="进程间通信目的"><a href="#进程间通信目的" class="headerlink" title="进程间通信目的"></a><strong>进程间通信目的</strong></h3></li>
</ol>
<p>  数据传输：一个进程需要将它的数据发送给另一个进程</p>
<p>  资源共享：多个进程之间共享同样的资源。</p>
<p>  通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。</p>
<p>  进程控制：有些<strong>进程希望完全控制另一个进程的执行（如Debug进程）</strong>，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。</p>
<ol start="3">
<li><h3 id="进程间通信的本质"><a href="#进程间通信的本质" class="headerlink" title="进程间通信的本质"></a>进程间通信的本质</h3> <strong>必须让不同的进程看到同一份“资源”</strong>，这里的资源就是指<strong>以特定形式存在的内存空间</strong>。</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/a5885461758b4f49aefdcfb8b309d209.png" alt="img"></p>
<p>因此，进程间通信的本质就是，<strong>让不同的进程看到同一份资源（内存，文件内核缓冲等）</strong>。 由于<strong>这份资源可以由操作系统中的不同模块提供</strong>，因此出现了<strong>不同的进程间通信方式</strong>。</p>
<h4 id="4-进程间通信发展"><a href="#4-进程间通信发展" class="headerlink" title="4. 进程间通信发展"></a>4. 进程间通信发展</h4><ol>
<li><p>管道</p>
</li>
<li><p>System V 进程间通信</p>
</li>
<li><p>POSIX 进程间通信</p>
</li>
<li><h3 id="进程间通信分类"><a href="#进程间通信分类" class="headerlink" title="进程间通信分类"></a>进程间通信分类</h3><ol>
<li>管道（文件缓冲区）<br>1. 匿名管道pipe<br>2. 命名管道</li>
<li>System V IPC<ol>
<li>System V 消息队列</li>
<li>System V 共享内存 （内存块）</li>
<li>System V 信号量</li>
</ol>
</li>
<li>POSIX IPC<ol>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>互斥量</li>
<li>条件变量</li>
<li>读写锁</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h3 id="二、管道"><a href="#二、管道" class="headerlink" title="二、管道"></a>二、管道</h3><p>​        管道（Pipes）是一种基本的进程间通信（IPC）机制，用于<strong>连接一个进程的输出到另一个进程的输入</strong>。管道允许数据<strong>以字节流的形式</strong>从一个进程传递到另一个进程。它是<strong>单向</strong>的，即数据只能从一个方向流动。管道分为<strong>匿名管道和命名管道</strong>（也称为FIFO，即First In First Out）。</p>
<p>​	<strong>原理：基于文件的一种通信方式</strong></p>
<ol>
<li><h3 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h3><p> ​    匿名管道是最早出现的UNIX IPC机制之一，它只能用于<strong>具有亲缘关系的进程之间</strong>（通常是<strong>父子进程或兄弟进程</strong>）。当一个进程创建了一个管道后，它会得到两个文件描述符：一个用于写（通常称为管道的写端），另一个用于读（通常称为管道的读端）。进程可以将数据写入管道的写端，然后另一个进程可以从管道的读端读取数据。由于<strong>管道是基于文件描述符</strong>的，因此<strong>当所有指向管道的文件描述符都被关闭后</strong>，管道中的<strong>数据就会被丢弃</strong>，管道本身也会被销毁。</p>
<pre><code> 管道是一种简单但强大的IPC机制，它适用于需要数据流的场景，如父子进程之间的数据传递。然而，由于其单向性和有限的容量，管道可能不适合所有类型的IPC需求。在这种情况下，可以考虑使用其他IPC机制，如消息队列、共享内存或套接字等。
</code></pre>
</li>
</ol>
<p>例如，统计我们当前使用云服务器上的登录用户个数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who | wc -l</span><br></pre></td></tr></table></figure>

<p> who命令和wc命令都是两个程序，当它们运行起来后就变成了两个进程，who进程通过标准输出将数据打到“管道”当中，wc进程再通过标准输入从“管道”当中读取数据，至此便完成了数据的传输，进而完成数据的进一步加工处理。( who命令用于查看当前云服务器的登录用户（一行显示一个用户），wc -l用于统计当前的行数)<br><img src="https://i-blog.csdnimg.cn/direct/acbe35923c0c40ff9871a97167300e52.png" alt="img"></p>
<p>由管道（“|”）连接起来的各个进程是有亲缘关系的，它们之间互为兄弟进程，是匿名管道。</p>
<h5 id="1-1-匿名管道原理"><a href="#1-1-匿名管道原理" class="headerlink" title="1.1 匿名管道原理"></a>1.1 匿名管道原理</h5><p>重温一下进程结构体：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/1fe4e66715204c708422684cfbe8f5d7.png" alt="img"></p>
<p>进程创建时，创建 task_struct 结构体，结构体内有指针指向 files_struct 结构体，该结构体内有一个struct file* 数组，即文件描述符表，指向被该进程打开的 struct file 文件（默认打开stdin、stdout、stderr，对应键盘和显示器文件）。如果进程又打开一个文件（操作系统创建的内存级文件），那么为就为该文件分配一个最小的没有被使用的fd，在fd下标的文件描述符数组的元素填写指向该文件的struct file的struct file*，并且 struct file 结构体还指向了 inode 属性集结构体（有大部分inode的属性）、file_opeartors函数方法集（对硬件的操作函数的函数指针结构体）、文件页缓冲区。对于文件页缓冲区来说，无论读写，都将磁盘数据加载到文件页缓冲区（相当于缓冲，提高效率），如果是写就会修改缓冲区数据，该数据为脏，所以就会被操作系统刷新到磁盘，    </p>
<pre><code>    管道虽然用的是文件的方案，但操作系统一定不会把进程进行通信的数据刷新到磁盘当中，因为这样做有IO参与会降低效率，而且也没有必要。也就是说，这种文件是一批不会把数据写到磁盘当中的文件，换句话说，磁盘文件和内存文件不一定是一一对应的，有些文件只会在内存当中存在，而不会在磁盘当中存在。
</code></pre>
<p>进程打开文件后再 fork，会拷贝 files_struct 吗？ </p>
<pre><code>    会拷贝files_struct ，但是不会拷贝struct file，对于 struct file 直接引用计数即可(图画错了，两个进程的3号fd应该指向相同的struct file)。
    所以父子进程会看到同一个新建的文件 —— 内存级文件，这就实现了不同的进程，看到同一份资源！父进程可以向文件页缓冲区写入数据，子进程就可以在文件页缓冲区读取数据！这就实现了进程间通信。所以管道就是文件！是一种内存级别文件，不在磁盘。
    内存级文件：不在磁盘，操作系统在内存直接创建一个struct file。
</code></pre>
<p>管道是一个内存级别文件，由os直接创建一个文件结构体用于进程间读写，不会加载到磁盘。</p>
<p>这里父子进程看到的同一份文件资源是由操作系统来维护的，所以当父子进程对该文件进行写入操作时，该文件缓冲区当中的数据并不会进行写时拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内存级文件（管道文件）有路径、文件名、inode吗？</span><br><span class="line"></span><br><span class="line">由于匿名管道不直接对应于文件系统中的任何实体，因此它没有自己的inode号。并且根本就不需要名字，因为子进程看到父进程是靠继承拷贝来看到的。</span><br><span class="line">匿名管道的文件描述符仅用于在创建它的进程及其子进程或通过其他IPC机制（如消息队列、共享内存等）与之通信的进程之间进行数据传递。</span><br></pre></td></tr></table></figure>

<p><strong>命名管道：有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作。</strong><br><strong>匿名管道：没有明确的路径、文件名和inode号，仅存在于内存中，通过进程间的文件描述符进行通信。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当进程依靠管道文件通信时，一方关闭文件，另一方会受影响而出现错误吗？</span><br><span class="line"></span><br><span class="line">如果父进程只是以读方式打开管道文件，那么子进程拷贝父进程进程的一系列结构体，导致子进程也只能以读方式读管道文件，父子都只能读管道文件，这就会引发矛盾。所以，父进程打开文件是有要求的，需要以读和写分别打开管道文件！</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/9ac46c225bf141c5af52e4ec8e53fb2b.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/e894e87ef87743989ca870dc4b387daa.png" alt="img"></p>
<pre><code>    虽然读写在技术角度可以，但是读写不建议混起来，因为读写都是由各自的变量控制的，如果混在一起我们刚写的数据是读不出来的。所以，一般都是读打开一次、写打开一次，但是除了创建一个struct file，其他的都是共享（inode结构体、文件缓冲区）
    所以操作系统规定，一个进程不能同时读写，因为如果同时读写，不能确定哪些数据是自己的哪些是其他进程写的，这就很繁琐，操作系统使用文件系统来实现就是为了简单一些，否则就会再设计一个复杂的系统来实现，所以操作系统就规定进程之间只能进行单向通信！
    所以一个进程在读时，就关闭自己的写文件，另一个进程在写时，就关闭自己的读文件，从而实现单向通信。
</code></pre>
<p>管道进行读写时，一般都是关闭各自的另一个写读文件，比如A读就关闭A的写文件，B写就关闭B的读文件，实现单向通信，而且只能互斥地读写，每次每个管道只能有一端被一个进程访问。</p>
<p>匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么非要搞管道，我父进程写一个全局数据，子进程继承，这不就是传递消息吗？</span><br><span class="line">首先，进程的通信内容大部分为动态的消息，即消息是即时性的传递，而不是静态的数据，其次父进程的全局数据只是单方面的传递，子进程只能读数据，不能写数据，一旦写数据就会触发写时拷贝。</span><br></pre></td></tr></table></figure>

<p><strong>写时拷贝&#x2F;写时复制：一种资源管理优化策略</strong></p>
<p><strong>核心思想是延迟数据的实际复制操作，直到数据被修改时才进行复制。</strong>具体来说，如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会<strong>共同获取相同的指针指向相同的资源</strong>，直到某个调用者<strong>试图修改</strong>资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p>fork()系统调用创建子进程时会使用写时拷贝。子进程和父进程共享内存空间，只有<strong>在某个进程对内存进行写操作时，才会复制相应的内存页面。</strong></p>
<p>优点：<strong>减少不必要的数据复制，节省内存和存储空间。提高系统性能，避免数据共享时的多个复制开销。</strong></p>
<p>缺点：<strong>需要额外的机制来管理；某些情况会多次触发写时拷贝，导致内存中有多份数据副本。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如果进程不是父子关系，那么还能通过管道通信吗？</span><br><span class="line">不可以，必须是父子关系。管道原理就是父子进程共享管道文件。</span><br><span class="line"></span><br><span class="line">如果父进程创建多个子进程，那么这些子进程可以通过管道通信吗？</span><br><span class="line">可以，因为全都继承的父进程，所以都指向同一个内存文件——管道文件（文件页缓冲区）。</span><br><span class="line"> </span><br><span class="line">如果父进程创建的子进程，子进程又创建了子进程，那么爷孙进程可以通过管道通信吗？</span><br><span class="line">可以，因为也都是拷贝的同一份files_struct，都指向同一个内存文件——管道文件。</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong>匿名管道通信<strong>，</strong>进程之间需要又血缘关系，常见于父子关系。匿名管道通常只能用于具有亲缘关系的进程之间（如父子进程、兄弟进程）。这是因为非亲缘关系的进程无法直接访问对方的内存空间，也无法通过文件描述符&#x2F;句柄继承来访问对方的管道。</p>
<hr>
<h5 id="1-2-pipe系统调用"><a href="#1-2-pipe系统调用" class="headerlink" title="1.2 pipe系统调用"></a>1.2 pipe<strong>系统调用</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 pipe</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/d38666cd7b1843f3bba91cfccd140679.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br></pre></td></tr></table></figure>

<p><strong>该函数参数是一种输出型参数，</strong>pipe内部将struct file、文件缓冲区等结构创建好，以读写方式打开内存文件（匿名管道），然后返回两个文件描述符fd ，<strong>靠数组带回</strong>，数组只需两个元素，默认：</p>
<ul>
<li><strong>pipefd[0] ：读下标</strong></li>
<li><strong>pipefd[1] ：写下标</strong></li>
</ul>
<p><strong>返回值：pipe函数调用成功时返回0，调用失败时返回-1</strong></p>
<p>举例：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/8fc99c92b28f4a7b8c727b03812bccbc.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ff3291b0df74db3baf14cca773c98e2.png" alt="img"></p>
<p>pipefd有两个元素，用于存储管道的读写端；</p>
<p>pipefd传入pipe，将pipefd[0]设为当前文件句柄3，将pipefd[1]设为当前文件句柄4；</p>
<p>然后返回一个数用于反馈，成功为0，并且pipefd中会包含两个有效的文件描述符；失败为-1，并且会设置errno以指示错误原因。</p>
<hr>
<h5 id="1-3-匿名管道的使用"><a href="#1-3-匿名管道的使用" class="headerlink" title="1.3 匿名管道的使用"></a>1.3 匿名管道的使用</h5><p> 在创建匿名管道实现父子进程间通信的过程中，需要pipe函数和fork函数搭配使用。</p>
<p>1、父进程调用pipe函数创建管道</p>
<img src="https://i-blog.csdnimg.cn/direct/5ef0abc0575742e0acbda3094fbd5f71.png" alt="img" style="zoom:50%;" />

<p>2、父进程创建子进程</p>
<img src="https://i-blog.csdnimg.cn/direct/dab4bcb10ccb4d3d8e424cae7aa612d2.png" alt="img" style="zoom:50%;" />

<p>3、父进程关闭写端，子进程关闭读端（当然，父进程也可以关闭读端）</p>
<img src="https://i-blog.csdnimg.cn/direct/1596bea838aa46348204aa02514a1e6f.png" alt="img" style="zoom:50%;" />

<p>匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。</p>
<p>父子进程的<strong>通信靠操作系统的系统调用接口write、read</strong>，因为操作系统不相信用户，不可能让用户自己指定一块内存区域，让用户随便访问，这是不允许的。</p>
<p>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//child-&gt;write, father-&gt;read</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> fd[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>)&#123; <span class="comment">//使用pipe创建匿名管道</span></span><br><span class="line">		perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">pid_t</span> id = fork(); <span class="comment">//使用fork创建子进程</span></span><br><span class="line">	<span class="keyword">if</span> (id == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//child</span></span><br><span class="line">		close(fd[<span class="number">0</span>]); <span class="comment">//子进程关闭读端</span></span><br><span class="line">		<span class="comment">//子进程向管道写入数据</span></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;hello father, I am child...&quot;</span>;</span><br><span class="line">		<span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">while</span> (count--)&#123;</span><br><span class="line">			write(fd[<span class="number">1</span>], msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">			sleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		close(fd[<span class="number">1</span>]); <span class="comment">//子进程写入完毕，关闭文件</span></span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//father</span></span><br><span class="line">	close(fd[<span class="number">1</span>]); <span class="comment">//父进程关闭写端</span></span><br><span class="line">	<span class="comment">//父进程从管道读取数据</span></span><br><span class="line">	<span class="type">char</span> buff[<span class="number">64</span>];</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="type">ssize_t</span> s = read(fd[<span class="number">0</span>], buff, <span class="keyword">sizeof</span>(buff));</span><br><span class="line">		<span class="keyword">if</span> (s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			buff[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;child send to father:%s\n&quot;</span>, buff);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read file end\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd[<span class="number">0</span>]); <span class="comment">//父进程读取完毕，关闭文件</span></span><br><span class="line">	waitpid(id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>管道内部自带同步与互斥机制</strong></p>
<p>多执行流共享时，可能会出现访问冲突问题。即一个进程正在访问数据时，另一个进程写入数据，这就可能覆盖原数据——临界资源竞争问题</p>
<p>临界资源是需要被保护的，若是我们不对管道这种临界资源进行任何保护机制，那么就可能出现同一时刻有多个进程对同一管道进行操作的情况，进而导致同时读写、交叉读写以及读取到的数据不一致等问题。</p>
<p>为了避免这些问题，内核会对管道操作进行同步与互斥：</p>
<p>​	<strong>同步： 两个或两个以上的进程在运行过程中协同步调，按预定的先后次序运行。比如，A任务的运行依赖于B任务产生的数据。<br>​	互斥： 一个公共资源同一时刻只能被一个进程使用，多个进程不能同时使用公共资源。</strong><br>实际上，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。对于管道的场景来说，互斥就是两个进程不可以同时对管道进行操作，它们会相互排斥，必须等一个进程操作完毕，另一个才能操作，而同步也是指这两个不能同时对管道进行操作，但这两个进程必须要按照某种次序来对管道进行操作。</p>
<p>也就是说，互斥具有唯一性和排它性，但<strong>互斥并不限制任务的运行顺序</strong>，而<strong>同步的任务之间则有明确的顺序关系</strong>。</p>
<hr>
<h5 id="1-4-管道通信的特征"><a href="#1-4-管道通信的特征" class="headerlink" title="1.4 管道通信的特征"></a><strong>1.4 管道通信的特征</strong></h5><p>​	<strong>亲缘性</strong>：具有血缘关系的进程才能通过管道通信<br>​	<strong>单向性</strong>：管道是单向的，数据只能从一个方向流动<br>​	<strong>通信进程之间会协同（互斥、同步）</strong>，这是为了保护管道文件的数据安全。如果父进程读数据时，缓冲区直接拿来就读会导致乱码，因为缓冲区不是每时每刻都为空，子进程也不是时时刻刻写入缓冲区，所以进程间需要协同！一方没有写入，另一方就不读写。<br>​	<strong>基于字节流</strong>：管道是面向字节流的，管道中的数据以字节流的形式传递，没有消息边界的概念（不管一个进程写了多少字符、写了几次，另一个进程<strong>读取时一次全部读完</strong>。就像是自来水，来自写端的自来水不分边界，不管写端放了多少自来水，<strong>读端都是一个读完</strong>，不管读端是拿盆还是拿桶来接）对于进程A写入管道当中的数据，进程B每次从管道读取的数据的多少是任意的，这种被称为流式服务。<br>​	<strong>生命周期</strong>：<strong>匿名管道的生命周期随进程结束而结束</strong>；<strong>命名管道的生命周期则取决于文件系统</strong>，除非显式删除，否则会一直存在。<strong>管道是基于文件的</strong>，文件的生命周期是跟随进程的。父子进程退出时，管道文件自动被操作系统释放，例如默认打开的stdin、stdout、stderr都是操作系统关闭的<br><strong>管道是有固定大小的 ，在不同内核里大小有差别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>

<p>使用 ulimit 指令查看对很多重要资源的限制，进程可打开最大文件数、管道大小等等</p>
<p><img src="https://i-blog.csdnimg.cn/direct/07e49248461b4ca88efe98138cfaecfd.png" alt="img"></p>
<p>  centos7.6版本默认给管道大小是64KB。当写入的字节小于PIPE_BUF时，写入的必须是原子（单次写入大小），这里的pipe size 就可以看 作 PIPE_BUF</p>
<p>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。<br>当要写入的<strong>数据量大于PIPE_BUF时，linux将不再保证写入的原子性</strong>。</p>
<hr>
<h5 id="1-5-管道读写的4种情况"><a href="#1-5-管道读写的4种情况" class="headerlink" title="1.5 管道读写的4种情况"></a><strong>1.5 管道读写的4种情况</strong></h5><ol>
<li>读写端正常，管道如果为空，读端就要阻塞，直到管道内出现数据</li>
<li>读写端正常，管道如果被写满，写端就要阻塞，直到管道内数据被读端读取</li>
<li>读端正常读，写端关闭，读端就会读到0，表明读到了文件（pipe）结尾，不会被阻塞</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/97e0a28c17bd4e6d862ce38e5b70942f.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/2a6864ab841b400b98da320f6f24d5ba.png" alt="img"></p>
<ol start="4">
<li>写端正常写，读端关闭，操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程（操作系统不会做低效、浪费内存等类似的工作，如果做了，那么就是操作系统的bug）</li>
</ol>
<p><img src="https://i-blog.csdnimg.cn/direct/c2a723327a584febb1fc2a6b30cac17e.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/cc38546d15e6461d8cd4479205de9d52.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/1ac5195a5651417e98c3aa710f689a27.png" alt="img"></p>
<p>操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程</p>
<p><img src="https://i-blog.csdnimg.cn/direct/8aab473539d74eacb5f1dbeb6ad91b62.png" alt="img"></p>
<p>其中前面两种情况就能够很好的说明，管道是自带同步与互斥机制的，读端进程和写端进程是有一个步调协调的过程的，不会说当管道没有数据了读端还在读取，而当管道已经满了写端还在写入。读端进程读取数据的条件是管道里面有数据，写端进程写入数据的条件是管道当中还有空间，若是条件不满足，则相应的进程就会被挂起，直到条件满足后才会被再次唤醒。</p>
<p>第三种情况也很好理解，读端进程已经将管道当中的所有数据都读取出来了，而且此后也不会有写端再进行写入了，那么此时读端进程也就可以执行该进程的其他逻辑了，而不会被挂起。<br>第四种情况也不难理解，既然管道当中的数据已经没有进程会读取了，那么写端进程的写入将没有意义，因此操作系统直接将写端进程杀掉。而此时子进程代码都还没跑完就被终止了，属于异常退出，那么子进程必然收到了某种信号。</p>
<hr>
<h5 id="1-6-实践操作："><a href="#1-6-实践操作：" class="headerlink" title="1.6 实践操作："></a><strong>1.6 实践操作：</strong></h5><p><strong>shell管道</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/b751056f955f4c87a7478a8d5e9eea26.png" alt="img"></p>
<p>hpp文件：c++的头文件。直接将.h和.cpp文件混在一起，之前 .h 和 .cpp 分开编译是因为为了打包成库，如果本身就奔着开源，那么大部分就是直接使用hpp后缀 </p>
<hr>
<p><strong>进程池</strong></p>
<p>由于每次fork一个子进程效率并不高，我们可以在空闲时让父进程fork出一些子进程，组成一个进程池，当有需要时指定进程池中任意一个进程分配任务，这样的效率就提高了。</p>
<hr>
<ol start="2">
<li><h3 id="命名管道（FIFO）"><a href="#命名管道（FIFO）" class="headerlink" title="命名管道（FIFO）"></a>命名管道（FIFO）</h3></li>
</ol>
<p>命名管道克服了匿名管道只能用于亲缘关系进程间通信的限制，它<strong>允许无亲缘关系的进程间通信</strong>。命名管道在<strong>文件系统中有一个名字</strong>，任何<strong>进程都可以通过这个名字来访问管道</strong>。</p>
<p> 命名管道和匿名管道一样，都是内存文件，只不过命名管道在磁盘有一个简单的映像，但这个映像的大小永远为0，因为命名管道和匿名管道都不会将通信数据刷新到磁盘当中</p>
<p>匿名管道是<strong>通过子进程继承父进程实现的看到同一份资源</strong>，而命名管道是通过 <strong>路径+文件名 确定同一份资源</strong>，该文件只存一份数据，即一份inode、一份文件缓冲区、一份操作方法集。</p>
<h5 id="2-1-mkfifo"><a href="#2-1-mkfifo" class="headerlink" title="2.1 mkfifo"></a>2.1 mkfifo</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man mkfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/d701f2ba3f804963bc137973690c6a64.png" alt="img"></p>
<p><strong>命令行创建命名管道</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo myfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/2c69c95ca6454a99b345156f4b07251e.png" alt="img"></p>
<p>可以看到，创建出来的文件的类型是**<code>p</code><strong>，代表该文件是</strong>命名管道文件**</p>
<p><strong>举例</strong>：我们打开两个终端，一个终端持续向命名管道追加写入字符串，另一个终端cat命名管道，<strong>两个终端靠命名管道实现echo进程与cat进程的通信</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/8896afd038b144b68ddf785541e29c05.png" alt="img"></p>
<p>echo 指令并不在左边终端打印，而是从命名管道myfifo传到右边终端的cat进程，并且在打印过程中命名管道大小不变（因为<strong>命名管道不会将通信数据刷新到磁盘当中</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程间通信的前提，是先让不同的进程看到同一份资源。那么为什么两个进程不直接读同一个磁盘上的文件？</span><br><span class="line">进行交流信息的进程只想用文件缓冲区来交流，只需要一个进程把数据放到缓冲区，另一个进程去拿就够了，如果是磁盘文件，它就需要刷盘，这是一个冗余的行为！</span><br><span class="line">管道文件不需要刷到磁盘，是一个内存级文件，所以即使追加写到命名管道，它的属性inode也不会改变，因为不会刷到磁盘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不同的进程怎么知道打开的是同一个文件？</span><br><span class="line">匿名管道是通过继承，而命名管道：路径+文件名</span><br><span class="line">我们在基础IO学过，路径+文件名具有唯一性，因为路径确定了分区，同一目录下文件名不能重复，因为文件名需要和inode一一映射，再者找到文件后发现是p属性，进程就知道要找到文件就是它了，所以这种方式就是命名管道通信方式</span><br></pre></td></tr></table></figure>

<p><strong>命名管道与匿名管道几乎完全相同，不同的一点就是命名管道可以让毫不相干、没有血缘关系的进程进行通信</strong></p>
<hr>
<p><strong>系统调用创建命名管道：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 mkfifo</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/5d01dead8e444736be94ba176473967f.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char *pathname, mode_t mode);</span><br><span class="line"></span><br><span class="line">mkfifo函数的第一个参数是pathname，表示要创建的命名管道文件。</span><br><span class="line">· 若pathname以路径的方式给出，则将命名管道文件创建在pathname路径下。</span><br><span class="line">· 若pathname以文件名的方式给出，则将命名管道文件默认创建在当前路径下。（注意当前路径的含义）</span><br><span class="line"></span><br><span class="line">mkfifo函数的第二个参数是mode，表示创建命名管道文件的默认权限。</span><br><span class="line">例如，将mode设置为0666，则命名管道文件创建出来的权限：</span><br><span class="line">prw-rw-rw-  具体权限会受到umask掩码的影响（0002） umask掩码是控制文件和目录默认权限的</span><br><span class="line"></span><br><span class="line">mkfifo函数的返回值。</span><br><span class="line">· 命名管道创建成功，返回0</span><br><span class="line">· 命名管道创建失败，返回-1</span><br></pre></td></tr></table></figure>

<p><strong>命名管道的打开规则</strong></p>
<p>1、如果当前打开操作是为读而打开FIFO时。</p>
<p>O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO。<br>O_NONBLOCK enable：立刻返回成功。<br>2、如果当前打开操作是为写而打开FIFO时。</p>
<p>O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO。<br>O_NONBLOCK enable：立刻返回失败，错误码为ENXIO。</p>
<hr>
<h5 id="2-2-unlink"><a href="#2-2-unlink" class="headerlink" title="2.2 unlink"></a>2.2 unlink</h5><p>unlink——删除命名管道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 3 unlink</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/6915a6229cea4a9dbe3644c92c3f41b0.png" alt="img"></p>
<hr>
<h5 id="2-3-实践通信"><a href="#2-3-实践通信" class="headerlink" title="2.3 实践通信"></a>2.3 实践通信</h5><p>comm.hpp 封装命名管道的创建与销毁功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span>    <span class="comment">//命名管道的文件名</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664               <span class="comment">//管道默认创建权限</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//enum错误类型，假定为进程退出码</span></span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREAT_ERR = <span class="number">1</span>,</span><br><span class="line">    FIFO_DELETE_ERR,</span><br><span class="line">    FIFO_OPEN_ERR</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//对创建和销毁命名管道做封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建命名管道，mkfifo</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREAT_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//销毁命名管道，unlink</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Log log;    <span class="comment">//日志</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>server.cc 服务端创建命名管道，打开管道读取数据（此时客户端未进程启动，所以会在open处阻塞）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 让服务端管理命名管道文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init init;</span><br><span class="line">    Log log;</span><br><span class="line">    <span class="comment">// 先设置日志为单文件输出</span></span><br><span class="line">    log.<span class="built_in">Enable</span>(Classfile);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开管道</span></span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Warning, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">    <span class="built_in">log</span>(Error, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让服务端作为读端</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(fd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer[x] = <span class="number">0</span>; <span class="comment">// 读取后在末尾处加\0，构成C语言字符串</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;client say# &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">log</span>(Debug, <span class="string">&quot;client quit, me too! error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// break出来表示写端读端都关闭了，所以关闭管道文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> cilent.cc 打开管道文件，从键盘读取数据，再向文件内write数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd  &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;client open file done&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">getline</span>(cin, line);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">write</span>(fd, line.<span class="built_in">c_str</span>(), line.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">在大多数现代操作系统和编程语言中，当一个进程被Ctrl+C（SIGINT信号）直接关闭时，程序会接收到一个中断信号，这通常会导致程序立即终止执行。对于C++等需要显式资源管理的语言来说，这意味着如果程序在没有适当处理该信号的情况下被终止，那么程序中的对象可能不会按预期调用它们的析构函数。</span><br><span class="line"></span><br><span class="line">析构函数的调用通常发生在以下几种情况：</span><br><span class="line"></span><br><span class="line">作用域结束：对于局部变量，当它们的作用域结束时（例如，函数返回或块结束），它们的析构函数会被自动调用。</span><br><span class="line"></span><br><span class="line">delete操作符：对于通过new操作符动态分配的对象，当使用delete操作符释放这些对象时，它们的析构函数会被调用。</span><br><span class="line"></span><br><span class="line">程序正常结束：当程序正常结束（例如，通过return语句从main函数返回）时，全局对象和静态局部对象的析构函数会按照与它们被创建时相反的顺序被调用。</span><br><span class="line"></span><br><span class="line">然而，当程序接收到SIGINT信号（如Ctrl+C）并直接终止时，这些规则并不适用。程序会立即停止执行，而不会执行任何清理操作（如调用析构函数）。这可能导致资源泄漏，比如未关闭的文件描述符、未释放的内存等。</span><br><span class="line"></span><br><span class="line">要处理这种情况，你可以：</span><br><span class="line"></span><br><span class="line">使用信号处理：在C++中，你可以使用信号处理函数（如signal或sigaction在UNIX/Linux系统中）来捕获SIGINT信号，并执行一些清理工作。但请注意，从信号处理函数中直接调用非异步信号安全的函数（包括大多数C++库函数）是不安全的。</span><br><span class="line"></span><br><span class="line">使用RAII（Resource Acquisition Is Initialization）：尽量使用RAII技术来管理资源。RAII是一种在对象构造时获取资源并在对象析构时释放资源的编程技术。这样，即使程序因为接收到SIGINT信号而异常终止，如果对象的析构函数有机会被调用（这通常很难保证），那么资源也能被正确释放。然而，如前所述，当程序因为信号而终止时，析构函数可能不会被调用。</span><br><span class="line"></span><br><span class="line">优雅地关闭程序：在程序的关键位置添加检查点，以检测用户是否请求了中断（例如，通过捕获SIGINT信号），并在检测到中断时执行必要的清理工作，然后正常退出程序。</span><br><span class="line"></span><br><span class="line">综上所述，当程序被Ctrl+C直接关闭时，程序中的对象可能不会按预期调用它们的析构函数，这可能导致资源泄漏等问题。因此，在编写需要处理中断信号的程序时，应该采取适当的措施来确保资源被正确管理。</span><br></pre></td></tr></table></figure>

<p>先关闭客户端（写端），服务端（读端）就会因为写端关闭而读到0，然后break，init对象的生命周期随程序结束，才会调用它的析构函数，unlink命名管道。</p>
<p>如果直接ctrl c掉服务端，那么进程直接退出，不会调用析构函数，这就会导致内存泄露</p>
<hr>
<p><strong>多文件编译Makefile</strong></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:all</span></span><br><span class="line"><span class="section">all:client server</span></span><br><span class="line"> </span><br><span class="line"><span class="section">client:client.cc</span></span><br><span class="line">	g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line"><span class="section">server:server.cc</span></span><br><span class="line">	g++ -o <span class="variable">$@</span> <span class="variable">$^</span> -std=c++11</span><br><span class="line">	</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f client server</span><br></pre></td></tr></table></figure>

<hr>
<ol start="3">
<li><h3 id="命名管道和匿名管道的区别"><a href="#命名管道和匿名管道的区别" class="headerlink" title="命名管道和匿名管道的区别"></a>命名管道和匿名管道的区别</h3></li>
</ol>
<ul>
<li><strong>命名管道有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作</strong>。</li>
<li>匿名管道没有明确的路径、文件名和inode号，仅存在于内存中，<strong>通过进程间的文件描述符进行通信</strong><br>匿名管道<strong>由pipe函数创建并打开</strong>。</li>
<li><strong>命名管道由mkfifo函数创建，由open函数打开</strong>。</li>
<li>FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在于<strong>它们创建与打开的方式不同</strong>，一旦这些工作完成之后，它们具有相同的语义。</li>
</ul>
<hr>
<h3 id="四、system-V"><a href="#四、system-V" class="headerlink" title="四、system V"></a>四、system V</h3><p>管道通信本质是基于文件的，也就是说操作系统并没有为此做过多的设计工作，而system V IPC是操作系统特地设计的一种通信方式。但是不管怎么样，它们的本质都是一样的，都是在想尽办法让不同的进程看到同一份由操作系统提供的资源。</p>
<p>system V IPC提供的通信方式有以下三种：</p>
<ul>
<li>system V<strong>共享内存</strong>：<strong>允许两个或多个进程共享一段内存区域</strong>，是进程间<strong>通信中最快</strong>的方式，因为<strong>数据不需要在进程间复制</strong>。</li>
<li>system V<strong>消息队列</strong>：允许<strong>一个或多个进程写入或读取消息</strong>，可以看作是一个<strong>消息链表</strong>，<strong>每个消息都有一个类型和一个优先级</strong></li>
<li>system V<strong>信号量</strong>：用于<strong>同步进程</strong>，<strong>控制多个进程对共享资源的访问</strong>。System V信号量<strong>分为二进制信号量和计数信号量</strong>。</li>
</ul>
<p>其中，system V共享内存和system V<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">消息队列</a>是以传送数据为目的的，而<strong>system V信号量是为了保证进程间的同步与互斥而设计的，虽然system V信号量和通信好像没有直接关系，但属于通信范畴</strong></p>
<hr>
<h4 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1. 共享内存"></a>1. 共享内存</h4><h5 id="1-1-共享内存原理"><a href="#1-1-共享内存原理" class="headerlink" title="1.1 共享内存原理"></a>1.1 共享内存原理</h5><p>类似<strong>动态库加载</strong>，操作系统在物理内存创建一块区域，<strong>通过页表映射到需要通信的进程的虚拟地址空间的共享区中</strong>，并<strong>向应用层返回一个起始的虚拟地址</strong>，使得虚拟地址和物理地址之间建立起对应关系，从而使不同的进程看到同一份资源，这块物理内存就是共享内存。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/a0026aa10ab24fbeaf9bec4e20d9d136.png" alt="img"></p>
<p><strong>可以概括</strong>为：申请内存、挂接到进程地址空间、返回首地址。并且不能由进程自己malloc内存，因为进程是独立的，需要操作系统创建内存空间，创建信道，才可以实现不同进程通信。所以需求方进程要求执行方操作系统完成任务的过程就是<strong>系统调用</strong>。</p>
<h5 id="1-2-共享内存数据结构"><a href="#1-2-共享内存数据结构" class="headerlink" title="1.2 共享内存数据结构"></a>1.2 共享内存数据结构</h5><p>当进程之间的共享内存多了之后，操作系统就需要描述并组织起来大量的共享内存！所以对共享内存的增删查改就变成了对组织的数据结构的增删查改，所以共享内存除了在内存当中真正开辟空间之外，<strong>系统一定还要为共享内存维护相关的内核数据结构</strong>。</p>
<p><strong>共享内存的数据结构：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shmid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span>     shm_perm;   <span class="comment">/* operation perms */</span></span><br><span class="line">	<span class="type">int</span>         shm_segsz;  <span class="comment">/* size of segment (bytes) */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_atime;  <span class="comment">/* last attach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_dtime;  <span class="comment">/* last detach time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span>     shm_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>  shm_cpid;   <span class="comment">/* pid of creator */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span>  shm_lpid;   <span class="comment">/* pid of last operator */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>      shm_nattch; <span class="comment">/* no. of current attaches */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>      shm_unused; <span class="comment">/* compatibility */</span></span><br><span class="line">	<span class="type">void</span>            *shm_unused2;   <span class="comment">/* ditto - used by DIPC */</span></span><br><span class="line">	<span class="type">void</span>            *shm_unused3;   <span class="comment">/* unused */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们申请了一块共享内存后，<strong>为了让要实现通信的进程能够看到同一个共享内存</strong>，因此<strong>每一个共享内存被申请时都有一个key值，这个key值用于标识系统中共享内存的唯一性</strong>。</p>
<p>可以看到上面共享内存数据结构的第一个成员是shm_perm，shm_perm是一个ipc_perm类型的结构体变量，每个共享内存的key值存储在shm_perm这个结构体变量当中，其中ipc_perm结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-共享内存的建立与释放"><a href="#1-3-共享内存的建立与释放" class="headerlink" title="1.3 共享内存的建立与释放"></a>1.3 共享内存的建立与释放</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">共享内存的建立大致包括以下两个过程：</span><br><span class="line">1. 在物理内存当中申请共享内存空间。</span><br><span class="line">2. 将申请到的共享内存挂接到地址空间，即建立映射关系。</span><br><span class="line"></span><br><span class="line">共享内存的释放大致包括以下两个过程：</span><br><span class="line">1. 将共享内存与地址空间去关联，即取消映射关系。</span><br><span class="line">2. 释放共享内存空间，即将物理内存归还给系统。</span><br></pre></td></tr></table></figure>

<h5 id="1-4-共享内存的创建"><a href="#1-4-共享内存的创建" class="headerlink" title="1.4 共享内存的创建"></a>1.4 共享内存的创建</h5><p>创建共享内存我们需要用shmget函数，shmget函数的函数原型如下：</p>
<p><strong>shmget</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 shmget</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/04895e1b544d4d0fa66d0fe1c72489c3.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/ba593954601d4780897c1687e9bf04bd.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shmget函数的参数说明：</span><br><span class="line">· 第一个参数key，表示待创建共享内存在系统当中的唯一标识。</span><br><span class="line">· 第二个参数size，表示待创建共享内存的大小。</span><br><span class="line">· 第三个参数shmflg，表示创建共享内存的方式。</span><br></pre></td></tr></table></figure>

<p><strong>shmflg：</strong>创建共享内存的操作只需要一次，剩下的进程只需要获取就好了，所以需要有一个参数来标识</p>
<p><img src="https://i-blog.csdnimg.cn/direct/c8b8a14a9f354f04b86dca8b59bda892.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IPC_CREAT：如果申请的共享内存不存在，就创建；存在，就获取并返回。（这些都是宏，标记位，每个bit都不相同）</span><br><span class="line">IPC_CREAT | IPC_EXCL：如果申请的共享内存不存在，就创建；存在，就出错返回原有的共享内存。</span><br><span class="line">解释：第二个搭配确保了，如果我们申请成功了一个共享内存，这个共享内存一定是一个新的！并且 IPC_EXCL不单独使用</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shmget函数的返回值说明：</span><br><span class="line">· shmget调用成功，返回一个有效的共享内存标识符（用户层标识符），类似文件句柄，我们使用后续接口时都要通过这个句柄对指定的共享内存进行操作。</span><br><span class="line">· shmget调用失败，返回-1。</span><br><span class="line"></span><br><span class="line">在进程内，shimid 用来标识资源的唯一性，shmid并不像fd那样是0，1，2的小的数组下标，shmid数值很大，但是他也是一个数组下标，在它内部还有一套算法。shmid搞特殊，因为Linux中一切皆文件，那么共享内存也可以被看作文件，那么我们也应该使用fd就可以访问，这是因为当初shmid 标准没有制定好。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：我们把具有标定某种资源能力的东西叫做句柄，而这里shmget函数的返回值实际上就是共享内存的句柄，这个句柄可以在用户层标识共享内存，当共享内存被创建后，我们在后续使用共享内存的相关接口时，都是需要通过这个句柄对指定共享内存进行各种操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们怎么保证让不同的进程看到同一个共享内存？怎么知道这个共享内存是是否存在呢？</span><br><span class="line">通过相同的参数调用ftok函数，获取相同的Key值</span><br></pre></td></tr></table></figure>

<p>传入shmget函数的第一个参数key，需要我们使用<strong>ftok</strong>函数进行获取</p>
<p><img src="https://i-blog.csdnimg.cn/direct/b7a3ce86ce8143b1be7ed6e5f236ca4c.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key_t ftok(const char *pathname, int proj_id);</span><br><span class="line"></span><br><span class="line">ftok函数的作用就是，将一个已存在的路径名pathname和一个整数标识符proj_id转换成一个key值，称为IPC键值，在使用shmget函数获取共享内存时，这个key值会被填充进维护共享内存的数据结构当中。需要注意的是，pathname所指定的文件必须存在且可存取。</span><br><span class="line">ftok是一套算法，用路径名和项目id进行数值计算，获得冲突概率极低的数字 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为什么要让用户自己指定key，而不是操作系统自动生成？</span><br><span class="line">操作系统完全有能力创建很多的不冲突的key，但是操作系统创建的key只能由一个进程拿到，又因为进程的独立性，其他的想要和该进程通信的进程（没有血缘关系）拿不到该数据，又需要通信传递key，这就矛盾了，所以让用户（程序员）约定一个key，根据ftok使用通向的路径名和项目id，即使通信双方看不到彼此，也能获取相同的key，这样才可以看到同一个共享内存</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">使用ftok函数生成key值可能会产生冲突，此时可以对传入ftok函数的参数进行修改。</span><br><span class="line">需要进行通信的各个进程，在使用ftok函数获取key值时，都需要采用同样的路径名和和整数标识符，进而生成同一种key值，然后才能找到同一个共享资源。</span><br></pre></td></tr></table></figure>

<p>至此我们就可以使用ftok和shmget函数创建一块共享内存了，创建后我们可以将共享内存的key值和句柄进行打印，以便观察，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Log log;</span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享内存权限在flag参数处追加</p>
<p><img src="https://i-blog.csdnimg.cn/direct/3b133402c6da4d8790bf62403a1fdf36.png" alt="img"></p>
<hr>
<p><strong>在Linux中，查看系统内IPC的指令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/fa81fa78b3394088a3dc573f00c78a24.png" alt="img"></p>
<p>单独使用 <strong><code>ipcs</code><strong>命令时，会默认列出消息队列、共享内存以及信号量相关的信息，若只想查看它们之间某一个的相关信息，可以选择携带以下</strong>选项：</strong></p>
<ul>
<li>-q：列出消息队列相关信息。</li>
<li>-m：列出共享内存相关信息。</li>
<li>-s：列出信号量相关信息。</li>
</ul>
<p><img src="https://i-blog.csdnimg.cn/direct/7feae806f0b344bf9b32a589a3d01364.png" alt="img"></p>
<p><code>ipcs</code>命令输出的每列信息的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>key</strong></th>
<th><strong>系统区别各个共享内存的唯一标识</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>shmid</strong></td>
<td><strong>共享内存的用户层id（句柄）</strong></td>
</tr>
<tr>
<td><strong>owner</strong></td>
<td><strong>共享内存的拥有者</strong></td>
</tr>
<tr>
<td><strong>perms</strong></td>
<td><strong>共享内存的权限</strong></td>
</tr>
<tr>
<td><strong>bytes</strong></td>
<td><strong>共享内存的大小</strong></td>
</tr>
<tr>
<td><strong>nattch</strong></td>
<td><strong>关联共享内存的进程数</strong></td>
</tr>
<tr>
<td><strong>status</strong></td>
<td><strong>共享内存的状态</strong></td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <strong>key是在内核层面上</strong>保证共享内存唯一性的方式，而<strong>shmid是在用户层面上</strong>保证共享内存的唯一性，key和shmid之间的关系类似于fd和FILE*之间的的关系。</p>
<hr>
<p><strong>共享内存挂接</strong></p>
<p><strong>共享内存创建后，开始调用系统调用shmat进行挂接</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/8514d249f0ac4ccdbcb462128f9f5eea.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line"></span><br><span class="line">shmat函数的参数说明：</span><br><span class="line">· 第一个参数shmid：表示待关联共享内存的用户级标识符。应用层都是以shmid为准</span><br><span class="line">· 第二个参数shmaddr：指定共享内存映射到进程地址空间的某一地址，通常设置为NULL，表示让内核自己决定一个合适的地址位置。最终的挂接位置会被返回</span><br><span class="line">· 第三个参数shmflg：表示关联共享内存时设置的某些属性。挂接时按什么权限，在创建共享内存时的权限就可以了，不用再修改，所以可以从传0</span><br></pre></td></tr></table></figure>

<p>其中，作为shmat函数的第三个参数传入的常用的选项有以下三个：</p>
<table>
<thead>
<tr>
<th align="left"><strong>选项</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SHM_RDONLY</strong></td>
<td align="left">关联共享内存后只进行读取操作</td>
</tr>
<tr>
<td align="left"><strong>SHM_RND</strong></td>
<td align="left">若shmaddr不为NULL，则关联地址自动向下调整为SHMLBA的整数倍。公式：shmaddr-(shmaddr%SHMLBA)</td>
</tr>
<tr>
<td align="left"><strong>0</strong></td>
<td align="left">默认为读写权限</td>
</tr>
</tbody></table>
<p><strong>shmat函数的返回值说明：</strong></p>
<ul>
<li>shmat调用成功，返回共享内存映射到进程地址空间中的起始地址。</li>
<li>shmat调用失败，返回(void*)-1。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="1-5-共享内存去关联"><a href="#1-5-共享内存去关联" class="headerlink" title="1.5 共享内存去关联"></a>1.5 共享内存去关联</h5><p>取消共享内存与进程地址空间之间的关联我们需要用shmdt函数，shmdt函数的函数原型如下：</p>
<p><img src="https://i-blog.csdnimg.cn/direct/80ceea1a523f41068cf787b11aec6533.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure>

<p>去掉共享内存的关联，如果直接进程退出，那么进程会释放它的进程虚拟地址空间，和页表映射的物理内存，所以此时共享内存的引用计数–，<strong>ipcs -m</strong> 就可以查看到 nattck （挂接数）减1</p>
<p><strong>shmdt函数的参数说明：</strong></p>
<ul>
<li>待去关联共享内存的起始地址，即调用shmat函数时得到的起始地址。</li>
</ul>
<p><strong>shmdt函数的返回值说明：</strong></p>
<ul>
<li>shmdt调用成功，返回0。</li>
<li>shmdt调用失败，返回-1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只给它起始地址，shmdt它是怎么知道我们申请的共享内存有多大呢？</span><br><span class="line">因为需要知道具体大小才能在页表消除映射，并使共享内存引用计数--</span><br></pre></td></tr></table></figure>

<p> 这个问题就如同malloc申请内存、free只需要起始地址，这两个概念是完全相同的，因为操作系统有结构体维护申请的空间，例如malloc，如果你申请100字节，那么实际上操作系统会在进程地址空间的堆区申请120字节，多出来的就是维护申请空间信息的变量</p>
<p><strong>举例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 将共享内存段与当前进程脱离不等于删除共享内存，只是取消了当前进程与该共享内存之间的联系。</p>
<hr>
<h5 id="1-6-共享内存的释放"><a href="#1-6-共享内存的释放" class="headerlink" title="1.6 共享内存的释放"></a><strong>1.6 共享内存的释放</strong></h5><p>通过上面创建共享内存的实验可以发现，当我们的进程运行完毕后，申请的共享内存依旧存在，并没有被操作系统释放。即进程退出，共享内存没有被释放！</p>
<p>这表明<strong>共享内存的生命周期是跟随内核的</strong>（匿名管道是生命周期是随进程的，命名管道生命周期独立于进程，需要显示的unlink），<strong>用户不主动关闭，共享内存会一直存在，除非内核重启或用户释放</strong>。如果我们忘记释放共享内存，那么这就算内存泄漏；如果我们没有忘记，那么这就不算内存泄漏</p>
<p>例如两个进程通信完毕后走了，操作系统把共享内存释放了，过了一段时间，这两个进程又回来继续通信，此时发现共享内存没有了，而里面可能还有它们上一次通信的内容，此时操作系统就算是惹祸了</p>
<p>此时我们若是要将创建的共享内存释放，有两个方法，一就是<strong>使用命令释放共享内存</strong>，二就是在进程通信完毕后<strong>调用释放共享内存的系统调用函数</strong>进行释放。</p>
<hr>
<p> <strong>命令释放共享内存</strong></p>
<p>在shell中使用命令释放共享内存 </p>
<p><strong>ipcrm</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m 共享内存shmid</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 指定删除时使用的是共享内存的用户层id，即列表当中的shmid。用户层统一使用shmid，命令行输入也是用户层。</p>
<p><strong>系统调用释放共享内存</strong></p>
<p>在程序中，释放共享内存我们需要用shmctl函数，控制共享内存，我们用它来删除共享内存。shmctl函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">shmctl函数的参数说明：</span><br><span class="line">· 第一个参数shmid，表示所控制共享内存的用户级标识符。</span><br><span class="line">· 第二个参数cmd，表示具体的控制动作。</span><br><span class="line">· 第三个参数buf，用于获取或设置所控制共享内存的数据结构。</span><br><span class="line">shmctl函数的返回值说明：</span><br><span class="line">· shmctl调用成功，返回<span class="number">0</span>。</span><br><span class="line">· shmctl调用失败，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>其中，作为shmctl函数的第二个参数传入的常用的选项有以下三个：</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">IPC_STAT</td>
<td align="left">获取共享内存的当前关联值，此时参数buf作为输出型参数</td>
</tr>
<tr>
<td align="left">IPC_SET</td>
<td align="left">在进程有足够权限的前提下，将共享内存的当前关联值设置为buf所指的数据结构中的值</td>
</tr>
<tr>
<td align="left">IPC_RMID</td>
<td align="left">删除共享内存段</td>
</tr>
</tbody></table>
<p>我们目前使用该函数时，不需要获取值，所以在第三个参数处传nullptr即可（我们是C&#x2F;C++混编，所以使用了nullptr）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//通信...</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="1-7-实践通信"><a href="#1-7-实践通信" class="headerlink" title="1.7 实践通信"></a><strong>1.7 实践通信</strong></h5><p> 我们讲了这么多全都是预备工作，创建、挂接、去关联、释放共享内存。那么预备工作完成后，双方如何进行通信？</p>
<pre><code>很简单，此时共享内存已经被映射到各进程的地址空间中，已经属于进程（进程：这就是我创建的空间，我随便用），使用方法与平时我们 malloc 的空间使用方法完全相同！直接访问、写入即可
为了让服务端和客户端在使用ftok函数获取key值时，能够得到同一种key值，那么服务端和客户端传入ftok函数的路径名和和整数标识符必须相同，这样才能生成同一种key值，进而找到同一个共享资源进行挂接。这里我们可以将这些需要共用的信息放入一个头文件当中，服务端和客户端共用这个头文件即可。
我们依旧使用日志类来管理程序。共享内存流程：创建、挂接、去关联、释放
</code></pre>
<p><strong>comm.hpp</strong></p>
<p>该文件用来定义+实现共享内存的创建和获取</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMM_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMM_HPP__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line">Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>服务端processa.cc</strong></p>
<p>​    读取共享内存的信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say@ &quot;</span> &lt;&lt; shmaddr &lt;&lt; endl; <span class="comment">//直接访问共享内存</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除</span></span><br><span class="line">    <span class="comment">//如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端processb.cc</strong> </p>
<p>​    向共享内存写入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//processb直接使用即可，共享内存的创建和销毁由processa全权负责</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">GetShm</span>();</span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(shmaddr, <span class="number">4096</span>, stdin);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);         <span class="comment">//去掉共享内存关联</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i-blog.csdnimg.cn/direct/968e31eab76c453e9b5cc43ba1c135d5.png" alt="img"></p>
<p><strong>根据结果来看，共享内存有几个特性：</strong></p>
<ol>
<li>共享内存<strong>没有同步互斥之类的保护机制</strong>，跟管道不同，共享内存的读端进程不会等待写端进程就绪，会一直读空字符串。所以我们可以将共享内存和管道结合，当共享内存创建后，两者再使用管道，那么读端就必须等待写端写入数据，否则阻塞，这就实现了同步！</li>
<li>当共享内存<strong>创建好后就不再需要调用系统接口进行通信</strong>了，共享内存是所有的进程间通信中，<strong>速度是最快的，因为拷贝少</strong>！不需要read、write等系统接口进行通信。<strong>一旦有了共享内存，挂接到自己的地址空间中，那么直接使用起始地址进程操作即可</strong>，就如同操作自己malloc的空间，而管道创建好后仍需要read、write等系统接口进行通信。</li>
<li>共享内存<strong>内部的数据由用户自己维护</strong></li>
</ol>
<p><strong>我们来算算管道通信拷贝次数：</strong></p>
<p><img src="https://i-blog.csdnimg.cn/direct/b42b7dfdf6cc4a50ab34873024ba0765.png" alt="img"></p>
<p>使用管道通信的方式，将一个文件从一个进程传输到另一个进程需要进行<strong>四次拷贝操作：</strong></p>
<ol>
<li>服务端将信息<strong>从输入文件</strong>复制到服务端的临时缓冲区中。</li>
<li>将服务端<strong>临时缓冲区</strong>的信息复制到<strong>管道</strong>中。</li>
<li>客户端将信息从<strong>管道</strong>复制到客户端的<strong>缓冲区</strong>中。</li>
<li>将客户端<strong>临时缓冲区</strong>的信息复制到<strong>输出文件</strong>中。</li>
</ol>
<p><strong>注意：</strong>服务端和客户端的退出顺序 ，将共享内存和命名管道结合</p>
<p>与命名管道的服务端和客户端相同，只有先关闭客户端（写端），读端才会读到0，然后break，再执行后序的shmctl，shmctl是真的能删除共享内存，不用手动的使用 ipcrm -m 删除共享内存</p>
<p>如果直接ctrl c掉读端，进程会直接退出，不会执行后面的代码</p>
<p><img src="https://i-blog.csdnimg.cn/direct/138bd8d4886a45fab323102ad3415406.png" alt="img"></p>
<p><img src="https://i-blog.csdnimg.cn/direct/03e4c97343c7487ebb40c70211698faa.png" alt="img"></p>
<p>每一个共享内存都有自己的数据结构，里面就有相应的key值</p>
<p>共享内存+命名管道代码</p>
<hr>
<p><strong>comm.hpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMM_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMM_HPP__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_FILE <span class="string">&quot;./myfifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODE 0664</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    FIFO_CREATE_ERR = <span class="number">1</span>,</span><br><span class="line">    FIFO_DELETE_ERR,</span><br><span class="line">    FIFO_OPEN_ERR</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建管道</span></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">mkfifo</span>(FIFO_FILE, MODE);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_CREATE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Init</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//销毁管道</span></span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">unlink</span>(FIFO_FILE);</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(FIFO_DELETE_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Log log;</span><br><span class="line"><span class="comment">// 共享内存的大小一般建议是4096的整数倍</span></span><br><span class="line"><span class="comment">// 4097,实际上操作系统给你的是4096*2的大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> size = <span class="number">4096</span>; </span><br><span class="line"><span class="type">const</span> string pathname=<span class="string">&quot;/home/ljs&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> proj_id = <span class="number">0x666</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//进程调用的GetKey函数相同，代表着它们拿到的Key一定相同</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">GetKey</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">ftok</span>(pathname.<span class="built_in">c_str</span>(), proj_id);</span><br><span class="line">    <span class="keyword">if</span>(k &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;ftok error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;ftok success, key is : 0x%x&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建共享内存</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShareMemHelper</span><span class="params">(<span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用GetKey获取key</span></span><br><span class="line">    <span class="type">key_t</span> k = <span class="built_in">GetKey</span>();</span><br><span class="line">    <span class="comment">//创建</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(k, size, flag);  </span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;create share memory error: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log</span>(Info, <span class="string">&quot;create share memory success, shmid: %d&quot;</span>, shmid);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CreateShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT | IPC_EXCL | <span class="number">0666</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetShm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetShareMemHelper</span>(IPC_CREAT); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> <strong>processa.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> Log log;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//由processa来管理共享内存的创建和销毁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Init init;</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">CreateShm</span>();                            <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ipc code 在这里！！</span></span><br><span class="line">    <span class="comment">// 一旦有人把数据写入到共享内存，其实我们立马能看到了！！</span></span><br><span class="line">    <span class="comment">// 不需要经过系统调用，直接就能看到数据了！</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_RDONLY); <span class="comment">// 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// struct shmid_ds shmds;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">ssize_t</span> s = <span class="built_in">read</span>(fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client say@ &quot;</span> &lt;&lt; shmaddr &lt;&lt; endl; <span class="comment">//直接访问共享内存</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// shmctl(shmid, IPC_STAT, &amp;shmds);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm size: &quot; &lt;&lt; shmds.shm_segsz &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm nattch: &quot; &lt;&lt; shmds.shm_nattch &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// printf(&quot;shm key: 0x%x\n&quot;,  shmds.shm_perm.__key);</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;shm mode: &quot; &lt;&lt; shmds.shm_perm.mode &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除</span></span><br><span class="line">    <span class="comment">//如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用</span></span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);                     <span class="comment">//取消关联</span></span><br><span class="line">    <span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="literal">nullptr</span>);   <span class="comment">//删除共享内存</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>processb.cc</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;comm.hpp&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//processb直接使用即可，共享内存的创建和销毁由processa全权负责</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">GetShm</span>();</span><br><span class="line">    <span class="type">char</span> *shmaddr = (<span class="type">char</span>*)<span class="built_in">shmat</span>(shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);    <span class="comment">//挂接</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(FIFO_FILE, O_WRONLY);                 <span class="comment">// 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！</span></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">log</span>(Fatal, <span class="string">&quot;error string: %s, error code: %d&quot;</span>, <span class="built_in">strerror</span>(errno), errno);</span><br><span class="line">        <span class="built_in">exit</span>(FIFO_OPEN_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一旦有了共享内存，挂接到自己的地址空间中，你直接把他当成你的内存空间来用即可！</span></span><br><span class="line">    <span class="comment">// 不需要调用系统调用</span></span><br><span class="line">    <span class="comment">// ipc code</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please Enter@ &quot;</span>;</span><br><span class="line">        <span class="built_in">fgets</span>(shmaddr, <span class="number">4096</span>, stdin);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">write</span>(fd, <span class="string">&quot;c&quot;</span>, <span class="number">1</span>);  <span class="comment">// 通知对方</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">shmdt</span>(shmaddr);         <span class="comment">//去掉共享内存关联</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-System-V消息队列"><a href="#2-System-V消息队列" class="headerlink" title="2. System V消息队列"></a>2. System V消息队列</h4><h5 id="2-1-消息队列基本原理"><a href="#2-1-消息队列基本原理" class="headerlink" title="2.1 消息队列基本原理"></a>2.1 消息队列基本原理</h5><p> 消息队列实际上就是<strong>在系统当中创建了一个队列</strong>，<strong>队列当中的每个成员都是一个数据块</strong>，<strong>这些数据块都由类型和信息两部分构成</strong>，两个互相通信的进程通过某种方式看到同一个消息队列，这两个进程向对方发数据时，都在消息队列的<strong>队尾添加数据块</strong>，这两个进程<strong>获取数据块时</strong>，都在消息队列的<strong>队头取数据块</strong>。</p>
<p><img src="https://i-blog.csdnimg.cn/direct/082663a30ffe4fd9bbd6bc9b93331e8a.png" alt="img"></p>
<p>其中消息队列当中的某一个数据块是由谁发送给谁的，取决于数据块的类型。</p>
<p><strong>总结一下：</strong></p>
<ol>
<li>消息队列提供了一个从一个进程向另一个进程发送数据块的方法。</li>
<li>每个数据块都被认为是有一个类型的，接收者进程接收的数据块可以有不同的类型值。</li>
<li>和共享内存一样，<strong>消息队列的资源也必须自行删除</strong>，否则不会自动清除，因为system V IPC资源的生命周期是随内核的。</li>
</ol>
<hr>
<h5 id="2-2-消息队列数据结构"><a href="#2-2-消息队列数据结构" class="headerlink" title="2.2 消息队列数据结构"></a>2.2 消息队列数据结构</h5><p>​    当然，系统当中也可能会存在大量的消息队列，系统一定也要为消息队列维护相关的内核数据结构。</p>
<p>消息队列的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msqid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span> msg_perm;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">msg</span> *msg_first;      <span class="comment">/* first message on queue,unused  */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">msg</span> *msg_last;       <span class="comment">/* last message in queue,unused */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_stime;  <span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_rtime;  <span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> msg_ctime;  <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  msg_lcbytes; <span class="comment">/* Reuse junk fields for 32 bit */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  msg_lqbytes; <span class="comment">/* ditto */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_cbytes;  <span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_qnum;    <span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> msg_qbytes;  <span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span> msg_lspid;   <span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="type">__kernel_ipc_pid_t</span> msg_lrpid;   <span class="comment">/* last receive pid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到消息队列数据结构的第一个成员是<code>msg_perm</code>，它和<code>shm_perm</code>是同一个类型的结构体变量，<code>ipc_perm</code>结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="2-3-消息队列的创建"><a href="#2-3-消息队列的创建" class="headerlink" title="2.3 消息队列的创建"></a><strong>2.3 消息队列的创建</strong></h5><p>创建消息队列我们需要用msgget函数，msgget函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数接口几乎与共享内存完全相同，这里还不用传size</strong></p>
<p>说明一下：</p>
<ul>
<li>创建消息队列也<strong>需要使用ftok函</strong>数生成一个key值，这个key值作为msgget函数的第一个参数。</li>
<li><strong>msgget函数的第二个参数</strong>，与创建共享内存时使用的<strong>shmget函数的第三个参数相同</strong>。</li>
<li>消息队列创建成功时，msgget函数返回的一个有效的消息队列标识符（用户层标识符）。</li>
</ul>
<h5 id="2-4-消息队列的释放"><a href="#2-4-消息队列的释放" class="headerlink" title="2.4 消息队列的释放"></a>2.4 消息队列的释放</h5><p>释放消息队列我们需要用msgctl函数，msgctl函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>说明一下：</strong></p>
<ul>
<li>msgctl函数的参数与释放共享内存时使用的shmctl函数的三个参数相同，只不过msgctl函数的第三个参数传入的是消息队列的相关数据结构</li>
</ul>
<hr>
<p><strong>向消息队列发送数据</strong></p>
<p>向消息队列发送数据我们需要用msgsnd函数，msgsnd函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>msgsnd函数的参数说明：</strong></p>
<ul>
<li>第一个参数msqid，表示消息队列的用户级标识符。</li>
<li>第二个参数msgp，表示待发送的数据块。</li>
<li>第三个参数msgsz，表示所发送数据块的大小</li>
<li>第四个参数msgflg，表示发送数据块的方式，一般默认为0即可。</li>
</ul>
<p><strong>msgsnd函数的返回值说明：</strong></p>
<ul>
<li>msgsnd调用成功，返回0。</li>
<li>msgsnd调用失败，返回-1。</li>
</ul>
<p> 其中<strong>msgsnd</strong>函数的第二个参数必须为以下结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">msgbuf</span>&#123;</span><br><span class="line">	<span class="type">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">	<span class="type">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 该结构当中的第二个成员mtext即为待发送的信息，当我们定义该结构时，mtext的大小可以自己指定。</p>
<hr>
<h5 id="2-5-从消息队列获取数据"><a href="#2-5-从消息队列获取数据" class="headerlink" title="2.5 从消息队列获取数据"></a>2.5 从消息队列获取数据</h5><p>从消息队列获取数据我们需要用msgrcv函数，msgrcv函数的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<p>msgrcv函数的参数说明：</p>
<ul>
<li>第一个参数msqid，表示消息队列的用户级标识符。</li>
<li>第二个参数msgp，表示获取到的数据块，是一个输出型参数。</li>
<li>第三个参数msgsz，表示要获取数据块的大小</li>
<li>第四个参数msgtyp，表示要接收数据块的类型。</li>
</ul>
<p>msgrcv函数的返回值说明：</p>
<ul>
<li>msgsnd调用成功，返回实际获取到mtext数组中的字节数。</li>
<li>msgsnd调用失败，返回-1。</li>
</ul>
<p><em><strong>*消息队列不作为重点*</strong></em></p>
<hr>
<h4 id="3-System-V信号量"><a href="#3-System-V信号量" class="headerlink" title="3. System V信号量"></a>3. System V信号量</h4><p><strong>3.1 信号量的基本概念</strong></p>
<ul>
<li>定义：信号量是一种用于<strong>保证两个或多个关键代码段不被并发调用的机制</strong>。<strong>线程在进入一个关键代码段之前，必须先获取一个信号量；一旦该关键代码段执行完成，线程必须释放信号量</strong>。</li>
<li><strong>类型</strong>：信号量主要分为<strong>计数信号量（Counting Semaphore）和二元信号量（Binary Semaphore）或称为互斥量（Mutex）</strong>。<strong>计数信号量允许多个线程访问一定数量的资源</strong>，而<strong>二元信号量则只允许一个线程访问资源</strong>。</li>
<li><strong>核心操作</strong>：信号量的核心操作包括<strong>P操作（也称为wait或down操作）</strong>和V操作<strong>（也称为signal或up操作）</strong>。P操作会使信号量的值减1，<strong>如果信号量的值已经为0，则调用线程将会被阻塞</strong>；V操作则使信号量的值加1，如果有线程因为信号量值为0而被阻塞，则这些线程会被唤醒。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">共享内存中，如果进程A正在写入10个数字，只写了一部分，例如5个数字，此时进程B直接就拿走了这5个数字，但是这10个数字必须组合在一起才有意义，所以B拿了也没用，这就会导致数据不一致问题，即A发的数据和B收的数据不一致，这就是没有互斥的弊端。而管道就不会出现这种问题，因为管道数据有原子性</span><br><span class="line"></span><br><span class="line">1. A、B看到的同一份资源——共享资源，如果不加保护，会导致数据不一致问题</span><br><span class="line">2. 加锁 -- 互斥访问 -- 任何时刻只允许一个执行流访问共享资源 -- 互斥 </span><br><span class="line">3. 共享资源，任何时刻只允许一个执行流访问的资源——临界资源 --- 一般是内存空间</span><br><span class="line">4. 如果有100行代码，其中只有5-10行在访问临界资源（访问IPC资源都是代码干的），那么我们访问临界资源的代码叫做临界区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么多进程在显示器上打印的数据又是是错乱的、还会和命令行混在一起？</span><br><span class="line">因为显示器也是被多个进程共享的共享资源，没有互斥保护所以各打各的</span><br></pre></td></tr></table></figure>

<h5 id="3-2-信号量数据结构"><a href="#3-2-信号量数据结构" class="headerlink" title="3.2 信号量数据结构"></a>3.2 信号量数据结构</h5><p>在系统当中也为信号量维护了相关的内核数据结构。</p>
<p>信号量的数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ipc_perm</span> sem_perm;       <span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> sem_otime;      <span class="comment">/* last semop time */</span></span><br><span class="line">	<span class="type">__kernel_time_t</span> sem_ctime;      <span class="comment">/* last change time */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem</span>  *sem_base;      <span class="comment">/* ptr to first semaphore in array */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_queue</span> *sem_pending;      <span class="comment">/* pending operations to be processed */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_queue</span> **sem_pending_last;    <span class="comment">/* last pending operation */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sem_undo</span> *undo;          <span class="comment">/* undo requests on this array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  sem_nsems;      <span class="comment">/* no. of semaphores in array */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量数据结构的第一个成员也是<code>ipc_perm</code>类型的结构体变量，<code>ipc_perm</code>结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span>&#123;</span><br><span class="line">	<span class="type">__kernel_key_t</span>  key;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  uid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  gid;</span><br><span class="line">	<span class="type">__kernel_uid_t</span>  cuid;</span><br><span class="line">	<span class="type">__kernel_gid_t</span>  cgid;</span><br><span class="line">	<span class="type">__kernel_mode_t</span> mode;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>  seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-信号量原理"><a href="#3-3-信号量原理" class="headerlink" title="3.3 信号量原理"></a>3.3 信号量原理</h5><p>以停车场的运作为例，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待。此后来的车也都不得不在入口处等待。当有一辆车离开停车场时，看门人得知后，会打开车拦，放入外面的一辆车进去。这个过程中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用——计数信号量（Counting Semaphore）</p>
<p>如果此时只有一个车位，那么就表示只有一辆车能抢占位置，那么我们只需要一个值为1的计数器——二元信号量（Binary Semaphore）或称为互斥量（Mutex）</p>
<p><strong>将临界资源整合，作为一个整体，此时就是互斥原理</strong></p>
<p><strong>信号量是描述临界资源中资源数量的多少</strong>，我们怕的是多个执行流（车）访问同一个资源（车位），所以引入计数器，当计数器为0时，再有执行流申请资源，就不会同意了</p>
<p><strong>但是信号量计数器也是共享资源！它的目的是保护别人的安全，但是前提是它自己是安全的！</strong></p>
<p>所以<strong>信号量的申请和释放是原子的</strong>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小结：</span><br><span class="line">· 信号量本质是一把计数器，信号量的申请和释放（PV）操作是原子的</span><br><span class="line">· 执行流申请资源，必须先申请信号量资源，得到信号量之后才能访问临界资源</span><br><span class="line">· 信号量值为0或1两态的是二元信号量，对应互斥功能</span><br><span class="line">· 申请信号量的本质就是对临界资源的预定机制，就是对计数器的--，即P操作</span><br><span class="line">· 释放资源，释放信号量，本质是对计数器的++，即V操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">信号量凭什么是进程通信的一种？它又不能进行通信。 </span><br><span class="line">· 通信不仅仅是通信数据，互相协同也算通信</span><br><span class="line">· 要协同本质也是通信，信号量首先要被所有的通信进程看到，即不同的进程看到同一份资源</span><br></pre></td></tr></table></figure>

<p><strong>信号量不能用来通信资源，它是来帮助通信的</strong> </p>
<hr>
<h5 id="3-4-信号量的优缺点"><a href="#3-4-信号量的优缺点" class="headerlink" title="3.4 信号量的优缺点"></a>3.4 信号量的优缺点</h5><ul>
<li><strong>优点</strong>：<ul>
<li>灵活性强：信号量可以用于多种同步场景，如进程同步、资源管理和死锁预防。</li>
<li>可扩展性：信号量可以扩展为计数信号量，用于管理多个同类型资源的并发访问。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>编程复杂度：信号量的使用需要开发者仔细设计同步逻辑，避免出现死锁、优先级反转等问题。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五、mmap系统调用"><a href="#五、mmap系统调用" class="headerlink" title="五、mmap系统调用"></a>五、mmap系统调用</h3><p><strong>mmap（内存映射文件）</strong>函数是Unix和类Unix系统（包括Linux）中用于<strong>创建内存映射文件的一个系统调用</strong>。它<strong>允许程序将文件或其他对象的内容映射到进程的地址空间</strong>，从而<strong>实现文件内容的高效访问</strong>。通过mmap，<strong>进程可以像访问内存一样访问文件内容</strong>，这可以显著提高处理大文件时的性能，因为操作系统可以更有效地管理内存和磁盘之间的数据传输。</p>
<p>mmap（Memory Mapped File）是<strong>将磁盘上的文件加载到内存中，并将其映射到进程的地址空间中</strong>。这种机制<strong>允许进程通过访问内存的方式（通过指针）来直接操作文件内容</strong>，而无需通过传统的系统调用如read和write来进行数据的读写操作。这样做可以显著提高文件I&#x2F;O操作的效率，尤其是在处理大文件或需要频繁访问文件内容的场景下。</p>
<p><strong>功能：</strong></p>
<ol>
<li><strong>内存映射文件</strong><ul>
<li>将<strong>文件的内容映射到进程的地址空间</strong>中，使得文件内容可以<strong>通过指针直接访问</strong>。</li>
<li>这种方式可以提高文件读写效率，因为它<strong>减少了系统调用的开销</strong>。</li>
</ul>
</li>
<li><strong>匿名内存映射</strong><ul>
<li>创建一块<strong>匿名内存区域</strong>，通常<strong>用于分配动态内存</strong>。这块内存不与任何文件关联。</li>
</ul>
</li>
<li><strong>进程间通信</strong><ul>
<li><strong>多个进程可以映射同一个文件或共享内存区域</strong>，从而实现进程间通信。</li>
</ul>
</li>
</ol>
<h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1. 函数原型"></a>1. 函数原型</h4><p>在C语言中，<code>mmap</code>函数的原型定义在<code>&lt;sys/mman.h&gt;</code>头文件中，其基本形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h4><p>void *addr：建议的映射地址。通常设为NULL，让系统自动选择地址。<br>size_t length：要映射的字节数。<br>int prot：映射区域的保护方式，可以是PROT_READ（可读）、PROT_WRITE（可写）或PROT_EXEC（可执行）的位或操作。<br>int flags：映射选项，常用的有MAP_SHARED（共享映射）和MAP_PRIVATE（私有映射）。<br>int fd：文件描述符，表示要映射的文件。<br>off_t offset：文件映射的偏移量，即从文件的哪个位置开始映射。</p>
<h4 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h4><p>成功时，<code>mmap</code>返回指向映射区域的指针。失败时，返回<code>MAP_FAILED</code>（其值通常被定义为<code>(void *)-1</code>），并设置<code>errno</code>以指示错误。</p>
<h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4. 示例"></a>4. 示例</h4><p>以下是一个简单的使用<code>mmap</code>来读取文件的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;example.txt&quot;</span>, O_RDONLY);  </span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error opening file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">stat</span> sb;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fstat</span>(fd, &amp;sb) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error getting file size&quot;</span>);  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> length = sb.st_size;  </span><br><span class="line">    <span class="type">char</span> *map = <span class="built_in">mmap</span>(<span class="number">0</span>, length, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> (map == MAP_FAILED) &#123;  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error mmapping the file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设example.txt是一个文本文件  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Contents of file:\n%s&quot;</span>, map);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">munmap</span>(map, length) == <span class="number">-1</span>) &#123;  </span><br><span class="line">        <span class="built_in">close</span>(fd);  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Error un-mmapping the file&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">close</span>(fd);  </span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h4><ul>
<li>使用完映射区域后，应使用<code>munmap</code>函数来<strong>取消映射</strong>。</li>
<li><strong>映射的文件在进程终止时自动取消映射</strong>，但在进程生命周期内，如果不显式调用<code>munmap</code>或关闭文件描述符，映射会一直保持。</li>
<li><strong>映射的写操作</strong>（当使用<code>MAP_SHARED</code>时）会直接影响磁盘上的文件内容，这可能不是所有应用场景都期望的。</li>
</ul>
<h3 id="四、mmap-的优点"><a href="#四、mmap-的优点" class="headerlink" title="四、mmap 的优点"></a>四、<code>mmap</code> 的优点</h3><ol>
<li><strong>高效性</strong><ul>
<li><code>mmap</code> 提供了高效的文件访问方式，减少了系统调用的开销。</li>
<li>数据直接在内存中操作，无需通过缓冲区复制。</li>
</ul>
</li>
<li><strong>简单性</strong><ul>
<li><code>mmap</code> 提供了简单的接口，使得文件操作类似于内存操作。</li>
</ul>
</li>
<li><strong>灵活性</strong><ul>
<li>支持多种保护权限和映射类型，可以根据需要选择共享或私有映射。</li>
</ul>
</li>
<li><strong>进程间通信</strong><ul>
<li>多个进程可以映射同一个文件或共享内存区域，从而实现进程间通信。</li>
</ul>
</li>
</ol>
<h3 id="五、mmap-的缺点"><a href="#五、mmap-的缺点" class="headerlink" title="五、mmap 的缺点"></a>五、<code>mmap</code> 的缺点</h3><ol>
<li><strong>复杂性</strong><ul>
<li><code>mmap</code> 的使用相对复杂，需要理解内存映射的概念和参数。</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li>需要<strong>手动管理映射区域的取消映射</strong>，否则可能导致内存泄漏。</li>
</ul>
</li>
<li><strong>文件大小限制</strong><ul>
<li><strong>映射区域的大小必须与文件大小一致</strong>，否则可能导致未定义行为</li>
</ul>
</li>
</ol>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>进程间通信</p><p><a href="https://boneskeep.github.io/2025/01/08/进程间通信/">https://boneskeep.github.io/2025/01/08/进程间通信/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>BONESKEEP</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2025-01-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-03-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/01/09/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">通讯协议总结</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2025/01/07/TCPUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="level-item">TCP/UDP网络编程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/head_circle.png" alt="BONESKEEP"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">BONESKEEP</p><p class="is-size-6 is-block">硕士研究生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Lanzhou University of Technology</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">76</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">6</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/BONESKEEP" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/BONESKEEP"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="QQ" href="https://qm.qq.com/q/4kKCYBUmaA"><i class="fab fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Mail" href="mailto:coolhui2020@163.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#进程间通信"><span class="level-left"><span class="level-item">1</span><span class="level-item">进程间通信</span></span></a></li><li><a class="level is-mobile" href="#一、进程间通信介绍"><span class="level-left"><span class="level-item">2</span><span class="level-item">一、进程间通信介绍</span></span></a></li><li><a class="level is-mobile" href="#进程间通信概念"><span class="level-left"><span class="level-item">3</span><span class="level-item">进程间通信概念</span></span></a></li><li><a class="level is-mobile" href="#进程间通信目的"><span class="level-left"><span class="level-item">4</span><span class="level-item">进程间通信目的</span></span></a></li><li><a class="level is-mobile" href="#进程间通信的本质"><span class="level-left"><span class="level-item">5</span><span class="level-item">进程间通信的本质</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-进程间通信发展"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">4. 进程间通信发展</span></span></a></li></ul></li><li><a class="level is-mobile" href="#进程间通信分类"><span class="level-left"><span class="level-item">6</span><span class="level-item">进程间通信分类</span></span></a></li><li><a class="level is-mobile" href="#二、管道"><span class="level-left"><span class="level-item">7</span><span class="level-item">二、管道</span></span></a></li><li><a class="level is-mobile" href="#匿名管道"><span class="level-left"><span class="level-item">8</span><span class="level-item">匿名管道</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-匿名管道原理"><span class="level-left"><span class="level-item">8.1.1</span><span class="level-item">1.1 匿名管道原理</span></span></a></li><li><a class="level is-mobile" href="#1-2-pipe系统调用"><span class="level-left"><span class="level-item">8.1.2</span><span class="level-item">1.2 pipe系统调用</span></span></a></li><li><a class="level is-mobile" href="#1-3-匿名管道的使用"><span class="level-left"><span class="level-item">8.1.3</span><span class="level-item">1.3 匿名管道的使用</span></span></a></li><li><a class="level is-mobile" href="#1-4-管道通信的特征"><span class="level-left"><span class="level-item">8.1.4</span><span class="level-item">1.4 管道通信的特征</span></span></a></li><li><a class="level is-mobile" href="#1-5-管道读写的4种情况"><span class="level-left"><span class="level-item">8.1.5</span><span class="level-item">1.5 管道读写的4种情况</span></span></a></li><li><a class="level is-mobile" href="#1-6-实践操作："><span class="level-left"><span class="level-item">8.1.6</span><span class="level-item">1.6 实践操作：</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#命名管道（FIFO）"><span class="level-left"><span class="level-item">9</span><span class="level-item">命名管道（FIFO）</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-mkfifo"><span class="level-left"><span class="level-item">9.1.1</span><span class="level-item">2.1 mkfifo</span></span></a></li><li><a class="level is-mobile" href="#2-2-unlink"><span class="level-left"><span class="level-item">9.1.2</span><span class="level-item">2.2 unlink</span></span></a></li><li><a class="level is-mobile" href="#2-3-实践通信"><span class="level-left"><span class="level-item">9.1.3</span><span class="level-item">2.3 实践通信</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#命名管道和匿名管道的区别"><span class="level-left"><span class="level-item">10</span><span class="level-item">命名管道和匿名管道的区别</span></span></a></li><li><a class="level is-mobile" href="#四、system-V"><span class="level-left"><span class="level-item">11</span><span class="level-item">四、system V</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-共享内存"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">1. 共享内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-共享内存原理"><span class="level-left"><span class="level-item">11.1.1</span><span class="level-item">1.1 共享内存原理</span></span></a></li><li><a class="level is-mobile" href="#1-2-共享内存数据结构"><span class="level-left"><span class="level-item">11.1.2</span><span class="level-item">1.2 共享内存数据结构</span></span></a></li><li><a class="level is-mobile" href="#1-3-共享内存的建立与释放"><span class="level-left"><span class="level-item">11.1.3</span><span class="level-item">1.3 共享内存的建立与释放</span></span></a></li><li><a class="level is-mobile" href="#1-4-共享内存的创建"><span class="level-left"><span class="level-item">11.1.4</span><span class="level-item">1.4 共享内存的创建</span></span></a></li><li><a class="level is-mobile" href="#1-5-共享内存去关联"><span class="level-left"><span class="level-item">11.1.5</span><span class="level-item">1.5 共享内存去关联</span></span></a></li><li><a class="level is-mobile" href="#1-6-共享内存的释放"><span class="level-left"><span class="level-item">11.1.6</span><span class="level-item">1.6 共享内存的释放</span></span></a></li><li><a class="level is-mobile" href="#1-7-实践通信"><span class="level-left"><span class="level-item">11.1.7</span><span class="level-item">1.7 实践通信</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-System-V消息队列"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">2. System V消息队列</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-消息队列基本原理"><span class="level-left"><span class="level-item">11.2.1</span><span class="level-item">2.1 消息队列基本原理</span></span></a></li><li><a class="level is-mobile" href="#2-2-消息队列数据结构"><span class="level-left"><span class="level-item">11.2.2</span><span class="level-item">2.2 消息队列数据结构</span></span></a></li><li><a class="level is-mobile" href="#2-3-消息队列的创建"><span class="level-left"><span class="level-item">11.2.3</span><span class="level-item">2.3 消息队列的创建</span></span></a></li><li><a class="level is-mobile" href="#2-4-消息队列的释放"><span class="level-left"><span class="level-item">11.2.4</span><span class="level-item">2.4 消息队列的释放</span></span></a></li><li><a class="level is-mobile" href="#2-5-从消息队列获取数据"><span class="level-left"><span class="level-item">11.2.5</span><span class="level-item">2.5 从消息队列获取数据</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-System-V信号量"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">3. System V信号量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-信号量数据结构"><span class="level-left"><span class="level-item">11.3.1</span><span class="level-item">3.2 信号量数据结构</span></span></a></li><li><a class="level is-mobile" href="#3-3-信号量原理"><span class="level-left"><span class="level-item">11.3.2</span><span class="level-item">3.3 信号量原理</span></span></a></li><li><a class="level is-mobile" href="#3-4-信号量的优缺点"><span class="level-left"><span class="level-item">11.3.3</span><span class="level-item">3.4 信号量的优缺点</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、mmap系统调用"><span class="level-left"><span class="level-item">12</span><span class="level-item">五、mmap系统调用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-函数原型"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">1. 函数原型</span></span></a></li><li><a class="level is-mobile" href="#2-参数说明"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">2. 参数说明</span></span></a></li><li><a class="level is-mobile" href="#3-返回值"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">3. 返回值</span></span></a></li><li><a class="level is-mobile" href="#4-示例"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">4. 示例</span></span></a></li><li><a class="level is-mobile" href="#5-注意事项"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">5. 注意事项</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、mmap-的优点"><span class="level-left"><span class="level-item">13</span><span class="level-item">四、mmap 的优点</span></span></a></li><li><a class="level is-mobile" href="#五、mmap-的缺点"><span class="level-left"><span class="level-item">14</span><span class="level-item">五、mmap 的缺点</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com/BONESKEEP" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://boneskeep.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Blog</span></span><span class="level-right"><span class="level-item tag">boneskeep.github.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Game/Games101/"><span class="level-start"><span class="level-item">Games101</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Kunpeng/"><span class="level-start"><span class="level-item">Kunpeng</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Kunpeng/Limb/"><span class="level-start"><span class="level-item">Limb</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">39</span></span></a><ul><li><a class="level is-mobile" href="/categories/Linux/App/"><span class="level-start"><span class="level-item">App</span></span><span class="level-end"><span class="level-item tag">39</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/"><span class="level-start"><span class="level-item">学术</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/3DGS/"><span class="level-start"><span class="level-item">3DGS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/NeRF/"><span class="level-start"><span class="level-item">NeRF</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"><span class="level-start"><span class="level-item">三维重建</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E6%9C%AF/%E5%91%BD%E4%BB%A4/"><span class="level-start"><span class="level-item">命令</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">22</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/Leetcode/"><span class="level-start"><span class="level-item">Leetcode</span></span><span class="level-end"><span class="level-item tag">22</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2025/03/21/2025-3-21-Leetcode-Hot100-No.763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 763. 划分字母区间 贪心 字符串"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-21T11:00:00.000Z">2025-03-21</time></p><p class="title"><a href="/2025/03/21/2025-3-21-Leetcode-Hot100-No.763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/">Leetcode Hot100 763. 划分字母区间 贪心 字符串</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 45. 跳跃游戏 II 贪心算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-20T07:00:00.000Z">2025-03-20</time></p><p class="title"><a href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/">Leetcode Hot100 45. 跳跃游戏 II 贪心算法</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 55. 跳跃游戏 贪心算法"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-20T03:00:00.000Z">2025-03-20</time></p><p class="title"><a href="/2025/03/20/2025-3-20-Leetcode-Hot100-No.55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/">Leetcode Hot100 55. 跳跃游戏 贪心算法</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/19/2025-3-19-Leetcode-Hot100-No.24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 24. 两两交换链表中的节点 递归/迭代"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-19T11:00:00.000Z">2025-03-19</time></p><p class="title"><a href="/2025/03/19/2025-3-19-Leetcode-Hot100-No.24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/">Leetcode Hot100 24. 两两交换链表中的节点 递归/迭代</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2025/03/18/2025-3-18-Leetcode-Hot100-No.19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"><img src="/img/leetcode/Shangri-La%20Frontier-01.jpg" alt="Leetcode Hot100 19. 删除链表的倒数第 N 个结点 栈 双指针"></a></figure><div class="media-content"><p class="date"><time dateTime="2025-03-18T13:00:00.000Z">2025-03-18</time></p><p class="title"><a href="/2025/03/18/2025-3-18-Leetcode-Hot100-No.19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/">Leetcode Hot100 19. 删除链表的倒数第 N 个结点 栈 双指针</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a href="/categories/%E7%AE%97%E6%B3%95/Leetcode/">Leetcode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/03/"><span class="level-start"><span class="level-item">三月 2025</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/02/"><span class="level-start"><span class="level-item">二月 2025</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/12/"><span class="level-start"><span class="level-item">十二月 2024</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">六月 2024</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Games101/"><span class="tag">Games101</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kunpeng/"><span class="tag">Kunpeng</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Leetcode/"><span class="tag">Leetcode</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">39</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E6%9C%AF/"><span class="tag">学术</span><span class="tag">7</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/head_circle.png" alt="BONESKEEP&#039; BLOG" height="28"></a><p class="is-size-7"><span>&copy; 2025 BONESKEEP</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Open Source</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>