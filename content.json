{"posts":[{"title":"Leetcode Hot100 No.11 盛最多水的容器","text":"盛最多水的容器 双指针 2024.12.02 双指针、C++ Problem: 11. 盛最多水的容器 思路 双指针法 问题分析：即求解两条线与x轴围成的矩形的面积最大值问题。 细节： （1）面积S = 长度L * 宽度W （2）长度L = 两条线的x值之差 （3）宽度W = min（两条线的height） 解题过程 暴力解：两个循环，首先让第一个指针指向第一个元素，第二个指针指向下一个元素；外部循环控制第一条线的位置，每轮循环后更新两个指针的地址；内部循环控制第二条线的位置，在内部循环进行S的计算并更新最大值标志，每轮循环后更新第二个指针的地址。 最优解：单个循环，首先让第一个指针指向第一个元素，第二个指针指向第二个元素，在循环内计算S并更新最大值标志，每轮循环后将短线的指针移动（第一个指针右移或第二个指针左移），直到两个指针相遇。 复杂度 时间复杂度: 暴力解O(n) | 最优解O(n^2) 空间复杂度: O(1) Code 123456789101112131415161718192021222324252627282930313233class Solution {public: int cal_S(int L, int W) { // 计算面积S = L * W,并返回S return L * W; } int maxArea(vector&lt;int&gt;&amp; height) { int n = height.size(); if(2 &gt; n || n &gt; 10e5) return -1; int max_S = 0; int tmp_S = 0; int L = 0; int W = 0; vector&lt;int&gt;::iterator iter1 = height.begin(); vector&lt;int&gt;::iterator iter2 = height.end() - 1; while(iter1 != iter2){ L = iter2 - iter1; W = min(*iter2,*iter1); tmp_S = cal_S(L,W); if(tmp_S &gt; max_S) max_S = tmp_S; if(*iter1 &lt; *iter2){ iter1++; }else{ --iter2; } } return max_S; }};","link":"/2024/12/02/2024-12-04-Leetcode-Hot100-No.11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"Leetcode Hot100 No.121 买卖股票的最佳时机 动态规划","text":"买卖股票的最佳时机 动态规划 动态规划、C++ Problem: 121. 买卖股票的最佳时机 思路 双循环遍历 细节： （1）买入价格 &lt; 卖出价格 解题过程 暴力解：很简单，外层循环从开头的元素开始买入，内层循环找符合条件的卖出价格，更新最大利润，不符合条件就从下一个元素开始买入。 复杂度 时间复杂度: 暴力解O(n^2) 空间复杂度: O(1) Code 123456789101112131415161718192021class easySolution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;int&gt;::iterator buy = prices.begin(); vector&lt;int&gt;::iterator sell = buy + 1; int tmp, max_profit = 0; while(buy != prices.end() - 1){ while(*buy &lt; *sell){ tmp = *sell - *buy; if(max_profit &lt; tmp) max_profit = tmp; sell++; if(sell == prices.end()) break; } buy++; sell = buy + 1; } return max_profit; }}; 思路 双循环遍历 细节： （1）买入价格 &lt; 卖出价格 （2）维持两个动态变量 最小买入价格min_price 和 最大利润max_profit 解题过程 最优解：动态规划，动态维护最小买入价格和最大利润，一次遍历。 复杂度 时间复杂度: 最优解O(n) 空间复杂度: O(1) Code 1234567891011121314class perfectSolution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int max_profit = 0; int min_price = 10e9; for(int price: prices){ max_profit = max(max_profit, price - min_price); min_price = min(price, min_price); } return max_profit; }};","link":"/2024/12/04/2024-12-04-Leetcode-Hot100-No.121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"Leetcode Hot100 No.15 三数之和","text":"15.三数之和 问题降维-&gt;双指针 双指针、C++ Problem: 15. 三数之和 思路 （1）通过排序避免重复元素 （2）先确定第一个数，此时寻找第二个和第三个数变为两数之和，看第二个和第三个数之和与第一个数相加是否为0 （3）最终返回的是为存储多个三元组的数组 解题过程 如代码注释所示 复杂度 时间复杂度: 排序O(nlogn) 搜索结果O(n^2) 空间复杂度: O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {public: vector&lt;vector&lt;int&gt;&gt; twoSum(vector&lt;int&gt;&amp; nums, int start, int end, int target){ vector&lt;vector&lt;int&gt;&gt; answer;// 存储两数之和的结果 // 双指针法确定符合条件的两数之和 star为首元素索引 end为尾元素索引 while(start &lt; end){ // 存储两数之和 int sum = nums[start] + nums[end]; // 判断两数之和加目标值（之前确定的第一个数字）是否为0 if(sum + target == 0){ // 如果为0 则将两个数字和目标值加入result数组 vector&lt;int&gt; result; result.push_back(target); result.push_back(nums[start]); result.push_back(nums[end]); // 将结果数组(三元组）加入答案数组 answer.push_back(result); // 在找到两数之后 start和end要同时移动 // 在移动之前 避免重复的值 while(start &lt; end &amp;&amp; nums[start] == nums[start + 1]){ start++;// 遇到重复值 多移动一次 } start++; while(start &lt; end &amp;&amp; nums[end] == nums[end - 1]){ end--; } end--; }else if(sum + target &lt; 0){ // 如果两数之和加目标值小于0 相当于不够大 // 此时start向右移动 nums[start]会增大（递增排序） // 则sum增大 start++; }else{ // 反之end向左移动 nums[end]减小 sum减小 end--; } } return answer; } vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; answer;// 存储三数之和的结果 // 先对数组排序 避免重复元素 sort(nums.begin(), nums.end()); // 单循环确定第一个数字 此时三数之和降级为两数之和 for(int i=0; i&lt;nums.size(); i++){ // 跳过重复的元素 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; // 使用双指针法解决两数之和 // 从i+1开始到size-1结束 当前选择的数字为nums[i] auto result = twoSum(nums,i+1,nums.size()-1,nums[i]); // 将确定的第一个数字和twoSum中找到的第二个和第三个数字加入结果数组 // 在answer.end()开始插入，result.begin()和result.end()按范围插入 answer.insert(answer.end(),result.begin(),result.end()); } return answer; }};","link":"/2024/12/06/2024-12-06-Leetcode-Hot100-No.15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"Leetcode Hot100 No.73 矩阵置零","text":"73.矩阵置零 标记数组 矩阵、标记数组、C++ Problem: 73. 矩阵置零 思路 1.暴力法 定义两个数组：行数组和列数组，用来记录当前行或当前列中是否有0元素，如果有0元素，则将标记数组的行值或列值设为true，然后遍历整个数组，根据标记数组的情况，处理每一行和每一列的值，将其置为0。空间复杂度为m+n。 2.优化法 对于暴力解中的两个标记数组，直接用矩阵的第一行和第一列来代替，但是对于第一行和第一列中是否有0元素，则额外定义两个标记变量来确定，此时会将空间复杂度降为O(1)。 （1）定义两个标记变量 （2）遍历第一行和第一列，看其中是否含有0元素，如果有0，则将标记变量置为true （3）遍历除第一行和第一列之外的矩阵元素，判断当前元素是否为0，如果为0，则将当前元素对应的第一行和第一列的值设为0（根据其他行列元素设置第一行和第一列元素） （4）再次遍历除第一行和第一列之外的矩阵元素，对于当前元素，判断其当前行或列的第一个元素是否为0，如果为0，则表示当前行或列含有0元素，则处理当前元素为0（根据第一行和第一列元素处理其他行列元素） （5）判断两个标记变量，如果标记变量为true，则表示第一行或第一列中有0，则处理第一行或第一列的元素为0（根据两个标记变量处理第一行和第一列的元素） 解题过程 具体看注释 复杂度 时间复杂度: O(mn) 空间复杂度: O(m+n) / O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Solution {public: // 1.记录行和列标记 空间复杂度为O(m+n) void EASYsetZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 给定一个m x n的二维数组 // 思想：循环遍历每行和每列，只要遇到0元素就记录此行或列的坐标，这样最多会记录m+n个坐标，空间复杂度为m+n int m = matrix.size();// 记录行数 int n = matrix[0].size();// 记录列数 // 声明两个数组存储行和列的标记 vector&lt;int&gt; row(m), col(n); // 遍历行和列，遇到0元素就更新标记为true for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(!matrix[i][j]){ row[i] = col[j] = true; } } } // 对每个记录的坐标，把它们的行和列都设为0 for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(row[i] || col[j]){ matrix[i][j] = 0; } } } } // 2.用矩阵的第一行和第一列代替两个标记数组，而第一行和第一列的处理使用两个额外的标记量记录 空间复杂度为O(1) void HARDsetZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 额外使用两个标记变量分别记录第一行和第一列是否原本包含0 int m = matrix.size();// 记录行数 int n = matrix[0].size();// 记录列数 int flag_col0 = false, flag_row0 = false;// 两个标记变量 // 遍历每行，判断每行的第一个元素是否为0，即判断第一列是否含有0 for(int i=0;i&lt;m;i++){ if(!matrix[i][0]){ flag_col0 = true;// 如果有0，则将列标记置为true } } // 判断第一行是否含有0 for(int j=0;j&lt;n;j++){ if(!matrix[0][j]){ flag_row0 = true; } } // 遍历除了第一行和第一列的所有元素 for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ // 判断是否有0 if(!matrix[i][j]){ // 如果有0，则将当前行和列的第一个元素设为0 matrix[i][0] = matrix[0][j] = 0; } } } // 遍历除了第一行和第一列的所有元素 for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ // 判断当前行或列的第一个元素是否为0 if(!matrix[i][0] || !matrix[0][j]){ // 如果为0，则将当前行列坐标设为0 matrix[i][j] = 0; } } } // 判断列标记是否为true if(flag_col0){ // 如果为true，即第一列含有0元素 // 则处理第一列 for(int i=0;i&lt;m;i++){ matrix[i][0] = 0; } } // 判断行标记是否为true if(flag_row0){ // 如果为true，即第一行含有0元素 // 则处理第一行 for(int j=0;j&lt;n;j++){ matrix[0][j] = 0; } } }};","link":"/2024/12/08/2024-12-08-Leetcode-Hot100-No.73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"},{"title":"Leetcode Hot100 No.53 最大子数组和","text":"53.最大子数组和 贪心/动态规划 动态规划、数组、C++ Problem: 53. 最大子数组和 思路 设f(i)是直到第i个数为止的最大子数组和，且f(i)=max(f(i-1)+nums[i], nums[i])，nums[i]为当前数的值，f(i-1)为第i个数之前存储的最大子数组和，动态维护这个f(i)，如果当前数的值更大，则说明前面的子数组不够大，丢弃它，把当前数作为新的子数组；否则，说明子数组够大，继续判断下一个数。 解题过程 如代码注释所示 复杂度 时间复杂度: O(n) 空间复杂度: O(1) Code 1234567891011121314151617class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 存储最大和 初始为第一个数 int maxSum = nums[0]; // 存储前一个子数组的最大和 int pre = 0; for(int i=0;i&lt;nums.size();i++){ // 比较前一个子数组+当前数 与当前数的大小，如果当前数更大，则子数组的头元素更新 // 动态维护了pre pre = max(pre + nums[i], nums[i]); // 更新最大和 maxSum = max(maxSum, pre); } return maxSum; }};","link":"/2024/12/07/2024-12-07-Leetcode-Hot100-No.53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"},{"title":"Leetcode Hot100 No.198 打家劫舍","text":"198.打家劫舍 动态规划+滚动数组 动态规划、滚动数组、C++ Problem: 198.打家劫舍 思路 动态规划+滚动数组 推理递推公式 解题过程 具体看注释 复杂度 时间复杂度: O(n) 空间复杂度: O(1) Code 12345678910111213141516171819202122232425262728293031class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { // 推导递推公式： // Sn = // (1)n=1, H1 // (2)n=2, max(S0,H1) // (3)n&gt;2, max(Sn-1, Sn-2 + Hn) // 其中，Hi表示第i间房的金额，Si表示前i间房屋能获得的最大金额 int n = nums.size(); if(n==0) return 0; // 特殊情况1 if(n==1) return nums[0]; // 定义数组存储中间值 // 将states初始化为n个元素，a并赋初值为0 维护n个值来存储中间变量 // vector&lt;int&gt; states(n,0); // 但其实可以只维护两个值即可 使用滚动数组 int first = nums[0]; int second = max(first, nums[1]); // states[0] = nums[0]; // states[1] = max(states[0], nums[1]); // 对前3间房屋开始循环计算 for(int i=2; i&lt;n; i++){ // states[i] = max(states[i-1], states[i-2] + nums[i]); int temp = second; second = max(second, first + nums[i]); first = temp; } return second;// 返回前n个房屋的最大金额 }};","link":"/2024/12/23/2024-12-23-Leetcode-Hot100-No.198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"Leetcode Hot100 No.56 合并区间","text":"56.合并区间 排序巧解 排序、数组、C++ Problem: 56.合并区间 思路 先按数组的第一列进行排序，所得到有序区间； 使用一个数组merged存储答案， 先把第一个区间加入merged, 再按顺序处理之后的区间，判断当前区间的左端点是否大于merged数组最后一个区间的右端点： 如果大于，则说明区间不重叠，直接将当前区间加入merged数组， 否则，说明区间重叠，返回（当前区间右端点 与 merged数组最后一个区间的右端点）二者中较大值用于更新merged数组最后一个区间的右端点。 解题过程 具体看注释 复杂度 时间复杂度: 排序O(nlogN) 处理区间 O(n) 空间复杂度: O(n) Code 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if(intervals.size()==0) return {}; // 按第一列排序 sort(intervals.begin(),intervals.end()); // 用数组merged存储合并后的数组 vector&lt;vector&lt;int&gt;&gt; merged; // 将第一个区间加入 // merged.push_back(intervals[0]); for(int i=0; i&lt;intervals.size(); ++i){ // 按顺序依次考虑之后的每个区间 int L = intervals[i][0], R = intervals[i][1]; if(!merged.size() || merged.back()[1] &lt; L){ // 如果merged为空 或者 当前区间的左端点大于merged数组中最后一个区间的右端点时 // 将当前区间加入merged merged.push_back({L,R}); }else{ // 否则，说明区间重叠了，返回当前区间的右端点更新数组merged中最后一个区间的右端点，取二者较大值 merged.back()[1] = max(R, merged.back()[1]); } } return merged; }};","link":"/2024/12/14/2024-12-14-Leetcode-Hot100-No.56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"},{"title":"3D Gaussian Splatting 论文笔记","text":"3D Gaussian Splatting 论文笔记 3DGS：来自2023年8月在SIGGRAPH的best paper Title：3D Gaussian Splatting for Real-Time Radiance Field Rendering Paper:https://arxiv.org/pdf/2003.08934.pdf Code:https://github.com/grapgdeco-inria/gaussian-splatting 特点：由椭圆拼接组成的世界 成果:1)1080p(≥30fps)实时渲染 2)现有公开数据集 实时渲染达到sota(State of the Art)(行业顶尖)质量 3)比mipnerf360在相同质量渲染下巨量减少其训练时间 1 SfM初始化稀疏点云 先通过colmap创建出一个初始化点云（一组三维高斯分布） 通过一组照片即可进行估算 保持连续体积辐射场的理想特性，用于场景优化，同时避免了空白空间中不必要的计算 2 3D高斯椭球集的创建 2.1 位置与形状 位置信息：点云位置信息优化(x,y,z) 即高斯椭球的中心点(均值) 形状信息：高斯椭球的协方差矩阵Σ=RSSTRT 其中，R——旋转矩阵 ​ S——缩放矩阵 处理方式的几何意义：先将椭球旋转到与椭球世界平齐，然后沿着轴缩放，再旋转还原回去 上述方式优势：由于Σ不能随机初始化，能保证Σ保持半正定的性质，并且在一定程度上减少运算量 2.2 颜色与不透明度 颜色信息：点云颜色(r,g,b)——用球谐函数(拟合多项式)来表示，使得点云在不同角度呈现不同颜色，有利于提高迭代效率(代码中采用4阶) 不透明度信息：点云不透明度，密度优化α 2.3 傅里叶级数展开与基函数 球谐函数：类似看作一种多项式的拟合 （泰勒展开式） 例如f(x) = ax^3^+bx^2^+cx^1^+dx^0^是三次多项式拟合 有四个参数 将x^3^之类视作为构建多项式函数的基函数 也类似傅里叶级数的展开 分别用sin和cos作为基函数的组合 可以近似拟合不同的周期函数 也可看做将一个周期函数分解开为sin和cos这种基函数 球谐函数：一组能够代表球面上不同位置的值的基函数 阶数越高 表达能力越强 r = f(θ,φ) 球谐函数只和θ（仰角）和φ（方位角）有关，与r（半径）无关 参数量为阶数的平方 让整个球面的数据得到更为连续地表达（可理解为更加光滑 阶数越高 能表达地形状越复杂） 球谐函数用在不同角度的颜色表达 3D高斯中的点云颜色（r,g,b）用球谐函数来表示（每个值一个球谐函数） 使点云在不同角度可以呈现不同颜色 有利于提高迭代效率 代码中用4阶 参数量为n^2^ 球谐函数在一定程度上能弱化高频信息，本质上是一种有损压缩，并能将离散信息转变为连续信息，可计算梯度并进行迭代 2.4 各迭代参数的含义 位置信息：(x,y,z) 高斯的μ 中心点信息 法向量信息：(nx,ny,nz) 不同角度光照呈现的效果 貌似未使用（代码中为0） 颜色信息：代表每个高斯分布的颜色RGB的球鞋（SH）系数（f_dc_0,f_dc_1,f_dc_2）和（f_rest_0到f_rest_44） 不透明度/密度信息：opacity α 缩放矩阵：(scale_0,scale_1,scale_2)，三个方向的缩放轴，即协方差矩阵的参数 旋转矩阵：（rot_0到rot_3），使用旋转四元数（一个实部三个虚部组成）表示 3 计算机图形学投影矩阵 3D高斯协方差（缩放系数）变换是 非线性 的变换 用泰勒一阶展开公式来进行线性的近似 f(x) ≈ f(a) + f’(a)(x - a) f(x) ≈ f(a) + J(x - a) 泰勒公式扩展到三维空间 需要用到雅可比矩阵 于是有 Σ‘=JW Σ W^T^J^T^ 其中雅可比矩阵代表（直接计算得到 不迭代）表示一个多元函数在某一点的局部线性近似 4 渲染公式 和NeRF类似 NeRF： 3DGS也是通过类似point-based的渲染公式： 即通过点云中一定半径范围能影响像素的N个有序点来计算一个像素的颜色C$$C = \\sum_{i∈N}{c_iα_i}\\prod_{j=1}^{i-1}{(1-α_j)}\\其中，c_i代表当前点的颜色值\\\\alpha_i代表当前点i的不透明度（密度）值\\\\alpha_j代表i之前前面点的不透明度（密度）值\\用1-\\alpha_j，进行累乘，作为权重weight\\这代表着前面的点越透明，这个weight就越大，当前\\alpha_i的影响权重越大$$其中：影响范围用标准的球来简化计算，并分tile 16*16，一种快速的排序，CUDA并行加速，光栅化 5 loss定义 损失函数是L1和D-SSIM项：$$L = (1-\\lambda)L_1 + \\lambda L_{D-SSIM}\\\\lambda = 0.2$$ 6 基于梯度自适应改变点云的分布方式 由于刚开始的初始化点云质量不高 所以不能一直依赖 要进行优化 比如每隔个100个epoch会判断点云的分布是否合理 有两个方法： 方法一：Pruning减少伪影的出现 其中不透明度低于设置的阈值或者离相机近的一些点会进行删除 方法二：Densification过渡重构或者欠采样（算loss 基于梯度变化来判断）（高斯椭球和其理想形体差很远） ​ 方差很小（椭球形状小）–&gt;克隆高斯来适应 Under-Reconstruction ​ 方差很大（椭球形状大）–&gt;分割成两个高斯 Over-Reconstruction 7 伪代码 算法1未使用深度学习神经网络，或许可以以此入手找寻一些可以用神经网络优化参数的创新点 算法2为光栅化伪代码","link":"/2024/06/11/3D%20Gaussian%20Splatting%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"title":"Advanced in Neural Rendering 论文笔记","text":"Advanced in Neural Rendering 论文笔记 来源EuroGraphocs 的2022综述论文，2022年3月 ABSTRACT 传统上，场景的合成图像使用 渲染算法 （如光栅化或光线跟踪）生成的； 将特别定义的集合和材质属性表示作为输入。 这些输入定义了实际场景和渲染的内容，称为 场景表示 ，场景由一个或多个目标组成。 示例场景表示是具有伴随纹理的 三角网格（艺术家创建）、点云（来自深度传感器）、体网格（来自CT扫描）或 隐式曲面函数（截断符号距离场）； 使用可微分渲染的损失 从观测中 重建这样的场景表示 被称为 逆图形学或逆渲染。 神经渲染结合了图形学和机器学习的思想，创建了从真实世界观测合成图像的算法； 近年来该领域展示了 可将学习的组件 注入 渲染流水线的不同方法 这篇报告侧重于 将经典渲染原理与学习的3D场景表示（神经场景表示）相结合的方法； 关键优点是在设计上的3D一致性，从而实现了捕获场景的新视点合成等应用； 除了 处理静态场景的方法外，还介绍了用于建模 非刚体变形目标 的神经场景表示以及场景编辑和合成； 这些方法大多时 场景特定的，但也讨论了 跨目标类进行泛化的技术，并可用于生成任务； 回顾这些最先进的方法外 还概述了 使用的基本概念和定义，最后讨论了公开挑战和社会影响。 1. INTRO 传统计算机图形学可以生成高质量的可控图像，但是要基于物理定律并且场景的所有物理参数，比如 摄像机参数、照明和对象的材质都需要作为输入提供； 所以如果想要生成真实场景的可控图像，需要从现有的观测（如图像和视频）中估计这些物理属性，即逆渲染，具有挑战性，尤其是质量达到照片级时的合成图像。 图像合成——需要物理参数——需要进行观测——观测后估计（逆渲染）——达成图像合成目标 挑战性在于逆渲染具有很大的挑战性！ 所以，神经渲染出现，允许场景的紧凑（compact）表示，而且可以通过 神经网络从现有观测中学习渲染。 神经渲染的主要思想是：结合经典（基于物理的）计算机图形学的见解和深度学习的最新进展。 神经渲染的目标：以可控的方式生成照片级真实感图像，例如新视点合成、重照明、场景变形和合成等。 早期的神经绘制方法： 使用神经网络将场景参数转换为输出图像，场景参数也可以直接作为一维输入给定，或者使用经典的图形学流水线生成二维输入。 深度神经网络： 通过对真实世界场景的观察进行训练，并学习对这些场景进行 建模和渲染。 具体来说：一个网络根据输入参数、模型架构和可训练参数定义了一个函数族。使用随机梯度下降，从这空间中找到最能解释由训练损失度量的训练集的函数。 神经绘制的目的是寻找控制参数与对应的输出图像之间的映射。 可以理解为一个复杂且具有挑战性的稀疏数据插值问题。因此，类似于经典的函数拟合，神经绘制需要在欠拟合和过拟合之间进行权衡。如果网络的表征能力不足，那么得到的图像质量就会很低，找到合适的网络架构本身就是一门艺术。在神经渲染的背景下，设计正确的物理驱动的归纳偏差往往需要强大的图形背景。 这方面的一个很好的例子是最近的神经渲染技术 NeRF，该技术试图通过仅学习3D场景表示并依赖计算机图形中的渲染函数进行监督来分离建模和渲染过程。 神经辐射场（NeRF）使用多层感知器（MLP）来近似3D场景的辐射场和密度场。该学习的体表示可以使用解析可微分渲染（即体积分）从任何虚拟摄像头渲染。 对于训练，假设从多个摄像机视点观测场景。从这些训练视点，渲染估计的3D场景，并最小化渲染图像和观察图像之间的差异，根据这些观察结果训练网络。一旦训练完成，由神经网络近似的3D场景可以从新的视点进行渲染，从而实现可控合成。 与使用神经网络学习渲染函数的方法相反，NeRF在该方法中更明确地使用了计算机图形学的知识，由于（物理）归纳偏差，能够更好地概括新视图：场景密度和半径的中间3D结构化表示。因此，NeRF在3D空间中学习物理上有意义的颜色和密度值，物理激发的光线投射和体集成可以持续渲染到新视图中。 所取得的结果质量，以及方法的简单性，导致了该领域的“爆炸式”发展。已经取得了一些进步，提高了适用性，实现了可控性，动态变化场景的捕获以及训练和推理时间。 神经渲染发展非常快，在许多不同的维度上都取得了重大进展，因此对最近的方法及其应用领域进行了分类，以提供发展的简要概述。 2. Scope of This STAR 在本报告中，重点介绍了将经典渲染与可学习3D表示相结合的高级神经渲染方法（见图2）。 先前关于神经渲染的STAR报告主要集中在此范式：2D神经渲染( 2D Neural Rendering )，也称为神经细化、神经重渲染或延迟神经渲染，是基于某个2D信号（例如一个语义标签或者一个栅格化的代理几何）输入 直接映射到输出图像——神经网络被训练用于渲染，例如使用经典的渲染器生成并学习在2D中渲染场景。 本报告聚焦于此范式：3D神经渲染学习在3D中表示一个场景，并使用来自计算机图形学的固定可微的渲染方案。例如NeRF，神经网络是有监督的，以表示特定场景的形状或外观，神经表示用略传统的图形“引擎”来呈现，通过分析定义，并不是被学习的。 通过设计，底层的神经3D表示是3D一致的，并且能够控制不同的场景参数。 在本报告中，全面概述了不同的场景表示，并详细介绍了从经典渲染流水线以及机器学习中借鉴的组件基本原理。进一步关注用神经辐射场以及体渲染的方法。然而，这里忽略主要在2D屏幕空间中推理的神经渲染方法，也不包括光线跟踪图像的神经超采样和去噪方法。 3. Fundamentals of Neural Rendering 神经渲染管道从真实世界的图像中学习渲染和/或表示场景，这些图像可以是无序的图像集，也可以是结构化的多视图图像或视频。 3D神经渲染的一个关键特性是该训练过程中相机捕获过程(即,投影和图像的形成)和3D场景表示的解耦。 这种解耦有许多优点，特别是在图像(例如,对于新颖的视点合成)的合成过程中，可以获得很高的3D一致性。 为了将投影等物理过程从三维场景表示中分离出来，三维神经绘制方法依赖于计算机图形学(例如,栅格化、点散布或体积积分)中已知的图像生成模型。 这些模型受到物理学的启发，特别是发射器的光线与场景以及相机本身的相互作用。这种光传输是使用渲染方程[ Kaj86 ]来描述的。 计算机图形学领域对此渲染方程提供了多种近似。 这些近似依赖于使用的场景表示，范围从经典的栅格化到路径追踪和体积积分。 3D神经渲染利用了这些渲染方法。 下面我们将详细介绍场景表示( 3.1节)以及常用神经绘制方法中使用的渲染方法( 3.2节)。 注意，为了从真实图像中学习，场景表示和渲染方法本身都必须是可微的( 3.3节)。 3.1. 场景表示 几十年来，图形学界探索了各种表征，包括点云、隐式和参数曲面、网格和体积（见图）。 这些表示在 图形学领域有明确定义，但在当前神经渲染的文献中存在混淆，尤其是涉及到 隐式和显式曲面表示和体积表示。 通常，体表示可以表示曲面，反之亦然。 体表示存储 体特征，比如 密度、不透明度或占用率，也可以存储多维特征，如颜色或亮度。 与体表示不同，曲面表示存储目标曲面的特性。 不能用于模拟体物质，如烟雾（除非是粗略近似值）。 对于曲面和体表示，都有连续和离散的对应项（见上图）。 连续表示对于神经渲染方法特别有趣，因为它们可以提供解析梯度。 曲面表示（surface representation）有两种不同的方式——显式和隐式 在欧式空间中有显式曲面函数Sfexplicit的定义（公式3.1 3.2 3.3） 体积表示（volume representation）定义了整个空间的属性（公式3.4） 以上所有表示，各自的功能领域都可以会被限制。具体见3.1。 在神经渲染的背景下，使用神经网络来近似（比如基于MLP的函数逼近器）表面或体积表示函数的场景表示称为神经场景表示。特别的，表面和体积表示都可以扩展以存储额外的信息，如颜色或与视角相关的辐射。 3.1.1. MLPs as Universal Function Approximators 本节讨论了不同的基于MLP的函数逼近器，其构建了最近的神经曲面和体积表示的基础。 3.1.2. Representing Surfaces 本节介绍了不同曲面表示方式，如点云、网格等。 点云(Point Clouds) 点云是欧氏空间的元素集合。一个连续的曲面可以通过点云离散化，点云的每个元素代表曲面上的一个样本点( x , y , z)。对于每个点，可以存储额外的属性，如法线或颜色。 具有法线特征的点云也被称为定向点云。除了简单的点可以看成无穷小的表面面片外，还可以使用半径为(表示位于下垫面切平面上的2D圆盘)的定向点云。这种表象被称为表面元素，别名面元[ PZvBG00 ]。 它们经常被用于计算机图形学中，用于从模拟中渲染点云或粒子。这样的面元的渲染被称为抛雪球，最近的工作表明它是可微的。 使用这种可微的渲染管线，可以直接反向传播到点云位置以及伴随特征(例如,半径或颜色)。 在Neural基于点的图形学和SynSin中，可学习的特征被附加到能够存储关于实际表面的外观和形状的丰富信息的点上。 在ADOP中，这些可学习的特征由一个可以解释视图依赖效应的MLP来解释。值得注意的是，对于离散位置，也可以使用MLP来预测特征，而不是存储特定点的显式特征。 如前所述，点云是欧氏空间的元素集合，因此，除了曲面，它们还可以表示体(例如,存储额外的不透明度或密度值)。对每个点使用一个半径自然会导致一个完整的基于球的公式。 网格(Meshes) 网格。多边形网格表示曲面的分段线性逼近。特别地，三角网格和四边形网格在计算机图形学中被用作表面事实上的标准表示。 优化了图形流水线和图形加速器( GPU )，以每秒处理和光栅化数十亿个三角形。 大多数图形编辑工具使用三角形网格，这使得这种表示对于任何内容创建管道都很重要。为了与这些管线直接兼容，许多”经典”的逆向图形和神经绘制方法都使用了这种基本的曲面表示。 使用可微的渲染器，可以优化顶点位置和顶点属性(例如,颜色)，以再现一幅图像。 神经网络可以被训练来预测顶点的位置，例如，预测动态变化的曲面。而不是使用顶点属性，在三角形内存储表面属性的常用策略是纹理贴图。 2D纹理坐标是贴在网格顶点上的，它参考了纹理图像中的一个位置。利用重心插值，可以计算三角形内任意一点的纹理坐标，并利用双线性插值从纹理中检索属性。纹理的概念也被集成到了标准的图形流水线中，增加了一些额外的功能，如分级细化，它需要妥善处理纹理( c.f. ,采样定理)的采样。 延迟神经绘制( Deferred Neural Rendering )使用包含可学习的视点相关特征的纹理，即所谓的神经纹理。具体来说，一个粗网格被用作底层的3D表示，以光栅化这些神经纹理。神经网络在图像空间中解释这些光栅化的特征。注意到该网络可以是一个像素级的MLP，那么神经纹理就代表了表面辐亮度。 相对于使用离散纹理，可以使用连续纹理。纹理场的作者提出使用MLP来预测每个表面点的颜色值。在神经反射场纹理( NeRF-Tex ) 中，将NeRF的思想与使用2D神经纹理和底层3D网格的思想相结合。NeRF - Tex是基于用户定义的参数来控制外观，因此可以被艺术家编辑。 隐式曲面(Implicit Surfaces) 隐式曲面。隐式曲面将曲面定义为函数的零水平集，见公式3 。最常用的隐式曲面表示方法是符号距离函数( SDF )。这些SDF表示被用于许多使用体积融合增量重建静态或动态物体表面的3D扫描技术中。隐式曲面表示提供了许多优点，因为它们避免了定义网格模板的要求，因此能够在动态场景中表示拓扑未知或拓扑变化的物体。 上述体积融合方法使用离散(截断)的符号距离函数，即使用包含符号距离值的3D网格。Hoppe等人提出了分段线性函数来对输入曲面点样本的符号距离函数进行建模。Carr等人的开创性工作使用径向基函数网络代替。这个径向基函数网络代表了一个连续的隐式曲面函数，可以看作是第一个”神经”隐式曲面表示。 最近的神经隐式曲面表示是基于坐标的多层感知器( MLPs )，见3.1.1节。这种表示方法在神经场景的表示和渲染中得到了广泛应用。它们在[ PFS⋅19 , CZ19]中同时被提出用于形状建模，其中MLP架构用于将连续坐标映射到符号距离值。这种坐标网络表示的信号的保真度，或者说神经隐式表示，主要受限于网络的容量。因此，与上述其他表示法相比，隐式曲面在记忆效率方面具有潜在的优势，并且作为一种连续表示法，理论上可以表示无限分辨率的几何图形。 最初的建议接踵而至，产生了广泛的热情，随后有了各种针对不同侧重点的改进，包括训练方案、利用全局-局部上下文、采用特定参数化或空间分区。（创新点） 由于不需要预先定义网格模板或对象拓扑结构，神经隐式曲面非常适合对不同拓扑结构的对象进行建模。 利用反向传播可以计算输出相对于输入坐标的解析梯度。这使得除了其他几何激励的正则化器外，在梯度上实现正则化项成为可能。 这些表示可以扩展到对场景的辐亮度进行编码。这对于神经渲染是有用的，在这里我们希望场景表示能够同时编码场景的几何和外观。 3.1.3. Representing Volumes 本节介绍了不同体积表示方式，如体素网格、神经体积表示等。 体素网格( Voxel Grids ) 体素网格( Voxel Grids )。作为R^3^中的像素等价体，体素通常被用来表示体积。 它们可以存储几何占有率，或者存储具有体积效应(如透明度)的场景的密度值。 此外，场景的外观可以存储。 使用三线性插值，这些体属性可以在体素网格内的任意点访问。这种插值方法特别适用于光线投射等基于样本的绘制方法。 在存储的属性可以具有特定的语义(例如,占有率)的同时，属性也可以被学习。 西茨曼等人提出使用DeepVoxels，将特征存储在体素网格中。光线投射渲染程序后的特征的积累和解释是使用深度神经网络完成的。这些DeepVoxels可以看作是体积神经纹理，可以直接使用反向传播进行优化。 虽然基于稠密体素的表示可以快速查询，但它们的内存效率很低，并且3D CNNs可能在这些体上运行，计算量很大。 八叉树数据结构（用于描述空间的树状数据结构）可以用稀疏的方式来表示体积。八叉树上的稀疏3D卷积可以帮助缓解一些问题，但这些紧凑的数据结构不能轻易地在工作中更新。因此，它们很难融入到学习框架中。 其他减轻密集体素网格内存挑战的方法包括使用对象特定形状模板，多平面或多球体图像，它们都旨在使用稀疏近似来表示体素网格。 神经体积表征(Neural Volumetric Representations) 神经体积表征(Neural Volumetric Representations)。特征或其他感兴趣的量也可以使用神经网络来定义，类似于神经隐式曲面(见3.1.2节)。MLP网络体系结构可以用于参数化体积，与显式体素网格相比，MLP网络体系结构具有更高的存储效率。 这些表示可能仍然成本巨大，需要根据基础网络的大小进行采样，因为对于每个样本，必须计算通过网络的整个前馈。大多数方法可以粗略地分类为使用全局或局部网络。 同时使用网格和神经网络的混合表示在计算效率和内存效率之间做出了权衡。 与神经隐式曲面类似，神经体积表示允许计算解析梯度，这已被用于定义正则化项。 BACON引入了基于带限坐标的网络，学习了表面的光滑多尺度分解。 总的注释(General remark) 总的注释(General remark)： 使用基于坐标的神经网络对场景进行体积建模(如NeRF)，表面上类似于使用坐标网络对表面进行隐式建模(如在神经隐式曲面中)。 然而，类NeRF的体表示并不一定是隐式的——因为网络的输出是密度和颜色，场景的几何结构是由网络显式地，而不是隐式地参数化的。 尽管如此，这些模型在文献中仍然被称为”隐式”是很常见的，这可能是由于场景的几何形状是由神经网络（SDF文献中使用了一个不同的”隐式”定义）的**权重”隐式”**定义的。 同时注意到，这是一个与深度学习和统计社区通常使用的”隐式”不同的定义，其中**”隐式”通常是指模型的输出被隐式地定义为动态系统的固定点，其梯度使用隐函数定理计算**。 3.2. 可微图像的生成 Differentiable Image Formation 前面几节中的场景表示允许我们表示场景的3D几何和外观。 下一步，我们将描述如何通过渲染从这些场景表示中生成图像。 将三维场景渲染成二维图像平面的一般方法有两种：光线投射和栅格化，见图4。 也可以通过定义场景中的相机来计算场景的渲染图像。 大多数方法使用针孔相机，其中所有相机**光线都通过空间中的单点(焦点)**。 对于给定的相机，可以将来自相机原点的光线投射到场景中，以便计算渲染图像。 (a) 正向渲染(例如,光栅化)——通过 将三维表示投影到图像平面上 生成图像。 (b) 光线投射( Ray Casting )——通过投射观看光线，采样3D表示并累加生成图像。 上图描述： 对于显式曲面表示，曲面是直接可索引的。这使得我们可以使用前向渲染方法，将表面投影到图像平面，并相应地设置一个像素(例如,使用栅格化或点散布)。隐式表面表示和体积表示，不提供允许前向渲染的表面的直接信息，相反，从虚拟相机看到的3D空间必须采样以生成图像(例如,使用光线行进法)。 光线投射。在针孔模型中，基本截距定理可以用来描述一个点p∈R^3^在三维中如何被投影到图像平面中的正确位置q∈R^2^。 它被定义为一个非内射函数，并且很难求逆，这使得它在三维重建问题中处于核心地位。 Pinhole模型对该投影具有单一参数矩阵：本征矩阵K包含经像素尺寸归一化的焦距f = [αx , αy]，轴偏斜度γ和中心点c = [cx , cy]。利用截距定理并假设齐次坐标p′= [ x , y , z , 1]，我们发现投影坐标为q′= K · p′，有 这假设投影的中心在坐标原点，并且相机是轴对齐的。为了推广到任意相机位置，可以使用一个外部矩阵R。这个均匀的4 × 4矩阵E是由 其中R是旋转矩阵，t是平移向量，使得R · pw + t = pc，这里我们用pw表示世界坐标中的点，pc表示相机坐标中的点。R和t的这种定义在计算机视觉(例如, OpenCV使用的)中很常见，被称为”世界到世界”映射，而在计算机图形学(例如,在OpenGL中)中，类似的逆”凸轮到世界”映射更普遍。假设” worldto-cam “约定，利用齐次坐标，我们可以写出pw到qp的全投影为： 如果使用’ cam-to-world ‘约定，光线投射也同样方便。由于深度模糊，这些方程是非单射的，但它们非常适合于自动微分，并且可以在图像形成模型中进行端到端的优化。 为了正确地对当前的相机进行建模，还必须考虑另外一个部件：镜头。 抛开在图像形成过程中必须建模的景深或运动模糊等影响，它们会给投影函数添加失真影响。不幸的是，没有一个单一的、简单的模型来捕获所有不同的镜头效果。 标定包，如OpenCV中的标定包，通常实现最多12个畸变参数的模型。它们是通过五次多项式建模的，因此不是平凡可逆的(这是光线投射相对于点投影所需要的)。 更现代的摄像机标定方法使用了更多的参数，并达到了更高的精度，并且可以实现可逆和可微。 光栅化/栅格化 Rasterization 光栅化。光线投射的一种替代方法是将几何图元栅格化。 该技术并不试图模仿真实世界的图像形成过程，而是利用物体的几何特性来快速生成图像。 它主要用于网格，由顶点v和面f的集合描述，连接顶点的三元组或四元组来定义曲面。 一个基本的见解是，3D中的几何操作可以单独处理顶点：例如，我们可以使用相同的外部矩阵E将世界中的每个点变换到相机坐标系中。 经过这种变换后，可以剔除视锥体之外的点或法线方向错误的点，以减少下一步需要处理的点和面的数量。 通过使用如上所述的内蕴矩阵K，可以再次平凡地找到投影到图像坐标的其余点的位置。 利用人脸信息可以对人脸图元进行深度插值，最上层的人脸可以存储在一个零缓冲器中。 这种实现投影的方式往往比光线投射更快：它主要根据场景中可见顶点的数量进行缩放，而光线投射则根据像素的数量和要与之相交的图元的数量进行缩放。然而，使用(例如,光影、阴影、反射等)来捕获某些效应是比较困难的。它可以通过”软”栅格化使其具有可微性。例如，在[ LLCL19 , RRN⋅20]中已经实现。 3.2.1. 曲面渲染 Surface Rendering 点云渲染 Point Cloud Rendering 点云渲染。点云是连续曲面或体积的离散样本。 点云渲染对应于从不规则分布的离散样本中重建连续信号，例如连续表面的出现，然后在每个像素位置的图像空间中重采样重建信号。 这个过程可以通过两种不同的方式来完成： 第一种方法基于经典信号处理理论，可以看作是一个”软”点抛雪球（Splatting 喷溅）(类似于下面网格渲染部分中的软光栅化器)。它首先利用连续的局部重构核r ( · )构造连续信号，即f =∑f i ( pi )。 本质上，这种方法相当于将离散样本与一些局部确定性模糊核混合，例如EWA抛雪球，它是一种空间变化的重构核，旨在最小化混叠。在神经绘制中，离散样本可以存储一些可学习的特征。相应地，前述步骤有效地将个体特征投影并融合到2D特征图中。 如果特征具有预定义的语义(例如,颜色,法线)，可以使用固定的着色函数或BRDF来生成最终的图像。 如果特征是学习到的神经描述符，则部署2D神经网络将2D特征图转换为RGB图像。 最近采用这种方法的神经点绘制方法包括Sin Syn和Pulsar。为了性能的原因，他们在混合步骤中使用空间不变和各向同性的核。虽然这些简化的内核会导致渲染伪影，如空洞，模糊边缘和锯齿，但这些伪影可以在神经着色步骤中得到补偿，并且在Pulsar的情况下，可以通过优化半径来实现。[ KPLD21 ]还使用了相机选择和概率深度测试的策略，并能够在该框架中处理IBR、风格化和协调。 除了软点绘制方法外，还可以使用传统的OpenGL或directx技术的点渲染器。在这里，每个点被投影到单个像素(或小面积的像素)，从而得到一个稀疏的特征图。可以使用深度神经网络直接在图像空间中重构信号。注意，这种朴素的渲染方法不提供关于点位置p的梯度，只允许区分渲染函数w . r . t . (神经)特征。相比之下，软点散布方法通过重构核r ( p )提供点位置梯度。 然而，即使在这种情况下，梯度在空间上也被限制在局部重建的支持范围内。[ YSW※19b ]通过使用有限差分来近似梯度来解决这个问题，并成功地将渲染器应用于表面去噪、风格化和多视图形状重建。这一思想在文献[ RFS21b ]中被采用，以联合优化几何和相机姿态来进行新的视图合成。 网格渲染 Mesh Rendering 有许多通用的渲染器允许网格被栅格化或以可微的方式渲染。在可微网格栅格化中，Loper和Black开发了一个可微的渲染框架，称为OpenDR，它近似一个主要的渲染器，并通过自动微分来计算梯度。 神经网格渲染器( NMR ) 使用可见度变化的手工函数来近似光栅化操作的向后梯度。 文献[ LTJ18 ]提出了无固定职业的摄影师，一种利用图像滤波器进行网格几何处理的解析可微渲染器。彼得森等人[ PBDCO19 ]提出了Pix2Vex，一种通过邻近三角形的软混合方案的C∞可微渲染器，[ LLCL19 ]提出了Soft光栅化程序，它渲染和聚合网格三角形的概率映射，允许梯度从渲染的像素流向被遮挡的和远程的顶点。虽然大多数栅格化器只支持基于直接光照的渲染，但[ LHL⋅21 ]也支持软阴影的可微渲染。在基于物理的绘制领域，[ LADL18a ]和[ ALKN19 ]引入了可微分的光线示踪器，实现了基于物理的绘制效果的可微分性，处理了相机位置、光照和纹理。此外，Mitsuba 2 [ NDVZJ19 ]和Taichi [ HLA * 19 , HAL * 20]是通用的基于物理的渲染器，通过自动区分支持可微的网格渲染，以及其他许多图形技术。 神经隐式曲面渲染 Neural Implicit Surface Rendering 当输入观测为2D图像时，实现隐式曲面的网络不仅产生几何相关的量，即符号距离值，而且产生外观相关的量。 一个隐式可微渲染器可以通过首先使用神经隐式函数的几何分支找到一条观察光线与曲面的交点，然后从外观分支获得该点的RGB值来实现。曲面求交的搜索通常是基于球面追踪算法[ Har96 ]的一些变体。 球面跟踪在视线方向上从相机中心对三维空间进行迭代采样，直到到达表面。球面追踪是一种优化的射线追踪方法，通过前一位置采样的SDF值来调整步长，但这种迭代策略仍然会带来计算上的开销。泷川等人[ TLY※21 ]通过将光线跟踪算法与稀疏八叉树数据结构相适应，提高了渲染性能。 在二维监督的联合几何和外观估计的隐式曲面渲染中，一个常见的问题是几何和外观的模糊性。在[ NMOG20 , YKM * 20 , KJJ * 21 , BKW21]中，从2D图像中提取前景掩码，为几何分支提供额外的监督信号。最近，[ OPG21 ]和[ YGKL21b ]通过将表面函数转化为体渲染公式(下面介绍)来解决这个问题；另一方面[ ZYQ21 ]利用现成的深度估计方法生成伪地面真值符号距离值来辅助几何分支的训练。 3.2.2 体积渲染 Volumetric Rendering 体积渲染是基于光线投射的，并且已经被证明在神经渲染，特别是在从多视图输入数据中学习场景表示方面是有效的。具体来说，这个场景表示为体积密度或占有率的连续场，而不是硬表面的集合。 这意味着光线在空间中的每一点都有一定的概率与场景内容发生交互，而不是二进制的相交事件。 这种连续模型可以很好地作为机器学习管道的可微渲染框架，这些机器学习管道严重依赖良好行为梯度的存在进行优化。 虽然完全通用的体积渲染确实考虑了光线可以从一个体粒子反射出去的”散射”事件，但我们将这一总结限制在用于视图合成的神经体积渲染方法常用的基本模型中，它只考虑了光线被一个体粒子发射或阻挡的”发射”和”吸收”事件。 给定一组像素坐标，我们可以使用先前描述的相机模型计算通过原点p和方向ωo的3D空间的相应光线。沿着这条射线的入射光可以用一个简单的发射/吸收模型定义为 其中σ为点的体积密度，Le为点和方向的出射光，透射率T为嵌套积分表达式 密度表示光线在特定点与场景的体积”介质”相互作用的微分概率，而透射率描述了光线从点p + tωo回到相机时被衰减的程度。 这些表达式只能针对简单的密度场和色场进行解析计算。在实际应用中，我们通常用求积来近似积分，其中σ和Le被假设为在N个区间{ [ ti - 1，ti ) } ^N^i=1内的分段常数，该区间划分了射线的长度： 对于这个近似的完整推导，我们参考Max和Chen 。注意，当写成这种形式时，逼近L的表达式恰好对应于由后向前合成颜色L^(i)^e的alpha。 NeRF和相关方法使用可微体积渲染将场景表示投影到2D图像中。这使得这些方法可以在”逆向渲染”框架中使用，其中三维或更高维的场景表示是从2D图像中估计出来的。体绘制需要沿一条射线处理多个样本，每个样本都需要通过网络进行完整的前向传递。 最近的工作提出了增强数据结构、重要性采样、快速集成等策略来加快渲染速度，尽管这些方法的训练时间仍然较慢。自适应坐标网络使用多分辨率网络结构加速训练，在训练阶段通过以最优和有效的方式分配可用的网络容量来优化网络结构。 3.3. 优化 Optimization 训练神经网络的核心是非线性优化，其目的是应用训练集的约束，以获得一组神经网络权值。 因此，由神经网络逼近的函数能够拟合给定的训练数据。通常，神经网络的优化是基于梯度的；更具体地说，使用了SGD的变体，如Momentum或Adam，其中梯度是通过反向传播算法获得的。 在神经渲染的背景下，神经网络实现了3D场景表示，训练数据由场景的2D观测值组成。使用神经场景表示的可微渲染得到的渲染结果与使用给定的观察进行了比较。 这些重建损失可以用每个像素的L1或L2项来实现，也可以使用基于感知的甚至基于判别器的损失公式。然而，关键是这些损失直接与各自的可微渲染公式耦合，以更新场景表示，见3.1节。","link":"/2024/06/11/Advanced%20in%20Neural%20Rendering%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"title":"Linux命令","text":"设置GPU可见命令 加在运行命令之前 CUDA_VISIBLE_DEVICES = [GPU编号] nvidia-smiwatch -n 0.1 nvidia-smi WIFI 使用nmcli查看可用的WiFi网络：nmcli dev wifi list 选择一个网络，并使用以下命令连接：nmcli –ask dev wifi connect password 您想要创建一个新的WiFi连接配置，可以使用以下命令：nmcli con add type wifi ifname con-name nmcli con modify wifi.ssid nmcli con modify wifi.security nonenmcli con modify wifi.mode managednmcli con modify wifi.hidden falsenmcli con modify wifi.password nmcli con up 将替换为您的无线网络接口名称，为您的连接名称，为网络的名称，为网络的密码。","link":"/2024/10/07/CUDA%E5%91%BD%E4%BB%A4/"},{"title":"Git命令","text":"branch分支相关git branch 显示本地分支git branch -a 显示所有分支 git checkout 切换分支，将替换为你的分支名","link":"/2024/09/29/Git%E5%91%BD%E4%BB%A4/"},{"title":"Leetcode 算法解析","text":"难度：Easy = E | Middle = M E 1.两数之和 2024.3.26 方法一：暴力枚举 两个循环搞定 注意用malloc先分配好空间 int* ret = malloc(sizeof(int)*2); 时间O(N^2^) 空间O(1) ！！！方法二：哈希表 用于方法一的时间复杂度过高——寻找匹配元素 创建一个哈希表，对于每一个x，先查询表中是否存在target-x，再将x插入到表中，保证不会让x与自己匹配 E 9.回文数 2024.3.27 方法一：将数字划分为各个单个数进行循环判断； 常规解法：1.先将数字划分为单个数存入数组，while循环加静态数组；2.循环进行判断，注意循环次数；3.可使用动态数组以防止overflow。 方法二：将其转换为字符串数组，直接进行数组元素的相等判断。循环次数到n/2即可。 E 13.罗马数字转整数 2024.3.29 方法一：字符串的转化 找规律 建立转化表 再进行数字判断并累加 出现了问题“如何建立一个转换表” “switch函数的参数是否能输入多字符结构（字符串）” E 14.最长公共前缀 2024.3.30 指针与字符串——文言一心 指针的定义与类型 char* 是一个指向字符的指针。 char** 或 char* * 是一个指向字符指针的指针，通常用于存储字符串数组。 数组与指针 ： 当有一个字符串数组（如 char* strs[]），strs 是一个指向该数组第一个元素的指针，即 strs 的类型是 char**。 strs[i] 表示数组中的第 i 个字符串，它的类型是 char*。 解引用指针 ： 使用 * 运算符可以解引用指针，获取指针所指向的值。例如，*strs[0] 获取 strs 数组中第一个字符串的第一个字符。 printf 函数与格式说明符 ： %s：用于输出以空字符结尾的字符串。 %d：用于输出整数。 %c：用于输出单个字符。 %p：用于输出指针的地址，通常需要将指针转换为 void* 类型。 字符串与地址的输出 ： 直接使用 printf(&quot;%s\\n&quot;, strs[i]) 可以输出 strs 数组中第 i 个字符串的内容。 使用 printf(&quot;%p\\n&quot;, (void*)strs[i]) 可以输出 strs 数组中第 i 个字符串的地址（即指针的值）。 指针与整数的区别 ： 指针存储的是内存地址，而整数存储的是数值。 错误的格式说明符可能导致输出无意义的结果或未定义的行为。 方法一：横向扫描 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串（对比其各个字符是否相等），更新最长公共前缀，当遍历完所有字符串后，即可得到最长公共前缀。 对比其各个字符是否相等——strs[i][j]==prefix[j] prefix为存储当前最长公共前缀的字符串 如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。 if(prefixLength == 0) 方法二：纵向扫描 纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。 具体思路：把第一个字符先拿出来（循环1），然后依次用用数值的相应字符与其比较（strs[0][i] != strs[j][i]）（循环2），然后判断是否相同，如果有一个字符不同则将这个字符赋’\\0’，然后将新的数组赋给strs[0]，然后return 新的strs[0]; **注意：此方法会更改strs[0]原本的值 如果此变量之后还具有价值的话 会导致值被更改 ** 最好的方法是动态分配一块内存用于存储公共前缀的值，记得在返回后free掉， 除此之外，如果不想使用动态分配的话，可以再传入函数参数时，多传入一个具有足够大空间的静态缓冲区， 因为在函数内部定义的缓冲区是局部变量，会在结束后被释放，所以不能用于返回，返回会为一个null E 20.有效的括号 栈 2024.3.31 括号的正确匹配问题 用到了数据结构——栈 使用栈来跟踪尚未匹配的打开括号 遍历输入字符串：对于字符串中的每个字符，我们检查它是打开括号还是闭合括号。 处理打开括号：如果遇到打开括号（如(、[、{），我们将其压入栈中，表示这个括号尚未找到匹配的闭合括号。 处理闭合括号：如果遇到闭合括号（如)、]、}），我们检查栈顶的元素是否是与之匹配的打开括号。如果是，则从栈中弹出该元素，表示找到了匹配的括号对；如果不是或栈为空，则说明括号无效。 检查栈是否为空：在遍历完整个字符串后，如果栈为空，说明所有的打开括号都找到了匹配的闭合括号，因此括号组合是有效的；如果栈不为空，则说明还有未匹配的打开括号，括号组合无效。 这种算法思想利用了栈的后进先出（LIFO）特性，非常适合处理这种需要匹配成对出现元素的问题。在遍历字符串的过程中，我们只需要维护一个栈，就可以高效地判断括号是否有效。 注意栈的定义与初始化 char* stack = (char*)malloc(strlen(s) * sizeof(char)); 其中因为malloc函数的返回值为void*类型 所以要进行类型转换 int top = -1；这是栈顶指针 初始化为-1 表示栈空 元素入栈时，stack[++top] = s[i]；栈顶指针要自增 再压入栈中 元素出栈时，pop = stack[top–]; 出栈时要先取值再自减 不然取到的值是栈顶第二个元素 E 21.合并两个有序链表 2024.3.29 方法一：双指针遍历 创建一个新链表进行存储合并后的链表 创建链表结点的问题 如果此结点需要存储信息，则要malloc分配空间 如果此结点/指针仅仅用来遍历，则不需要分配空间 注意断链问题 可能需要一个指针防止断链 防止内存泄漏问题 动态分配内存malloc后记得free掉 E 26.删除有序数组中的重复项 2024.4.1 不能使用临时数组存储不需要考虑其他元素 只考虑返回唯一的元素需要记录元素覆盖的位置 思想：定义一个变量pos初始化为1，即时更新 表示当前插入的数组位置，最后可以当作nums的唯一元素数量返回 E 27.移除元素 2024.4.2 原地删除 给一串数字，用两个循环遍历，第一个循环找出对应值的元素，第二个循环从对应值开始向后遍历，找不等于对应值的元素，找到后赋值到第一个循环找到的位置，然后直接退出第二个循环，再如此进入第一个循环继续遍历。 E 28.找出字符串中第一个匹配项的下标 2024.4.3 给了两个字符串，在第一个字符串中找到第二个字符串的第一个匹配项的下标，未匹配到就返回-1。 思想：用双循环，第一个循环遍历第一个字符串，每次从一个字符开始，用第二个循环和第二个字符串匹配，如果不匹配就从第一个字符串的下一个字符开始继续匹配，直到第一个字符串全部遍历结束。 E 35.搜索插入位置 二分查找 2024.4.4 规定了时间复杂度 用二分查找 规定中间值与目标值进行对比，不等时从两侧查找，当前后两个位置值顺序反转或相等时退出循环 要注意整数溢出问题 C或C++中，整数值过大时直接相加会导致整数溢出，此时可以用如下方法： first + (last - first) / 2 等价于 (first + last) / 2 E 70.爬楼梯 动态规划 2024.3.25 方法一：每次爬1或2层 找规律可得递推公式 递归解决 方法二 C++：为了节省时间 记忆化递归 用memo数组记录计算结果 如果已经计算过就直接返回memo中的结果 保证每个结点只计算一次 方法三：动态规划算法 记录n个状态，从1到n依次更新 只记录其中用到的两个状态 可以优化时间复杂度到O(1) 方法四：滚动数组 每次状态更新后 把状态2移到状态1的位置 状态3移到状态2的位置 状态整体向前滚动一位 E 94.二叉树的中序遍历 2024.4.19 递归 由于是左中右的遍历顺序 所以遍历当前节点前要先遍历左子树 遍历当前节点后遍历右子树 迭代 二叉树中序遍历的迭代法，相比较递归法就是显式地维护了一个栈 用数组保存中序遍历 用栈来遍历节点 当根结点不为空且栈不空时 说明树没遍历完 进入循环遍历 用循环将当前节点和所有左子节点压入栈中 全部压入栈中后，再取栈顶元素，出栈，加入结果数组，然后遍历当前结点的右子树 最后返回结果数组 E 104.二叉树的最大深度 2024.4.22 深度优先搜索 递归 当前树的深度 = max（左子树深度 + 右子树深度） + 1 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。 广度优先搜索 迭代 队列 按层数进行节点的遍历，定义一个队列用来存储当前层的节点，遍历节点时，注意其左右孩子节点，如果存在就入队，再进行队列中下一个节点的遍历和操作，每遍历完一层结点（一次循环），记录（h++），最后的遍历层数就是最大深度。 时间复杂度：O(n)。 空间复杂度：O(n)，最大要遍历所有元素n个。 E 118.杨辉三角 2024.4.11 迭代/递归 迭代 先定义一个二维数组，初始化第一第二行，从第三行开始循环算：一行一行初始化一个辅助vector存储当前行的元素，用一个循环计算中间元素，最后将当前行的元素push_back进二位数组中 递归 先确定边界条件0和1，在递归调用生成前numRows-1行，此时会只剩当前行没生成，和迭代相同，创建当前行，使用一个辅助数组存储当前行元素，初始化第一和最后一个元素为1，在计算中间元素，最后将当前行加入整个二维数组中 back()的问题 vec.back()用来返回最后一个元素 vec2D.back()[i] 用来返回一个二维数组的最后一行的第i个元素 E 136.只出现一次的数字 2024.4.10 需要使用异或运算 异或运算的性质： 任何数和0做异或运算，结果仍然是原来的数，即 a ^ 0 = a。 任何数和其自身做异或运算，结果是0，即 a ^ a = 0。 异或运算满足交换律和结合律，即 a ^ b ^ a = b ^ (a ^ a) = b ^ 0 = b。 除了一个元素只出现一次以外，其余每个元素都出现两次。 那么，如果我们对数组中的所有元素进行异或操作，那些出现两次的元素会两两抵消（因为 a ^ a = 0），最后剩下的就是只出现一次的元素。 E 141.环形链表 2024.4.13 判断环 快慢指针判断环 E 160.相交链表 双指针 2024.4.6 方法一：双指针 1.写一个求链表元素的函数2.双指针遍历 比较指针(比较指针所指的值时可能会重复 指针是唯一的)3.遍历前操作：先让链表更长的指针先走 时间复杂度:O*(m+n) 空间复杂度:O*(1) 方法二：循环遍历 用指针实现循环链表 两个指针走了相同距离必定相遇 12345678910111213struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { //定义指针p,q,当两个指针走了相同距离必定相遇 struct ListNode *p = headA; struct ListNode *q = headB; while(p != q) { p = p ? p-&gt;next : headB; q = q ? q-&gt;next : headA; } return p;} 方法三：哈希集合 E 169.多数元素 跟踪者/计数器 摩尔投票算法（Boyer–Moore Voting Algorithm） 这个算法的基本思想是在遍历数组时，用一个变量 count 来记录当前候选众数的出现次数，用另一个变量 candidate 来记录当前的候选众数。如果当前元素与candidate相等，则count++；否则count–。count==0时，更新此时candidate= 当前元素。 这样做由于是多数元素，最终的count一定会是正数，而多数元素就是此时candidate记录的元素。 E 206.反转链表 2024.4.7 逐个翻转结点法 初始化两个指针，一个指向当前节点（prev），另一个指向下一个节点（curr）。 将prev初始化为NULL，curr初始化为head。 遍历链表，每次迭代将curr的next指针指向prev，然后移动prev和curr到下一个位置。 当curr为NULL时，遍历结束，此时prev就是反转后的头节点。 头结点的问题 一般提到头结点head时，可以将其理解为指向第一个结点的指针 所以head-&gt;val=第一个结点的值 head-&gt;next=第二个结点 递归解法 主要关键在于反向工作 用C++解决 构造函数 1234567struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; ListNode() : val(0), next(nullptr) {} 这是ListNode的默认构造函数。当你创建一个ListNode对象而不提供任何参数时，这个构造函数会被调用。它将val初始化为0，并将next初始化为nullptr（即空指针）； 以此类推，如果传入int x 或 int x与一个next指针，则会调用相应的构造函数 解法 M 215.数组中的第k个最大元素 2024.4.14 1.快速选择2.堆排序3.先排序后直接返回 一般用这个就够了根据快速排序算法的快速选择算法，在划分之后，如果枢轴元素正好是第k个，就找到了目标值，如果k在枢轴元素左边，则向左递归划分，否则向右递归划分。需要重点掌握的算法：划分、快排 E 226. 翻转二叉树 2024.4.23 递归 递归交换 只需要声明两个指针，用于递归地翻转左右子树，再进行交换，交换时直接交换节点而不是节点的值 时间和空间都是O(n) E 283.移动零 双指针 2024.4.5 双指针 一个指针遍历整个数组找非0值 一个指针标记0的位置（即要插入的位置）用非0值覆盖0值的位置 E 543.二叉树的直径 2024.6.6 这道题主要搞清楚几点：1.深度优先遍历 需要用其来计算深度 深度=max（左儿子深度，右儿子深度）+ 12.路径长度 = 根结点左右儿子的深度之和3.最长路径长度 用一个MAX来在计算深度时顺便记录 计算完左右孩子的深度时进行更新4.用到一个class内的局部变量MAX 只需定义一次5.注意：MAX是求深度depth时顺便记录的 depth返回的是深度 最长路径是MAX","link":"/2024/03/26/Leetcode/"},{"title":"NeRF入门及进阶——中恩实验室","text":"NeRF原理快速入门 1 关于渲染与反渲染（图形学） 渲染rendering：基于一个三维模型以及材质和光照的信息，通过一个特定的视角，将物体渲染成一个精美的画面。（上图） 反渲染inverse rendering（三维重建）：通过渲染出来的图像，重新得到三维模型。一般会用网格、点云或者体素的方式表现。 2 NeRF NeRF也是三维重建的一种技术，但是和以往技术不同： 以往技术：通过图片重建模型 NeRF：通过神经隐式重建模型 神经隐式：将三维模型的信息存在于神经网络中，输入相机位姿，输出图片的RGB和不透明度alpha。 可简单理解为：使用一个NeRF神经网络采取体积雾（带不透明度的点云）的渲染方式，通过已知视角的图片进行训练，然后输入其他相机视角的参数，从而预测出未出现视角的图片。 此时三维模型的信息存储在NeRF神经网络之中，所以是一种隐式的表示方法，而不是像点云、网格显示表示。 一个NeRF网络模型只能存储一个三维物体或场景的信息（单对单训练模型），现在有一些相关工作：希望网络可以同时使用在多个场景和多个三维模型（泛化）。 3 原理 3.1 输入：相机位姿——5D Input Position 相机位置：(x，y，z) Direction 相机方向：(θ，φ)，这是球坐标的表现方法，只要两个参数，方位角和俯仰角，代表的是相机位置与成像平面所对应像素连线发出的“光线”射线的方位，类似与Yaw，Pitch，Roll中的Yaw和Pitch，但不包含Roll。 注： θ是点在xOy平面上的投影 与 原点的连线 和 x轴正方向所成夹角，也就是一般说的极坐标的θ，取值范围为[0,2π)或[0,2π]。 φ是点与原点所成连线和z轴正半轴所成夹角，取值范围为[-π,π]（闭区间，否则顶点取不到）。 实际上在网络输入的仍然是三维向量，来表示射线方向xyz，和相机位置的xyz不同。 3.2 神经网络 F(θ) 最后目的就是把在这个相机角度下所拍摄到的图片的成像内容给输出出来。 一个像素点对应的射线和相机位置就是一个训练资料，一个神经网络模型只需要40mb的大小就可以存储下3D模型内容。 3.3 输出：一根射线上一组采样点的属性——4D Output 输出像素点对应射线上的一组采样点颜色值(r,g,b)和不透明度值(α)。 如图b，在一定范围内取了一组采样点（橙色小点，每个点带有rgba的值），代码中使用near和far参数来表示光线能到达的最近及最远点。 在射线方向上对采样渲染点进行积分得到确切颜色值（通过体积雾渲染的方式，图c，d），在第一次出现波峰对该像素点的着色影响最大。（所以NeRF渲染出来的物体有一种看起来像雾一样的感觉） 注： Density密度值/不透明度：α 该值与观测角度无关 3.4 位置编码γ(x,y,z) Positional Encoding 将图像中的高频信息体现出来，可以大幅度提高图片的细节质量 NeRF中的位置编码是通过concat 的方式将信息融合起来 Fθ=F‘θ ○ γ γ(p) = (sin(2^0^πp),cos(2^0^πp),…,sin(2^L-1^πp),cos(2^L-1^πp)). sin和cos两个为一项，空间坐标中用10项，即20维离开分别表示(x,y,z)位置编码 相机方向用4项，及8维来分别表示(x,y,z)位置编码 4 网络图 用全连接层一直连得到最终结果 5 Volume Render部分 采用一种体积雾的渲染方式，在获取一定范围采样点的(r,g,b,a)后需要再进行特定积分运算，最终得到对应像素最终的(r,g,b,a)，在训练时通过光线采样点积分得到的像素值 存在一个问题：光线穿透不透明的物体时 物体是存在前面和后面 后面的内容是不应该被成像出来的（物体不透明） 解决方式：通过一种特定的积分方式，主要是计算了第一个波峰所对应的颜色和不透明度值来产生对应的画面中的像素值 总结 通过一组图片（和对应的相机位姿）去训练一个网络，网络存储对应模型信息，再输入一个不一样视角的相机参数，就能呈现我们想要看到的物体的一个角度的成像。","link":"/2024/06/11/NeRF%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%AD%E6%81%A9%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"title":"Python笔记-Mosh","text":"Python笔记-Mosh 1.关于输入输出 ·input() 输入 括号里可以加想打在屏幕上的字 ·print（） 输出 其中可以用 运算符 ·可以用双引号和单引号 2.关于字符串 ·格式化字符串 以某个字符为开头 如 f‘{first} [{last}] is a coder’ down_payment = 0.2 * price print(f”Down payment: ${down_payment}”) （输出）Down payment: $100000.0 ·len() 函数返回长度 ·字符串改为大写 course.upper 小写 .lower (course是字符串变量) unit.lower() == “k” unit.upper()== “L” · .title 将字符串中每个单词首字母变成大写 其余变为小写 · .find找到字符或字符串的位置 · .replace 替换字符或字符串 ·用in运算符 可以判断字符串是否在其变量中 如‘python’ in course ，这会产生一个布尔型的值 true or false 3.关于加减乘除运算 ·**是次方（取幂） ·//是整除 /是除（浮点数） ·注意运算符之间的优先级 4.关于数字的处理 ·round函数 四舍五入 ·abs函数 输出其绝对值 ·导入数学模块 import math 用来使用math点函数 ·ceil函数 印章？ ·floor函数 取整 5.关于if语句 is_hot = True is_cold = True if is_hot: print(“It’s a hot day”) print(“Drink plenty of water”) elif is_cold: print(“It’s a cold day”) print(“Wear warm clothes”) else: print(“It’s a lovely day”) print(“Enjoy your day”) 6.关于逻辑运算符 and 和 or not：非 7.关于比较运算符 &lt;= &gt;= != == 等等 8.强制转换类型 int()函数：转换为int类型 weight = int(input(“Weight: “)) 9.关于while循环 While循环中也有类似于else的语句 一般用在循环结束时执行 secret_num = 9 guess_count = 0 guess_limit = 3 while guess_count &lt; guess_limit: guess = int(input(“Guess: “)) guess_count += 1 if guess == secret_num : print(f”Congraculation! It’s {guess} !”) break else: print(“Sorry you failed!”) 此语句 会在循环结束时执行else语句中的内容 除非在此之前循环中通过break跳出 10.练习-开车小游戏 我的代码： is_start = True command = input(“&gt;”) while is_start: if command == “help”: print(“start - to start the car”) print(“stop - to stop the car”) print(“quit - to exit”) command = input(“&gt;”) elif command == “start”: print(“Car started…Ready to go!”) command = input(“&gt;”) elif command == “stop”: print(“Car stopped.”) command = input(“&gt;”) elif command == “quit”: break else: print(“I don’t understand that …”) command = input(“&gt;”) 示例代码： command = “” flag_start = False while True: command = input(“&gt; “).lower() if command == “help”: print(“”” start - to start the car stop - to stop the car quit - to quit “””) elif command == “start”: if flag_start == False: print(“Car started…Ready to go!”) flag_start = True elif flag_start == True: print(“Car already started!”) elif command == “stop”: if flag_start == True: print(&quot;Car stopped.&quot;) flag_start = False elif flag_start == False: print(&quot;Car already stopped!&quot;) elif command == “quit”: break; else: print(“I don’t understand that …”) 11.关于for循环 适合用于循环遍历取值 ·range(起始, 结束, 步长)函数 从0到n-1 循环打印数字 for 变量名 in 可迭代对象（字符串、列表、字典等） for item in range(5,10,2): print(item) 例 遍历计算总和 prices = [10,20,30] total = 0 for price in prices: total += price print(f”Total:{total}”) 12.关于嵌套循环 输出一个用x组成的图形F —— 设置一个空字符串 循环加入x 再打印 numbers = [5,2,5,2,2] for x_count in numbers: output = ‘’ for count in range(x_count): output += ‘x’ print(output) 13.关于列表list 类似数组 可以用数组名[起始: 结束] 来选定特定的组内元素 如果忽略起始/结束符 则默认从开头/到结尾选定 names = [‘John’,’Bob’,’Mosh’,’Sarah’,’Mary’] print(names[2:4]) 通过修改索引项直接修改组内元素内容 names[1] = ‘Ann’ 例 找出列表中最大的数值 numbers = [12,32,57,4,86,998,324,102,10,90] max = numbers[0] for number in numbers: if number &gt; max: max = number print(max) number变量可以直接访问列表！ 14.关于二维列表2D list 定义： matrix = [ [1,2,3], [4,5,6], [7,8,9] ] 可以单个修改其中的元素： matrix[0][1] = 20 可以通过循环嵌套访问每个元素： for row in matrix: for item in row: print(item) 15.关于列表函数或列表方法List Methods ·.append（n） 列表末尾添加n ·.insert（索引数, n）在索引处添加n 其他数后移一位 ·.remove（n）删除一个n（最左边） ·.clear（） 删除列表中所有的值 ·.pop（） 删除最后一项 ·.index（n）找到列表中值为n的元素 并返回其索引值 也可以检查list中是否有n 当然 可以用in运算符来判断 会返回一个布尔值 ·.count（n）返回list中值等于n的元素的个数 ·.sort（） 不返回任何值（返回None）对list进行升序排序 ·.reverse（） 对list进行反转 可以配合sort函数进行list的降序排列 ·.copy（） 对列表进行复制 例 删除表中重复项 numbers = [5,2,1,7,4,5,9,5,20,20] uniques = [] for number in numbers: if number not in uniques: uniques.append(number) print(uniques) 16.关于元组Tuples 适用于不可改变值的list 类似于list 但是不同于list Tuples不可改变 不可赋值 只有count函数和index函数 17.关于解包Unpacking 可以避免多次赋值 将元组解包为三个变量 也可以用于列表list coordinates = (1,2,3) x = coordinates[0] y = coordinates[1] z = coordinates[2] x,y,z = coordinates 18.关于字典Dictionaries 存储以键值对形式出现的信息 可以修改其中的值 可以用方括号取值 也可以用get函数取值（get函数不会报错 只会返回None值） customer = { “name”:”John Smith”, “age”:30, “is_verified”:True } customer[“name”] = “Jack Smith” print(customer[“name”]) print(customer.get(“birthday”,”Jan 1 1980”)) 例 输入一串数字 将其中每个数字用英文输出 numbers_chinese = { “0”:”Zero”, “1”:”One”, “2”:”Two”, “3”:”Three”, “4”:”Four”, “5”:”Five”, “6”:”Six”, “7”:”Seven”, “8”:”Eight”, “9”:”Nine”, } Phone_numbers = input(“Phone: “) for i in Phone_numbers: print(f”{numbers_chinese[i]}”,end = ‘ ‘) 示例代码： numbers_chinese = { “0”:”Zero”, “1”:”One”, “2”:”Two”, “3”:”Three”, “4”:”Four”, “5”:”Five”, } Phone_numbers = input(“Phone: “) output = “” for i in Phone_numbers: output += numbers_chinese.get(i, “!”) + “ “ print(output) 将其一个一个加入了空的输出字符串中 而且每个字符后加了一个空格符 将数据放在一行上输出 并用空格隔开 用end参数——规定print函数输出的结尾字符 默认为回车符 for i in Phone_numbers: print(f”{numbers_chinese[i]}”,end = ‘ ‘) 19.关于表情Emoji Converter：) 一个小游戏 Split(‘ ‘) 函数 可以以字符’ ‘为界限 分割字符串中的各个字符 并返回一个列表list 20.关于函数 Functions 定义函数： def greet_user(): print(“Hi there!”) print(“Welcome!Here is a happy place!”) greet_user() 先定义 再调用 定义之后要空一行 21.关于传递参数parameters 将信息传递给函数 def greet_user(name): print(f”Hi {name}!”) greet_user(“John”) greet_user(“Mary”) 定义函数时 在括号里设定变量参数 def greet_user(first_name, last_name): print(f”Hi {first_name} {last_name}!”) greet_user(“John”,”Smith”) 可以对参数进行规定 提高可读性 greet_user(first_name=”John”,last_name=”Smith”) 如果同时传递位置和关键字参数 请使用位置参数之后的关键字参数 22.关于创建返回的函数 Return Statement def square(number): return number * number 一般情况下 函数默认（没有Return语句时）返回None 23.关于创建一个可重复使用的函数 Reusable Function def emoji_converter(message): words = message.split(“ “) emojis = { “:)”:”0.0”, “:(“:”QAQ” } output = “” for word in words: output += emojis.get(word,word) + “ “ return output message = input(“&gt;”) print(emoji_converter(message)) 24.关于处理异常情况/错误 try except （尝试接受块） try: age = int(input(‘Age: ‘)) print(age) except ValueError: print(‘Invalid value’) try：尝试运行以下代码 当错误信息为ValueError时 不要报错 而是执行以下代码（输出错误信息） 25.关于注释comments 注释一般要用来解释why或者how 而不是whats # 这是一行注释 ‘’’* 这是多行注释 ‘’’* # ctrl+/ 可以快捷设置注释 三个单引号和三个双引号都可以实现多行注释 26.关于类 classes 定义新的类型 帕斯卡命名法 命名规则：对于变量和函数 总是使用小写字母和下划线 可以分割多个单词 但对于类的命名 不使用下划线 而是大写每个单词的第一个字母 class EmailClient 定义类 类中可以定义函数 也可以像C中的结构体 定义新的变量并修改 class Point: def move(self): print(“move”) def draw(self): print(“draw”) point1 = Point() point1.x = 10 point1.y = 20 print(point1.x) point1.draw()","link":"/2023/04/21/Python%E7%AC%94%E8%AE%B0-Mosh/"},{"title":"limb_compound开发文档试写","text":"3.3 compound3.3.1 接口调用第一步：在x86环境调用mathimf.h库中的compound函数 12345678910111213141516#include &quot;stdio.h&quot;#include &quot;mathimf.h&quot; //调用mathimf.h库#include &quot;convert.h&quot;int main() { double inputValue1; double inputValue2; printf(&quot;please input an integer1: &quot;); scanf(&quot;%llx&quot;, &amp;inputValue1); printf(&quot;please input an integer2: &quot;); scanf(&quot;%llx&quot;, &amp;inputValue2); double result = compound(inputValue1,inputValue2); //调用mathimf.h库中的compound函数 printf(&quot;The result of _libm_compound is: %llx\\n&quot;, *(unsigned long long*)&amp;result); printf(&quot;The result of _libm_compound is: %lf\\n&quot;, *(unsigned long long*)&amp;result); return 0;} 第二步：Makefile编译 1234567891011121314151617181920212223242526VERSION =CC =iccDEBUG =-gCFLAGS =-fp-model precise -no-ftzifeq ($(COMPOUND), TRUE) SOURCES =compound_acc_test.c TARGET =compound_accendifINCLUDES =-I../src/includeLIB_NAMES =LIB_PATH =OBJ =$(patsubst %.c, %.o, $(SOURCES))#links$(TARGET): $(OBJ) $(CC) $(OBJ) $(LIB_PATH) $(LIB_NAMES) -o $(TARGET)$(VERSION) @rm -rf $(OBJ) #compile%.o: %.c $(CC) $(INCLUDES) $(DEBUG) -c $(CFLAGS) $&lt; -o $@.PHONY:cleanclean: @echo &quot;Remove linked and compiled files......&quot; rm -rf $(OBJ) $(TARGET) 3.3.2 IDA Pro反汇编第一步：使用IDA Pro打开编译后的文件compound，点击Tab键即可打开反汇编之后的伪代码。 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp){ double v3; // xmm0_8 double inputValue1; // [rsp+18h] [rbp-28h] BYREF double inputValue2; // [rsp+20h] [rbp-20h] BYREF double v7; // [rsp+28h] [rbp-18h] double result; // [rsp+30h] [rbp-10h] printf(&quot;please input an integer1: &quot;); __isoc99_scanf(&quot;%llx&quot;, &amp;inputValue1); printf(&quot;please input an integer2: &quot;); __isoc99_scanf(&quot;%llx&quot;, &amp;inputValue2); v7 = compound(inputValue1, inputValue2); v3 = v7; result = v7; printf(&quot;The result of _libm_compound is: %llx\\n&quot;, *(_QWORD *)&amp;v7); printf(&quot;The result of _libm_compound is: %lf\\n&quot;, v3); return 0;} 第二步：双击compound进入函数内部，找到对应的接口_libm_compound_ex。 1234__int64 compound(){ return _libm_compound_ex();} 第三步：双击_libm_compound_ex进入接口内部，又找到接口sub_4012E4。 1234__int64 _libm_compound_ex(){ return sub_4012E4();} 第四步：双击sub_4012E4进入接口内部，此时的伪代码就是我们需要实现的。例： 12345678910111213141516171819202122232425262728293031323334353637v2 = a2; v4 = *(_QWORD *)&amp;a2; v70 = a1; v5 = (*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FFLL; v6 = (*(_QWORD *)&amp;a2 &gt;&gt; 52) &amp; 0x7FFLL; if ( (unsigned int)(HIDWORD(a1) + 0x100000) &gt;= 0xBFF00000 || (_DWORD)v5 == 2047 || (unsigned int)(v6 - 1) &gt;= 0x7FE || (int)v6 + (int)v5 &lt; 1988 || ((unsigned __int16)(*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FFu) &gt;= 0x3FF &amp;&amp; (unsigned int)(v6 - 965) &gt;= 0x45 ) { v7 = 2LL * *(_QWORD *)&amp;a2; if ( !(2LL * *(_QWORD *)&amp;a2) ) { v69 = 0.0; return 1.0 + 0.0; } if ( ((*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FF) == 2047 ) { if ( (unsigned __int64)(2LL * *(_QWORD *)&amp;a1) &gt; 0xFFE0000000000000LL ) { v69 = 0.0; return v70 + 0.0; } if ( v7 &lt;= 0xFFE0000000000000LL ) { if ( a1 &lt; 0.0 ) return 0.0 * v70; result = 0.0; if ( a2 &gt; 0.0 ) { v69 = INFINITY; return INFINITY; } return result; } } 3.3.3 double类型常用宏定义1、HIDWORD(double x) 12345678static uint32_t HiDword(double x){ uint32_t ret; uint64_t xUint64; xUint64 = Asuint64(x); ret = (xUint64 &gt;&gt; 0x20) &amp; 0xFFFFFFFF; return ret;} 2、LOBYTE(double x) 123456static uint8_t LowByte(double x){ uint8_t ret; ret = Asuint64(x) &amp; 0xFF; return ret;}","link":"/2023/12/21/limb_compound%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E8%AF%95%E5%86%99/"},{"title":"gdb调试","text":"第一步：gdb ./compoundf第二步：打断点 b *0x。。。第三步：layout asm第四步：r第五步：输入第六步：走一步 si第七步：i r 寄存器 看寄存器的值","link":"/2023/10/25/limb_gdb%E8%B0%83%E8%AF%95/"},{"title":"limb规范标准（试行）","text":"未规范代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115__int64 sincos_k32(double *a1, double *a2,int a3, double a4){ double v11_data[2]; unsigned __int64 v4; __int64 result; unsigned int v5; int v6; double v7; unsigned int v8; int v9; struct __m128d v10; struct __m128d v11; int v12; int v13; int v14; double v15; double v16; __int64 v17; double v18; double v19; double v21; double v22; double inputX; double v24; double v25; double v26; double v27; double v28; double ones[2] = {1.0, -1.0}; double iones[2]={1,-1}; v28 = a4; v4 = HIDWORD(a4) &gt;&gt; 31; v5 = HIDWORD(a4) &amp; 0x7FFFFFFF;//将上述读取的 64 位整数值与 0x7FFFFFFF 进行按位与操作。 v6 = iones[v4] * a3; v7 = fabs(a4); if (v5 &gt;= 0x41C00000) { v28 = v7; v17 = reduce_pi04d(&amp;v28, v6, v7); v8 = v17 + 1; v7 = v28; //v9 = ((_BYTE)(v17) + 1) &amp; 2;// 是从一个 double 类型的值中提取指定索引位置的字节，并对提取的字节进行处理，最终得到一个 uint8_t 类型的结果。 //v9 = (getByteFromDouble(v17, 0) + 1) &amp; 2; v9 = ((_BYTE)v17 + 1) &amp; 2; } else if (v5 &gt; 0x3FF90000) { v10.m128d_f64[0] = Asdouble(0x3FF45F306DC9C883) * v7; v28 = v7; v27 = Asdouble(0x3FF45F306DC9C883) * v7 + Asdouble(0x4338000000000000); //v11_data[1] = (double)SLODWORD(v27); //v11 = *((__m128d*)v11_data); v11.m128d_f64[0] = (double)SLODWORD(v27); //v11.m128d_f64[1] = v11_data[1]; v12 = compare(&amp;v10, &amp;v11); v13 = LODWORD(v27) - v12 + v6; v14 = v13 &amp; 1; v8 = v14 + v13; v15 = (double)(v14 + LODWORD(v27) - v12); v9 = v8 &amp; 2; if (v5 &gt;= 0x41000000){ v16 = v28 - Asdouble(0x3FE921FB40000000) * v15 - Asdouble(0x3E64442D00000000) * v15 - Asdouble(0x3CE8469880000000) * v15; } else{ v16 = v7 - Asdouble(0x3FE921FB54440000) * v15 - Asdouble(0x3D768C234C400000) * v15; } v7 = v16 - v15 * Asdouble(0x3B68CC51701B839A); v28 = v7; } else{ v8 = v6 + 1; v9 = v8 &amp; 2; if (v8 &amp; 2){ v7 = v7 - Asdouble(0x3FE921FB54442D18); } v28 = v7; } v18 = v7 * v7; v19 = (Asdouble(0x3EC71D9AA585BFC4) * (v18 * v18) + Asdouble(0x3F81111110FD4208)) * (v18 * v18) * v7 + v7 + ((Asdouble(0xBE5AA2880297FC43) * (v18 * v18) + Asdouble(0xBF2A019FD9BD0882)) * (v18 * v18) + Asdouble(0xBFC555555555516D))* v18* v7; result = ((v8 + 2) &gt;&gt; 2) &amp; 1; v21 = (Asdouble(0x3EFA01299942AB00) * (v18 * v18) + Asdouble(0x3FA5555555150951)) * (v18 * v18) + Asdouble(0x3FF0000000000000) + ((Asdouble(0x0BE9247507B5EE59E) * (v18 * v18) + Asdouble(0xBF56C16BAE710FF8)) * (v18 * v18) + Asdouble(0xBFDFFFFFFFFFE6A2)) * v18; v22 = ones[(v8 &gt;&gt; 2) &amp; 1 ^ v4]; if (v9){ inputX = v21 * v22; v24 = ones[result]; *a1 = inputX; *a2 = v19 * v24; } else{ v25 = v19 * v22; v26 = ones[result]; *a1 = v25; *a2 = v21 * v26; } return result;} 规范代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int64_t SincosK32(double* outputX, double* outputY, int y, double x){ uint64_t xSign; unsigned int magnitude; int signedMultiplier; double doubleTemp; double xAbs; unsigned int uint32Temp; int uint32SetBit; double xAbsMulTemp; double xAbsTemp; double xAbsTempConInt; double retCompare; int temp; int getLastBit; double doubleTempSquare; int onesIndex; double intTemp; double xAbsSubTemp; double onesConvDouble; double doubleTempX; double doubleTempY; int retReduce; double input; xSign = hiDoubleDword(x) &gt;&gt; 0x1F; magnitude = hiDoubleDword(x) &amp; 0x7FFFFFFF; signedMultiplier = ones[xSign] * y; xAbs = fabs(x); if (magnitude &gt;= 0x41C00000) { retReduce = ReducePi04d(&amp;input, signedMultiplier, xAbs ); uint32Temp = retReduce + 1; doubleTemp = input; uint32SetBit = (retReduce + 1) &amp; 0x2; } else if (magnitude &gt; 0x3FF90000) { xAbsMulTemp = Asdouble(0X3FF45F306DC9C883) * xAbs; xAbsTemp = Asdouble(0X3FF45F306DC9C883) * xAbs + Asdouble(0x4338000000000000); xAbsTempConInt = lowDoubleDword(xAbsTemp); retCompare = compare(xAbsMulTemp, xAbsTempConInt); temp = xAbsTempConInt - retCompare + signedMultiplier; getLastBit = temp &amp; 1; uint32Temp = getLastBit + temp; intTemp = getLastBit + xAbsTempConInt - retCompare; uint32SetBit = uint32Temp &amp; 0x2; if (magnitude &gt;= 0x41000000) { xAbsSubTemp = xAbs - Asdouble(0x3FE921FB40000000) * intTemp - Asdouble(0x3E64442D00000000) * intTemp - Asdouble(0x3CE8469880000000) * intTemp; } else { xAbsSubTemp = xAbs - Asdouble(0x3FE921FB54440000) * intTemp - Asdouble(0x3D768C234C400000) * intTemp; } doubleTemp = xAbsSubTemp - intTemp * Asdouble(0x3B68CC51701B839A); } else { uint32Temp = signedMultiplier + 1; uint32SetBit = uint32Temp &amp; 0x2; if (uint32Temp &amp; 0x2) { doubleTemp = xAbs - Asdouble(0x3FE921FB54442D18); } else { doubleTemp = xAbs; } } doubleTempSquare = doubleTemp * doubleTemp; doubleTempX = (Asdouble(0x3EC71D9AA585BFC4) * (doubleTempSquare * doubleTempSquare) + Asdouble(0x3F81111110FD4208)) * (doubleTempSquare * doubleTempSquare) * doubleTemp + doubleTemp + ((Asdouble(0xBE5AA2880297FC43) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBF2A019FD9BD0882)) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBFC555555555516D)) * doubleTempSquare * doubleTemp; onesIndex = ((uint32Temp + 0x2) &gt;&gt; 0x2) &amp; 1; doubleTempY = (Asdouble(0x3EFA01299942AB00) * (doubleTempSquare * doubleTempSquare) + Asdouble(0x3FA5555555150951)) * (doubleTempSquare * doubleTempSquare) + 1.0 + ((Asdouble(0xBE9247507B5EE59E) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBF56C16BAE710FF8)) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBFDFFFFFFFFFE6A2)) * doubleTempSquare; onesConvDouble = ones[(uint32Temp &gt;&gt; 0x2) &amp; 1 ^ xSign]; if (uint32SetBit) { *outputX = doubleTempY * onesConvDouble; *outputY = doubleTempX * ones[onesIndex]; } else { *outputX = doubleTempX * onesConvDouble; *outputY = doubleTempY * ones[onesIndex]; } return 0;}","link":"/2023/09/28/limb%E8%A7%84%E8%8C%83%E6%A0%87%E5%87%86%EF%BC%88%E8%AF%95%E8%A1%8C%EF%BC%89/"},{"title":"limb_compound开发项目日志","text":"关于compound_float函数的代码调试及精度测试2023.10.13当前状态：代码未通过编译 ‘_libm_error_support‘ 报错为 未声明的函数 此函数是否为库函数 是否需要进行链接 解决办法：直接注释 ‘_libm_exp‘ 同上 compound_float0.c:198:1: warning: non-void function does not return a value in all control paths [-Wreturn-type] 非void函数 在每个分支都没有返回值 ida中反汇编的源代码函数为void类型 log1p 在ida源代码中为**_libm_log1p** vscode中报错为未定义的函数 2023.10.30 compound double类型函数 调试后 修改代码205行和208行 为result和v77值添加负号 结果：精度从60%提升到79% ida第87行代码 第999993个测试数上 x86结果为nan 即-(0.0/0.0)，但arm上结果为 1.0 若进行更改则精度降低 比如第999998个测试数上x86又为1.0，arm为-nan 是否要进行加入条件分支？条件如何选择？","link":"/2023/10/13/limb%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/"},{"title":"linux_01_open","text":"12345678910111213141516171819202122232425262728293031323334#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()int main(int argc, char **argv){ int fd; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } fd = open(argv[1], O_RDWR);//can read &amp;&amp; can write if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ sleep(10); } close(fd); return 0;}","link":"/2024/10/07/linux_01_open/"},{"title":"linux_02_create","text":"1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()int main(int argc, char **argv){ int fd; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0777);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ sleep(10); } close(fd); return 0;}","link":"/2024/10/07/linux_02_create/"},{"title":"linux_03_write","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./write 1.txt str1 str2*/int main(int argc, char **argv){ int fd; int i; int len; if (argc &lt; 3){ printf(&quot;Usage: %s &lt;file&gt; &lt;str1&gt; &lt;str2&gt; ...\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0644);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } for (i = 2; i &lt; argc; i++){ len = write(fd, argv[i], strlen(argv[i])); if(len != strlen(argv[i])){ perror(&quot;write&quot;); break; } write(fd, &quot;\\r\\n&quot;, 2); } close(fd); return 0;}","link":"/2024/10/07/linux_03_write/"},{"title":"linux_04_read","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./read 1.txt*/int main(int argc, char **argv){ int fd; int i; int len; unsigned char buf[100]; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDONLY);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;read&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ len = read(fd, buf, sizeof(buf)-1); if(len &lt; 0){ perror(&quot;read&quot;); close(fd); return -1; }else if(len == 0){ break; }else{ buf[len-1] = '\\0';// set the end sign printf(&quot;%s\\n&quot;,buf); } } close(fd); return 0;}","link":"/2024/10/07/linux_04_read/"},{"title":"linux_03_write_in_pos","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./write 1.txt str1 str2*/int main(int argc, char **argv){ int fd; int i; int len; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT, 0644);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } printf(&quot;lseek to offset 3 from file head\\n&quot;); lseek(fd, 3, SEEK_SET); // SEEK_SET: from the begin to offset write(fd, &quot;123&quot;, 3); close(fd); return 0;}","link":"/2024/10/07/linux_03_write_in_pos/"},{"title":"linux_05_Makefile","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152CROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -gCFLAGS += -I $(shell pwd)/includeLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/all : start_recursive_build $(TARGET) @echo $(TARGET) has been built!start_recursive_build: make -C ./ -f $(TOPDIR)/Makefile.build$(TARGET) : start_recursive_build $(CC) -o $(TARGET) built-in.o $(LDFLAGS)clean: rm -f $(shell find -name &quot;*.o&quot;) rm -f $(TARGET)distclean: rm -f $(shell find -name &quot;*.o&quot;) rm -f $(shell find -name &quot;*.d&quot;) rm -f $(TARGET)","link":"/2024/10/07/linux_05_Makefile/"},{"title":"linux_05_Process_excel","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */static int read_line(int fd, unsigned char *buf){ // read for loop a char // how to judge already read a line, read until 0x0d 0x0a unsigned char c; int len; int i = 0; int err = 0; while (1){ len = read(fd, &amp;c, 1); if(len &lt;= 0){ // read no data err = -1; break; }else{ if (c != '\\n' &amp;&amp; c != '\\r'){ buf[i] = c; i++; }else{ // read \\n and \\r, already read a line err = 0; break; } } } // read end OR \\r\\n, fix \\0 in the buf, \\0 means null char, ASCII = 0 buf[i] = '\\0'; if(err &amp;&amp; i==0){ // read end but no data return -1; }else{ return i; }}void process_data(unsigned char *data_buf, unsigned char *result_buf){ /* test 1: data_buf = &quot;,yuwen,shuxue,yingyu,zongfen,pingjia&quot; result_buf = &quot;,yuwen,shuxue,yingyu,zongfen,pingjia&quot; test 2: data_buf = &quot;zhangsan,90,91,92,,&quot; result_buf = &quot;zhangsan,90,91,92,273,A+&quot; */ char name[100]; int scores[3]; int sum = 0; int level; char *levels[] = {&quot;A+&quot;,&quot;A&quot;,&quot;B&quot;};// &gt;=90, &gt;=80, &lt;80 if(data_buf[0] == 0xef){ // for UTF-8 (BOM), first line, first 3 chars: 0xef 0xbb 0xbf strcpy(result_buf, data_buf); // help: man strcpy(shell) // printf(&quot;data_buf: %s&quot;,data_buf); }else{ // use sscanf() separate ',' and other char // %[] means scanf be ruled, '^' means NO, '^,' means NO ',' but other char could sscanf(data_buf, &quot;%[^,],%d,%d,%d,&quot;, name, &amp;scores[0], &amp;scores[1], &amp;scores[2]); // printf(&quot;result: %s,%d,%d,%d\\n&quot;,name, scores[0], scores[1], scores[2]); sum = scores[0] + scores[1] + scores[2]; level = sum &gt;= 270? 0: (sum &gt;= 240? 1:2); sprintf(result_buf,&quot;%s,%d,%d,%d,%d,%s&quot;, name, scores[0], scores[1], scores[2], sum, levels[level]); // printf(&quot;result: %s&quot;,result_buf); }}/* ./process_excel data.csv result.csv argc = 3 argv[0] = &quot;./process_excel&quot; argv[1] = &quot;data.csv&quot; argv[2] = &quot;result.csv&quot;*/int main(int argc, char **argv){ int fd_data, fd_result; int i; int len; unsigned char data_buf[1000]; unsigned char result_buf[1000]; if (argc != 3){ printf(&quot;Usage: %s &lt;data csv file&gt; &lt;result csv file&gt;\\n&quot;,argv[0]); return -1; } // open the first csv file fd_data = open(argv[1], O_RDONLY);//can read &amp;&amp; can write if (fd_data &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); perror(&quot;open&quot;); return -1; } else { printf(&quot;data file fd = %d\\n&quot;, fd_data); } // create by open the result csv file fd_result = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0644);//can read &amp;&amp; can write if (fd_result &lt; 0){ printf(&quot;can not create file %s\\n&quot;, argv[2]); perror(&quot;create&quot;); return -1; } else { printf(&quot;data file fd = %d\\n&quot;, fd_result); } // processing while (1){ // read 1 line from data file len = read_line(fd_data, data_buf); if (len == -1){ break; } //if (len != 0){ // printf(&quot;line: %s\\n\\r&quot;,data_buf); //} if (len != 0){ // process data from 1 line process_data(data_buf,result_buf); // write data in result file write(fd_result, result_buf, strlen(result_buf)); write(fd_result,&quot;\\r\\n&quot;,2); // printf(&quot;result_buf: %s&quot;,result_buf); } } close(fd_data); close(fd_result); return 0;}","link":"/2024/10/11/linux_05_process_excel/"},{"title":"linux_07_dup","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */int main(int argc, char **argv){ char buf[10]; char buf2[10]; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;, argv[0]); return -1; } int fd = open(argv[1], O_RDONLY); int fd2 = open(argv[1], O_RDONLY); int fd3 = dup(fd); printf(&quot;fd = %d\\n&quot;, fd); printf(&quot;fd2 = %d\\n&quot;, fd2); printf(&quot;fd3 = %d\\n&quot;, fd3); if (fd &lt; 0 || fd2 &lt; 0 || fd3 &lt; 0){ printf(&quot;can not open %s\\n&quot;, argv[1]); return -1; } read(fd, buf, 1); read(fd2, buf2, 1); printf(&quot;data get from fd : %c\\n&quot;, buf[0]); printf(&quot;data get from fd2: %c\\n&quot;, buf2[0]); read(fd3, buf, 1); printf(&quot;data get from fd3: %c\\n&quot;, buf[0]); return 0;}","link":"/2024/10/17/linux_07_dup/"},{"title":"linux_11_input_01_get_input_info","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;/* ./01_get_input_info /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } return 0;}","link":"/2024/10/30/linux_11_input_01_get_input_info/"},{"title":"linux_11_input_03_input_read_poll","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;/* ./03_input_read_poll /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; struct pollfd fds[1]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd; fds[0].events = POLLIN; fds[0].revents = 0; ret = poll(fds,nfds,5000); if(ret &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_03_input_read_poll/"},{"title":"linux_11_input_03_input_read_poll_more","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;/* ./03_input_read_poll_more /dev/input/event0 /dev/input/event1**/int main(int argc, char **argv){ int fd1,fd2; int err1,err2; int len1,len2; int ret1,ret2; int i; unsigned char byte; int bit; struct input_id id[2]; unsigned int evbit[2]; struct input_event event; struct pollfd fds[2]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc &lt; 2){ printf(&quot;Usage: %s &lt;dev&gt; &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd1 = open(argv[1], O_RDWR | O_NONBLOCK); if(fd1 &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } fd2 = open(argv[2], O_RDWR | O_NONBLOCK); if(fd2 &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[2]); return -1; } // get dev info err1 = ioctl(fd1, EVIOCGID, &amp;id[0]); if(err1 == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id[0].bustype); printf(&quot;vendor = 0x%x\\n&quot;, id[0].vendor ); printf(&quot;product = 0x%x\\n&quot;, id[0].product); printf(&quot;version = 0x%x\\n&quot;, id[0].version); } err2 = ioctl(fd2, EVIOCGID, &amp;id[1]); if(err2 == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id[1].bustype); printf(&quot;vendor = 0x%x\\n&quot;, id[1].vendor ); printf(&quot;product = 0x%x\\n&quot;, id[1].product); printf(&quot;version = 0x%x\\n&quot;, id[1].version); } // get evbit len1 = ioctl(fd1, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len1 &gt; 0 &amp;&amp; len1 &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len1;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } len2 = ioctl(fd2, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len2 &gt; 0 &amp;&amp; len2 &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len2;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd1; fds[0].events = POLLIN; fds[0].revents = 0; fds[1].fd = fd2; fds[1].events = POLLIN; fds[1].revents = 0; ret1 = poll(&amp;fds[0],nfds,5000); ret2 = poll(&amp;fds[1],nfds,5000); if(ret1 &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd1,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret1 == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } if(ret2 &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd2,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret2 == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_03_input_read_poll_more/"},{"title":"linux_11_input_02_input_read","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;/* ./02_input_read /dev/input/event0 noblock **/int main(int argc, char **argv){ int fd; int err; int len; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc &lt; 2){ printf(&quot;Usage: %s &lt;dev&gt; [noblock]\\n&quot;,argv[0]); return -1; } // open dev file if(argc == 3 &amp;&amp; !strcmp(argv[2],&quot;noblock&quot;)){ fd = open(argv[1], O_RDWR | O_NONBLOCK); }else{ fd = open(argv[1], O_RDWR); } if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ len = read(fd,&amp;event,sizeof(event)); if(len == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); }else{ printf(&quot;read err %d\\n&quot;,len); } } return 0;}","link":"/2024/10/31/linux_11_input_02_input_read/"},{"title":"linux_06_app_libc_kernel","text":"12345678910111213141516171819202122232425262728#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */int main(int argc, char **argv){ if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;, argv[0]); return -1; } int fd = open(argv[0], O_RDONLY); printf(&quot;fd = %d\\n&quot;, fd); while (1){ sleep(100); } return 0;}","link":"/2024/10/17/linux_06_app_libc_kernel/"},{"title":"linux_11_input_04_input_read_select","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;#include &lt;sys/select.h&gt;/* ./04_input_read_select /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; struct pollfd fds[1]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd; fds[0].events = POLLIN; fds[0].revents = 0; ret = poll(fds,nfds,5000); if(ret &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_04_input_read_select/"},{"title":"linux_11_input_05_input_read_fasync","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* ./05_input_read_fasync /dev/input/event0 **/int fd;void my_sig_handler(int sig){ struct input_event event; while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); }}int main(int argc, char **argv){ int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; unsigned int flags; int count = 0; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // register siganl process function signal(SIGIO,my_sig_handler); // open drive app fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } // bring pid of app to drive app fcntl(fd,F_SETOWN,getpid()); // make fasync flags = fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,flags | FASYNC); while(1){ printf(&quot;main loop count = %d\\n&quot;,count++); sleep(2); } return 0;}","link":"/2024/10/31/linux_11_input_05_input_read_fasync/"},{"title":"linux_11_socket_tcp_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket connect send/recv*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_STREAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // connect iAddrLen = sizeof(struct sockaddr); iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; } // send while(1){ if(fgets(ucSendBuf, 999, stdin)){ iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_tcp_client/"},{"title":"linux_11_socket_tcp_server","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* socket bind listen accept send/ recv*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#define SERVER_PORT 8888#define BACKLOG 10int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// accpet int iSocketClient; int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept signal(SIGCHLD, SIG_IGN); // socket // (IPv4,TCP,protocol) iSocketServer = socket(AF_INET, SOCK_STREAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // listen iRet = listen(iSocketServer, BACKLOG); if(iRet == -1){ printf(&quot;listen error!\\n&quot;); return -1; } // accept while(1){ iAddrLen = sizeof(struct sockaddr); iSocketClient = accept(iSocketServer, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iSocketClient != -1){ iClientNum++; printf(&quot;Get connect from client %d : %s\\n&quot;, iClientNum, inet_ntoa(tSocketClientAddr.sin_addr)); if(!fork()){ // son while(1){ // accpet and display data from client iRecvLen = recv(iSocketClient, ucRecvBuf, 999, 0); if(iRecvLen &lt;= 0){ close(iSocketClient); return -1; }else{ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %d: %s\\n&quot;, iClientNum, ucRecvBuf); } } } } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_tcp_server/"},{"title":"linux_11_socket_udp_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket connect sendto/recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_DGRAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // connect iAddrLen = sizeof(struct sockaddr); iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; } // send while(1){ if(fgets(ucSendBuf, 999, stdin)){ iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_udp_client/"},{"title":"linux_11_socket_udp_no_connect_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket sendto/recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_DGRAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset()#if 0 // connect iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; }#endif // send while(1){ if(fgets(ucSendBuf, 999, stdin)){#if 0 iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); #else iAddrLen = sizeof(struct sockaddr); iSendLen = sendto(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen);#endif if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_udp_no_connect_client/"},{"title":"linux_11_socket_udp_no_connect_server","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* socket bind sendto/ recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// recvfrom int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept // socket // (IPv4,UDP,protocol) iSocketServer = socket(AF_INET, SOCK_DGRAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // recvfrom while(1){ // accpet and display data from client iAddrLen = sizeof(struct sockaddr); iRecvLen = recvfrom(iSocketServer, ucRecvBuf, 999, 0, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iRecvLen &gt; 0){ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %s: %s\\n&quot;, inet_ntoa(tSocketClientAddr.sin_addr), ucRecvBuf); } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_udp_no_connect_server/"},{"title":"linux_11_socket_udp_server","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* socket bind sendto/ recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// recvfrom int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept // socket // (IPv4,UDP,protocol) iSocketServer = socket(AF_INET, SOCK_DGRAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // recvfrom while(1){ // accpet and display data from client iAddrLen = sizeof(struct sockaddr); iRecvLen = recvfrom(iSocketServer, ucRecvBuf, 999, 0, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iRecvLen &gt; 0){ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %s: %s\\n&quot;, inet_ntoa(tSocketClientAddr.sin_addr), ucRecvBuf); } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_udp_server/"},{"title":"linux_13_pthread0","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;// static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic pthread_cond_t g_tConVar = PTHREAD_COND_INITIALIZER;// conditionstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); // sem_wait(&amp;g_sem); pthread_mutex_lock(&amp;g_tMutex); pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex); /*print*/ // pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; // sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_cond_signal(&amp;g_tConVar);/*notice recv thread*/ pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 1; // sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread0/"},{"title":"linux_13_pthread1","text":"1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;static void *my_thread_func (void *data){ while(1){ sleep(1); }}int main(int argc, char **argv){ pthread_t tid; int ret; /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ sleep(1); } return 0;}","link":"/2024/10/27/linux_13_pthread1/"},{"title":"linux_13_pthread2","text":"12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;static char g_buf[1000];static int g_hasData = 0;static void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ while(g_hasData == 0); /*print*/ printf(&quot;recv: %s\\n&quot;, g_buf); g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(g_buf, 1000, stdin); /*notice recv thread*/ g_hasData = 1; } return 0;}","link":"/2024/10/27/linux_13_pthread2/"},{"title":"linux_13_pthread3","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;static char g_buf[1000];// static int g_hasData = 0;static sem_t g_sem; //signalstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); sem_wait(&amp;g_sem); /*print*/ printf(&quot;recv: %s\\n&quot;, g_buf); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(g_buf, 1000, stdin); /*notice recv thread*/ // g_hasData = 1; sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread3/"},{"title":"linux_13_pthread4","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); sem_wait(&amp;g_sem); /*print*/ pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_mutex_unlock(&amp;g_tMutex); /*notice recv thread*/ // g_hasData = 1; sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread4/"},{"title":"linux_13_pthread5","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;// static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic pthread_cond_t g_tConVar = PTHREAD_COND_INITIALIZER;// conditionstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); // sem_wait(&amp;g_sem); pthread_mutex_lock(&amp;g_tMutex); pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex); /*print*/ // pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; // sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_cond_signal(&amp;g_tConVar);/*notice recv thread*/ pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 1; // sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread5/"},{"title":"linux_i2c_at24c02","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;sys/ioctl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/i2c-dev.h&gt;#include &lt;i2c/smbus.h&gt;#include &quot;i2cbusses.h&quot;#include &lt;time.h&gt;/* ./at24c02 &lt;i2c_bus_number&gt; w &quot;100ask.taobao.com&quot; ./at24c02 &lt;i2c_bus_number&gt; r*/int main(int argc, char **argv){ unsigned char dev_addr = 0x50; unsigned char mem_addr = 0; unsigned char buf[32]; int file; char filename[20]; unsigned char *str; struct timespec req; int ret; if(argc != 3 &amp;&amp; argc !=4){ printf(&quot;Usage:\\n&quot;); printf(&quot;write eeprom: %s &lt;i2c_bus_number&gt; w string\\n&quot;,argv[0]); printf(&quot;read eeprom: %s &lt;i2c_bus_number&gt; r\\n&quot;,argv[0]); return -1; } // open i2c device file = open_i2c_dev(argv[1][0]-'0', filename, sizeof(filename), 0); if(file &lt; 0){ printf(&quot;can't open %s\\n&quot;,filename); return -1; } // set slave address if(set_slave_addr(file, dev_addr, 1)){ printf(&quot;can't set_slave_addr\\n&quot;); return -1; } // write or read data if(argv[2][0]=='w'){ // argv[2] is a string, argv[2][0] is a char from the string // write str: argv[3] str = argv[3]; req.tv_sec = 0; req.tv_nsec = 20000000;// 20ms while(*str){ // mem_addr, *str // mem_addr++, str++ ret = i2c_smbus_write_byte_data(file, mem_addr, *str); if(ret){ printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; } // wait tWR(10ms) nanosleep(&amp;req, NULL); mem_addr++; str++; } ret = i2c_smbus_write_byte_data(file, mem_addr, 0);// string end char if(ret){ printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; } }else{ // read ret = i2c_smbus_read_i2c_block_data(file, mem_addr, sizeof(buf), buf); if(ret &lt; 0){ printf(&quot;i2c_smbus_read_i2c_block_data err\\n&quot;); return -1; } buf[31] = '\\0'; printf(&quot;get data: %s\\n&quot;,buf); } return 0;}","link":"/2024/10/30/linux_i2c_at24c02/"},{"title":"pa0_homework","text":"12345678910111213141516171819202122232425262728293031#include&lt;cmath&gt;#include&lt;eigen3/Eigen/Core&gt;#include&lt;eigen3/Eigen/Dense&gt;#include&lt;iostream&gt;int main(){ // a point P(2,1) a vector Eigen::Vector3f P(2.0f,1.0f,1.0f); std::cout &lt;&lt; &quot;old P \\n&quot; &lt;&lt; P.head&lt;2&gt;() &lt;&lt; std::endl; // a rotation matrix R // [cost, -sint // sint, cost] float t = (45.0 / 180.0) * acos(-1); Eigen::Matrix3f R; R &lt;&lt; cos(t), -sin(t), 0, sin(t), cos(t) , 0, 0 , 0 , 1; // run rotation P = R * P; // + B Eigen::Vector3f B(1.0f,2.0f,0.0f); P = P + B; //output P std::cout &lt;&lt; &quot;new P \\n&quot; &lt;&lt; P.head&lt;2&gt;() &lt;&lt; std::endl; return 0;}","link":"/2024/09/21/pa0_homework/"},{"title":"pa0_main","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;eigen3/Eigen/Core&gt;#include&lt;eigen3/Eigen/Dense&gt;#include&lt;iostream&gt;int main(){ // Basic Example of cpp std::cout &lt;&lt; &quot;Example of cpp \\n&quot;; float a = 1.0, b = 2.0; std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; a/b &lt;&lt; std::endl; std::cout &lt;&lt; std::sqrt(b) &lt;&lt; std::endl; std::cout &lt;&lt; std::acos(-1) &lt;&lt; std::endl; std::cout &lt;&lt; std::sin(30.0/180.0*acos(-1)) &lt;&lt; std::endl; // Example of vector std::cout &lt;&lt; &quot;Example of vector \\n&quot;; // vector definition Eigen::Vector3f v(1.0f,2.0f,3.0f); Eigen::Vector3f w(1.0f,0.0f,0.0f); // vector output std::cout &lt;&lt; &quot;Example of output \\n&quot;; std::cout &lt;&lt; v &lt;&lt; std::endl; // vector add std::cout &lt;&lt; &quot;Example of add \\n&quot;; std::cout &lt;&lt; v + w &lt;&lt; std::endl; // vector scalar multiply std::cout &lt;&lt; &quot;Example of scalar multiply \\n&quot;; std::cout &lt;&lt; v * 3.0f &lt;&lt; std::endl; std::cout &lt;&lt; 2.0f * v &lt;&lt; std::endl; // Example of matrix std::cout &lt;&lt; &quot;Example of matrix \\n&quot;; // matrix definition Eigen::Matrix3f i,j; i &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0; j &lt;&lt; 2.0, 3.0, 1.0, 4.0, 6.0, 5.0, 9.0, 7.0, 8.0; // matrix output std::cout &lt;&lt; &quot;Example of output \\n&quot;; std::cout &lt;&lt; i &lt;&lt; std::endl; // matrix add i + j std::cout &lt;&lt; &quot;add i + j \\n&quot; &lt;&lt; i + j &lt;&lt; std::endl; // matrix scalar multiply i * 2.0 std::cout &lt;&lt; &quot;scalar multiply i * 2.0 \\n&quot; &lt;&lt; i * 2.0f &lt;&lt; std::endl; // matrix multiply i * j std::cout &lt;&lt; &quot;multiply i * j \\n&quot; &lt;&lt; i * j &lt;&lt; std::endl; // matrix multiply vector i * v std::cout &lt;&lt; &quot;multiply vector i * v \\n&quot; &lt;&lt; i * v &lt;&lt; std::endl; return 0;}","link":"/2024/09/21/pa0_main/"},{"title":"医学AI学术交流会","text":"基金项目申请-青年基金评审-赵宏 题目很重要 摘要 给出内容和重点 研究背景和意义 研究的紧迫性 研究成果的重要性 研究现状 时效性、全面性、针对性、SOTA 研究内容 重点 拟解决的关键问题 来源于研究内容 研究方案和技术路线 与研究内容对应 体现理论和技术的高度 创新点 来源于研究内容，关键问题 少数即可 年度计划、预期成果 与研究内容相对应 论文、专利、软著、学术交流、人才培养 研究基础和条件 已发表的论文、代表作 需要有相关性 支撑研究的条件 其他 师承、工作单位、文笔、领域、地域、科研经历、评审中出现D一票否决 医生眼中的人工智能-兰州大学第二医院核磁共振科-胡万均 大模型 深度学习神经网络 基于U-net的医学图像问题研究 结合临床实际的研究 前景很好 主要的问题还是 数据集私密的问题 拿不到医学类的数据 医工交叉前景无限 主要是落地到临床实现的应用几乎很少 所有研究都是基于大量数据 缺乏算力 难以进行大模型研究 医学内部的数据量很充分 医学内部的方法学很薄弱 而CS在这方面是强项 医学数据很多 耗费时间很大 而且需要专业的医生或者懂医学的人对模型进行调整 包括对训练结果的监督 利用临床二维图像 基于三维重建模型 生成三维模型 很有意义 医学图像分割 低维图像变高维图像 低分辨率图像变高分辨率图像 神经调控研究-脑电-崔琨博 抑郁症 治疗：经颅磁刺激 TMS 数据采集：脑电采集 设备成本巨大 实验需依靠实验室 源定位 脑电信号 传导到头皮容易受到其中皮层组织的干扰 脑组织电导率不均匀 脑源信号对各个方向都会施加影响 正问题：从头皮映射到源上 逆问题：根据头皮脑信号推算出脑内源活动 应用场景： 边缘计算硬件 对现有框架施加约束项优化定位精度 小型化设备 脑电伪迹去除 动作影响伪迹 设备伪迹 脉冲 充放电 滤波去除伪迹 神经网络方法去除眼电 神经调控 Neuralink 脑机接口 基于行为信息的抑郁识别研究-陶博士 通过提取人的面部表情特征点及语音特征点对于抑郁症的识别 深度学习模型的可解释性-常兆斌 事先可解释性：小样本图像语义分割 主要在语音分割的support与query上进行创新 基于query的信息对support进行指导 提取support与query的信息 找出其共同信息（之间的联系） 主要在特征处理上做 特征解耦 特征重构 大模型与写作技巧-郭岚 大模型微调 大模型迁移 知识蒸馏 数据优先，只要有其他人没有的数据就能做 写作技巧 生成公式 或 代码优化 小样本动作识别与因果学习/因果推理的探索-陈志文 小样本动作识别 因果推理（方法）","link":"/2024/06/01/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81%E4%BC%9A%202024.6.1/"},{"title":"神经渲染：图形学 + 深度学习","text":"神经渲染：图形学 + 深度学习 利用深度学习和图形学技术，实现高质量、高效率、高灵活性的图像合成和渲染的方法，并且能够对图像进行编辑，从而实现多种应用，主要应用于影视动画、游戏开发、虚拟现实、自动驾驶等领域 原理 利用深度学习模型来模拟图形学渲染的过程，实现从输入到输出的端到端映射。 神经渲染是基于数据驱动和统计推断的概率模型，对场景中的信息进行隐式的表示和学习，通过大量的数据来模拟渲染过程； 传统图形学渲染需要基于物理规律和数学模型的确定性算法，需要对场景中的几何、材质和光照等要素进行精确的描述和计算。 主要流程 「空间表示」：指将三维空间中的信息以一种适合于深度学习模型处理的方式进行编码和存储。常见的空间表示方法有体素voxel、点云point cloud、网格mesh、隐函数implicit function等。 「几何重建」：几何重建是指根据输入的二维图像或视频，恢复出三维空间中的几何结构。常见的几何重建方法有多视图立体（multi-view stereo）、结构光（structured light）、深度相机（depth camera）等。 「光照模拟」：光照模拟是指根据输入或预设的光照条件，计算出三维空间中各个位置的光强度和颜色。常见的光照模拟方法有光线追踪（ray tracing）、光线投射（ray casting）、辐射度（radiosity）等。 「视觉合成」：视觉合成是指根据给定或期望的视点位置，生成出对应视角下的二维图像或视频。常见的视觉合成方法有纹理映射（texture mapping）、着色器（shader）、后处理（post-processing）等。 主要特点 「高质量」：生成高分辨率、高真实度、高一致性的图像，从而达到与真实世界或传统图形学渲染相媲美甚至超越的效果。 「高效率」：利用深度学习模型的并行计算和近似推断的能力，大大降低图像合成和渲染的时间和空间复杂度。 「高灵活性」：根据用户的需求和喜好，对图像进行多样化的操控、变换和编辑，实现个性化和创意化的图像生成。神经渲染的深度生成模型 可能用到的模型 「变分自编码器（VAE）」：基于概率图模型的生成模型，由编码器和解码器两部分组成，编码器将输入数据映射到一个潜在空间中的随机变量，解码器将潜在变量映射回输出数据。通过最大化输入数据和输出数据之间的条件对数似然，以及最小化潜在变量和先验分布之间的散度，来学习数据的潜在分布和特征。可以用于神经渲染中的语义图像合成与操控，如根据用户给定的语义标签或草图，生成对应的真实图像，并且对图像中的内容进行添加、删除、移动、替换等操作。 「生成对抗网络（GAN）」：基于博弈论的生成模型，由生成器和判别器两部分组成，生成器将随机噪声或条件输入映射到输出数据，判别器将输入数据判断为真实或伪造。通过最小化生成器和判别器之间的对抗损失，来学习数据的潜在分布和特征。可以用于神经渲染中的目标和场景的新视角合成，如根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 「自回归模型（AR）」：基于链式法则的生成模型，它将输出数据分解为一系列条件概率分布，每个分布依赖于之前生成的数据。通过最大化输出数据的联合对数似然，来学习数据的潜在分布和特征，用于神经渲染中的自由视点视频合成，如根据用户给定的视频序列，生成任意视点下的视频，并且保持视频中的动态物体和背景的运动和连贯性不变。 图形学知识 「光线追踪」：基于物理光学原理的渲染技术，它通过模拟光线从视点出发，在三维空间中与物体表面发生反射、折射、散射等过程，从而计算出每个像素点的颜色和亮度。光线追踪可以用于神经渲染中提供真实感强烈的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中光照条件变化的约束和指导。 「光照模型」：基于数学公式的渲染技术，它通过描述光源、物体表面和观察者之间的光照关系，从而计算出每个像素点的颜色和亮度。光照模型可以用于神经渲染中提供不同复杂度和效果的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中材质和纹理变化的约束和指导。 「几何变换」：基于线性代数的渲染技术，它通过对三维空间中的物体进行平移、旋转、缩放等操作，从而改变物体的位置、方向和大小。几何变换可以用于神经渲染中提供不同视角和姿态的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中几何结构变化的约束和指导。 光栅化 可能用到的端到端训练方式 「监督学习」：基于标注数据的训练方式，它通过给定输入数据和期望输出数据之间的对应关系，来训练深度生成模型。可以用于神经渲染中提供高质量和高精度的图像合成和渲染效果，但是需要大量的标注数据和计算资源。 「无监督学习」：基于无标注数据的训练方式，它通过利用输入数据或输出数据本身的统计特征或结构信息，来训练深度生成模型。可以用于神经渲染中提供高效率和高灵活性的图像合成和渲染效果，但是需要复杂的模型设计和优化方法。 「弱监督学习」：介于监督学习和无监督学习之间的训练方式，它通过利用输入数据或输出数据之间的部分或隐含的对应关系，来训练深度生成模型。可以用于神经渲染中提供高质量、高效率和高灵活性的图像合成和渲染效果，但是需要合适的先验知识和约束条件。 神经渲染的应用领域 语义图像合成与操控应用的例子 「SPADE」：基于GAN的语义图像合成方法，它通过使用空间自适应归一化（Spatially-Adaptive Normalization）层，将语义标签图作为生成器的输入，并在每个卷积层中根据语义标签图调整特征图的归一化参数，从而实现了对语义标签图中不同区域内容的精确控制。它能够根据用户给定的任意语义标签图，生成逼真且多样化的真实图像，并且能够对图像中的内容进行添加、删除、移动、替换等操作。 「GauGAN」：基于SPADE改进的语义图像合成方法，它通过使用自注意力机制（Self-Attention Mechanism）和多尺度判别器（Multi-Scale Discriminator），增强了生成器的感知能力和判别器的区分能力，从而实现了对语义标签图中细节和全局的更好的生成和判断。它能够根据用户给定的任意草图，生成逼真且多样化的真实图像，并且能够对图像中的内容进行添加、删除、移动、替换等操作。 目标场景新视角合成应用的例子 「NeRF」：基于隐函数的新视角合成方法，它通过使用一个深度神经网络，将三维空间中的每个位置映射到一个颜色和不透明度的值，从而隐式地表示一个连续的三维场景。它能够根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 「NSVF」：基于体素的新视角合成方法，它通过使用一个稀疏体素网格，将三维空间中的每个体素映射到一个颜色和不透明度的值，从而显式地表示一个离散的三维场景。它能够根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 自由视点视频合成应用的例子 「Neural Volumes」：基于体素和光场的自由视点视频合成方法，它通过使用一个时变体素网格，将三维空间中每个体素映射到一个颜色和不透明度的值，并且使用一个光场编码器，将每个体素进一步映射到一个光线方向相关的颜色和不透明度的值，从而表示一个动态且具有视差效果的三维场景。Neural Volumes能够根据用户给定的视频序列，生成任意视点下的视频，并且保持视频中的动态物体和背景的运动和连贯性不变。 「Relightables」：基于神经网络和光场的学习重新打光方法，它通过使用一个神经网络，将三维空间中的每个位置映射到一个颜色和不透明度的值，并且使用一个光场编码器，将每个位置进一步映射到一个光照相关的颜色和不透明度的值，从而表示一个具有光照信息的三维场景。Relightables能够根据用户给定的目标或场景以及期望的光照条件，生成重新打光后的图像，并且保持目标或场景的材质和纹理不变。 「Neural Relighting」：基于GAN和光照模型的学习重新打光方法，它通过使用一个生成器，将输入图像和期望的光照条件映射到输出图像，并且使用一个判别器，将输出图像和真实图像进行对比。Neural Relighting能够根据用户给定的目标或场景以及期望的光照条件，生成重新打光后的图像，并且保持目标或场景的材质和纹理不变。 人体重建渲染应用的例子 「Neural Body」：基于隐函数和自注意力机制的人体重建渲染方法，它通过使用一个时变隐函数，将三维空间中的每个位置映射到一个颜色和不透明度的值，并且使用一个自注意力机制，将每个位置进一步映射到一个视角相关的颜色和不透明度的值，从而表示一个动态且具有视差效果的人体模型。Neural Body能够根据用户给定的人体图片或视频，生成人体的三维模型，并且能够对人体进行姿态、表情、服装等属性的修改和变换。 「Neural Human」：基于GAN和几何变换的人体重建渲染方法，它通过使用一个生成器，将输入图片或视频中的人体分割、关键点、姿态等信息映射到输出图片或视频，并且使用一个判别器，将输出图片或视频和真实图片或视频进行对比。Neural Human能够根据用户给定的人体图片或视频，生成人体的三维模型，并且能够对人体进行姿态、表情、服装等属性的修改和变换。 神经渲染面临的挑战 技术上面临的挑战： 「真实性和一致性」：神经渲染需要生成与真实世界或传统图形学渲染相媲美甚至超越的图像合成和渲染效果，这需要深度生成模型能够捕捉到数据中的复杂和细微的特征和规律，以及图形学知识能够提供有效和准确的约束和指导。此外，神经渲染还需要保证在不同视角、光照、姿态等条件下，生成的图像具有一致性和连贯性，这需要深度生成模型能够处理数据中的多样性和变化性，以及图形学知识能够提供稳定和可靠的转换和映射。 「复杂性和动态性」：神经渲染需要处理复杂和动态的场景，如多个物体、多种材质、多个光源、多个运动等，这需要深度生成模型能够表示和生成高维度和高分辨率的数据，以及图形学知识能够模拟和计算复杂的物理过程和效果。此外，神经渲染还需要适应用户的需求和喜好，对图像进行多样化的操控、变换和编辑，这需要深度生成模型能够响应和反馈用户的输入，以及图形学知识能够支持和实现用户的操作。 「开销和资源」：神经渲染需要消耗大量的数据、计算、内存等资源，这需要深度生成模型能够有效地利用和优化资源的使用，以及图形学知识能够简化和加速资源的处理。此外，神经渲染还需要考虑用户的体验和满意度，对图像进行实时或近实时的合成和渲染，这需要深度生成模型能够快速地训练和推理，以及图形学知识能够并行地渲染和显示。 应用上面临的挑战： 「质量和可信度」：神经渲染需要保证生成的图像具有高质量和高可信度，这需要对图像进行有效的评估和保证，如使用客观的指标和标准，如峰值信噪比（PSNR）、结构相似性（SSIM）、感知损失（Perceptual Loss）等，来衡量图像的真实性、一致性、清晰度等；或使用主观的方法和手段，如使用人类评估员或用户反馈，来衡量图像的美观性、满意度、偏好等。 「需求和反馈」：神经渲染需要满足用户的需求和喜好，这需要对用户进行有效的分析和理解，如使用用户画像（User Profile）、用户行为（User Behavior）、用户情感（User Emotion）等，来获取用户的基本信息、兴趣爱好、情绪状态等；或使用用户交互（User Interaction）、用户反馈（User Feedback）、用户评价（User Evaluation）等，来获取用户的输入输出、意见建议、评分评价等。 「隐私和版权」：神经渲染需要保护用户的隐私和版权，这需要对数据进行有效的管理和保护，如使用加密（Encryption）、哈希（Hashing）、水印（Watermarking）等，来防止数据被窃取、篡改、泄露等；或使用授权（Authorization）、认证（Authentication）、审计（Audit）等，来防止数据被滥用、侵权、盗用等。 神经渲染是一种将图形学与深度学习相结合的创新方法，它能够实现高质量、高效率、高灵活性的图像合成和渲染，也能够实现多种创意和应用，为图像处理和计算机视觉领域带来了新的可能性和挑战。神经渲染还有着广阔的发展前景和潜力，它可以与其他领域的技术和知识相结合，探索更多的应用场景和领域，促进社会和经济的进步和发展。","link":"/2024/06/11/%E7%A5%9E%E7%BB%8F%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%9B%BE%E5%BD%A2%E5%AD%A6%20+%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"鲲鹏数学库limb精度库 项目文档及部分命令","text":"编译命令 icc -fp-model precise -no-ftz -g filename.cpp -o filename 生成可执行文件 文件 IDA Pro v7.7版本：https://www.52pojie.cn/thread-1640829-1-1.html 类似于IDApro的可以转伪C代码的软件ghidra，https://github.com/NationalSecurityAgency/ghidra/releases 需要java 17 y0f在两个工具上的表现，具有较大差异性，可以参考两者的共性和差异性分析局部代码的实际作用 https://www.cnblogs.com/HDK2016/p/10506083.htmlIEEE 754浮点的存储定义，是一些基本原理在涉及7F和FF开头的NaN和INF两类极端情况值得参考 Linux下编辑、编译、调试命令总结——gcc和gdb描述 Linux常用（实用）命令大全 [C] C语言中的nan和inf使用","link":"/2023/10/30/%E9%B2%B2%E9%B9%8F%E6%95%B0%E5%AD%A6%E5%BA%93limb%E7%B2%BE%E5%BA%A6%E5%BA%93%20%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E5%8F%8A%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"学术","slug":"学术","link":"/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Kunpeng","slug":"Kunpeng","link":"/tags/Kunpeng/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Games101","slug":"Games101","link":"/tags/Games101/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","link":"/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"学术","slug":"学术","link":"/categories/%E5%AD%A6%E6%9C%AF/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Kunpeng","slug":"Kunpeng","link":"/categories/Kunpeng/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"3DGS","slug":"学术/3DGS","link":"/categories/%E5%AD%A6%E6%9C%AF/3DGS/"},{"name":"三维重建","slug":"学术/三维重建","link":"/categories/%E5%AD%A6%E6%9C%AF/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"},{"name":"命令","slug":"学术/命令","link":"/categories/%E5%AD%A6%E6%9C%AF/%E5%91%BD%E4%BB%A4/"},{"name":"NeRF","slug":"学术/NeRF","link":"/categories/%E5%AD%A6%E6%9C%AF/NeRF/"},{"name":"Limb","slug":"Kunpeng/Limb","link":"/categories/Kunpeng/Limb/"},{"name":"App","slug":"Linux/App","link":"/categories/Linux/App/"},{"name":"Game","slug":"Game","link":"/categories/Game/"},{"name":"Games101","slug":"Game/Games101","link":"/categories/Game/Games101/"}],"pages":[{"title":"关于作者","text":"这里是 骨頭 的博客访客你好，博主是一名计算机系普通的研究生，研究方向是三维重建，参与过华为鲲鹏众智计划（加速库相关），同时也对昇腾（CANN算子)及华为云社区有一定了解。 这个博客当前主要是用来记录博主自己的学习情况，上传了一部分可供分享的学习笔记，大家对于感兴趣的内容也可以自行查看，如有疑问可通过邮箱或QQ与我联系。 博主当前的主要学习方向为Linux应用及驱动开发，同时在对新能源汽车和人形机器人两个行业进行深入了解，期望硕士毕业之后在汽车电子或人形机器人行业内工作，如有志同道合的朋友想一起报团学习也可与我联系！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}