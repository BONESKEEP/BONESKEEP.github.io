{"posts":[{"title":"Leetcode Hot100 No.11 盛最多水的容器","text":"盛最多水的容器 双指针 2024.12.02 双指针、C++ Problem: 11. 盛最多水的容器 思路 双指针法 问题分析：即求解两条线与x轴围成的矩形的面积最大值问题。 细节： （1）面积S = 长度L * 宽度W （2）长度L = 两条线的x值之差 （3）宽度W = min（两条线的height） 解题过程 暴力解：两个循环，首先让第一个指针指向第一个元素，第二个指针指向下一个元素；外部循环控制第一条线的位置，每轮循环后更新两个指针的地址；内部循环控制第二条线的位置，在内部循环进行S的计算并更新最大值标志，每轮循环后更新第二个指针的地址。 最优解：单个循环，首先让第一个指针指向第一个元素，第二个指针指向第二个元素，在循环内计算S并更新最大值标志，每轮循环后将短线的指针移动（第一个指针右移或第二个指针左移），直到两个指针相遇。 复杂度 时间复杂度: 暴力解O(n) | 最优解O(n^2) 空间复杂度: O(1) Code 123456789101112131415161718192021222324252627282930313233class Solution {public: int cal_S(int L, int W) { // 计算面积S = L * W,并返回S return L * W; } int maxArea(vector&lt;int&gt;&amp; height) { int n = height.size(); if(2 &gt; n || n &gt; 10e5) return -1; int max_S = 0; int tmp_S = 0; int L = 0; int W = 0; vector&lt;int&gt;::iterator iter1 = height.begin(); vector&lt;int&gt;::iterator iter2 = height.end() - 1; while(iter1 != iter2){ L = iter2 - iter1; W = min(*iter2,*iter1); tmp_S = cal_S(L,W); if(tmp_S &gt; max_S) max_S = tmp_S; if(*iter1 &lt; *iter2){ iter1++; }else{ --iter2; } } return max_S; }};","link":"/2024/12/02/2024-12-04-Leetcode-Hot100-No.11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"Leetcode Hot100 No.121 买卖股票的最佳时机 动态规划","text":"买卖股票的最佳时机 动态规划 动态规划、C++ Problem: 121. 买卖股票的最佳时机 思路 双循环遍历 细节： （1）买入价格 &lt; 卖出价格 解题过程 暴力解：很简单，外层循环从开头的元素开始买入，内层循环找符合条件的卖出价格，更新最大利润，不符合条件就从下一个元素开始买入。 复杂度 时间复杂度: 暴力解O(n^2) 空间复杂度: O(1) Code 123456789101112131415161718192021class easySolution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { vector&lt;int&gt;::iterator buy = prices.begin(); vector&lt;int&gt;::iterator sell = buy + 1; int tmp, max_profit = 0; while(buy != prices.end() - 1){ while(*buy &lt; *sell){ tmp = *sell - *buy; if(max_profit &lt; tmp) max_profit = tmp; sell++; if(sell == prices.end()) break; } buy++; sell = buy + 1; } return max_profit; }}; 思路 双循环遍历 细节： （1）买入价格 &lt; 卖出价格 （2）维持两个动态变量 最小买入价格min_price 和 最大利润max_profit 解题过程 最优解：动态规划，动态维护最小买入价格和最大利润，一次遍历。 复杂度 时间复杂度: 最优解O(n) 空间复杂度: O(1) Code 1234567891011121314class perfectSolution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int max_profit = 0; int min_price = 10e9; for(int price: prices){ max_profit = max(max_profit, price - min_price); min_price = min(price, min_price); } return max_profit; }};","link":"/2024/12/04/2024-12-04-Leetcode-Hot100-No.121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"Leetcode Hot100 No.15 三数之和","text":"15.三数之和 问题降维-&gt;双指针 双指针、C++ Problem: 15. 三数之和 思路 （1）通过排序避免重复元素 （2）先确定第一个数，此时寻找第二个和第三个数变为两数之和，看第二个和第三个数之和与第一个数相加是否为0 （3）最终返回的是为存储多个三元组的数组 解题过程 如代码注释所示 复杂度 时间复杂度: 排序O(nlogn) 搜索结果O(n^2) 空间复杂度: O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution {public: vector&lt;vector&lt;int&gt;&gt; twoSum(vector&lt;int&gt;&amp; nums, int start, int end, int target){ vector&lt;vector&lt;int&gt;&gt; answer;// 存储两数之和的结果 // 双指针法确定符合条件的两数之和 star为首元素索引 end为尾元素索引 while(start &lt; end){ // 存储两数之和 int sum = nums[start] + nums[end]; // 判断两数之和加目标值（之前确定的第一个数字）是否为0 if(sum + target == 0){ // 如果为0 则将两个数字和目标值加入result数组 vector&lt;int&gt; result; result.push_back(target); result.push_back(nums[start]); result.push_back(nums[end]); // 将结果数组(三元组）加入答案数组 answer.push_back(result); // 在找到两数之后 start和end要同时移动 // 在移动之前 避免重复的值 while(start &lt; end &amp;&amp; nums[start] == nums[start + 1]){ start++;// 遇到重复值 多移动一次 } start++; while(start &lt; end &amp;&amp; nums[end] == nums[end - 1]){ end--; } end--; }else if(sum + target &lt; 0){ // 如果两数之和加目标值小于0 相当于不够大 // 此时start向右移动 nums[start]会增大（递增排序） // 则sum增大 start++; }else{ // 反之end向左移动 nums[end]减小 sum减小 end--; } } return answer; } vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; answer;// 存储三数之和的结果 // 先对数组排序 避免重复元素 sort(nums.begin(), nums.end()); // 单循环确定第一个数字 此时三数之和降级为两数之和 for(int i=0; i&lt;nums.size(); i++){ // 跳过重复的元素 if(i&gt;0 &amp;&amp; nums[i]==nums[i-1]) continue; // 使用双指针法解决两数之和 // 从i+1开始到size-1结束 当前选择的数字为nums[i] auto result = twoSum(nums,i+1,nums.size()-1,nums[i]); // 将确定的第一个数字和twoSum中找到的第二个和第三个数字加入结果数组 // 在answer.end()开始插入，result.begin()和result.end()按范围插入 answer.insert(answer.end(),result.begin(),result.end()); } return answer; }};","link":"/2024/12/06/2024-12-06-Leetcode-Hot100-No.15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"Leetcode Hot100 No.73 矩阵置零","text":"73.矩阵置零 标记数组 矩阵、标记数组、C++ Problem: 73. 矩阵置零 思路 1.暴力法 定义两个数组：行数组和列数组，用来记录当前行或当前列中是否有0元素，如果有0元素，则将标记数组的行值或列值设为true，然后遍历整个数组，根据标记数组的情况，处理每一行和每一列的值，将其置为0。空间复杂度为m+n。 2.优化法 对于暴力解中的两个标记数组，直接用矩阵的第一行和第一列来代替，但是对于第一行和第一列中是否有0元素，则额外定义两个标记变量来确定，此时会将空间复杂度降为O(1)。 （1）定义两个标记变量 （2）遍历第一行和第一列，看其中是否含有0元素，如果有0，则将标记变量置为true （3）遍历除第一行和第一列之外的矩阵元素，判断当前元素是否为0，如果为0，则将当前元素对应的第一行和第一列的值设为0（根据其他行列元素设置第一行和第一列元素） （4）再次遍历除第一行和第一列之外的矩阵元素，对于当前元素，判断其当前行或列的第一个元素是否为0，如果为0，则表示当前行或列含有0元素，则处理当前元素为0（根据第一行和第一列元素处理其他行列元素） （5）判断两个标记变量，如果标记变量为true，则表示第一行或第一列中有0，则处理第一行或第一列的元素为0（根据两个标记变量处理第一行和第一列的元素） 解题过程 具体看注释 复杂度 时间复杂度: O(mn) 空间复杂度: O(m+n) / O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Solution {public: // 1.记录行和列标记 空间复杂度为O(m+n) void EASYsetZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 给定一个m x n的二维数组 // 思想：循环遍历每行和每列，只要遇到0元素就记录此行或列的坐标，这样最多会记录m+n个坐标，空间复杂度为m+n int m = matrix.size();// 记录行数 int n = matrix[0].size();// 记录列数 // 声明两个数组存储行和列的标记 vector&lt;int&gt; row(m), col(n); // 遍历行和列，遇到0元素就更新标记为true for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(!matrix[i][j]){ row[i] = col[j] = true; } } } // 对每个记录的坐标，把它们的行和列都设为0 for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++){ if(row[i] || col[j]){ matrix[i][j] = 0; } } } } // 2.用矩阵的第一行和第一列代替两个标记数组，而第一行和第一列的处理使用两个额外的标记量记录 空间复杂度为O(1) void HARDsetZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { // 额外使用两个标记变量分别记录第一行和第一列是否原本包含0 int m = matrix.size();// 记录行数 int n = matrix[0].size();// 记录列数 int flag_col0 = false, flag_row0 = false;// 两个标记变量 // 遍历每行，判断每行的第一个元素是否为0，即判断第一列是否含有0 for(int i=0;i&lt;m;i++){ if(!matrix[i][0]){ flag_col0 = true;// 如果有0，则将列标记置为true } } // 判断第一行是否含有0 for(int j=0;j&lt;n;j++){ if(!matrix[0][j]){ flag_row0 = true; } } // 遍历除了第一行和第一列的所有元素 for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ // 判断是否有0 if(!matrix[i][j]){ // 如果有0，则将当前行和列的第一个元素设为0 matrix[i][0] = matrix[0][j] = 0; } } } // 遍历除了第一行和第一列的所有元素 for(int i=1;i&lt;m;i++){ for(int j=1;j&lt;n;j++){ // 判断当前行或列的第一个元素是否为0 if(!matrix[i][0] || !matrix[0][j]){ // 如果为0，则将当前行列坐标设为0 matrix[i][j] = 0; } } } // 判断列标记是否为true if(flag_col0){ // 如果为true，即第一列含有0元素 // 则处理第一列 for(int i=0;i&lt;m;i++){ matrix[i][0] = 0; } } // 判断行标记是否为true if(flag_row0){ // 如果为true，即第一行含有0元素 // 则处理第一行 for(int j=0;j&lt;n;j++){ matrix[0][j] = 0; } } }};","link":"/2024/12/08/2024-12-08-Leetcode-Hot100-No.73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"},{"title":"Leetcode Hot100 No.53 最大子数组和","text":"53.最大子数组和 贪心/动态规划 动态规划、数组、C++ Problem: 53. 最大子数组和 思路 设f(i)是直到第i个数为止的最大子数组和，且f(i)=max(f(i-1)+nums[i], nums[i])，nums[i]为当前数的值，f(i-1)为第i个数之前存储的最大子数组和，动态维护这个f(i)，如果当前数的值更大，则说明前面的子数组不够大，丢弃它，把当前数作为新的子数组；否则，说明子数组够大，继续判断下一个数。 解题过程 如代码注释所示 复杂度 时间复杂度: O(n) 空间复杂度: O(1) Code 1234567891011121314151617class Solution {public: int maxSubArray(vector&lt;int&gt;&amp; nums) { // 存储最大和 初始为第一个数 int maxSum = nums[0]; // 存储前一个子数组的最大和 int pre = 0; for(int i=0;i&lt;nums.size();i++){ // 比较前一个子数组+当前数 与当前数的大小，如果当前数更大，则子数组的头元素更新 // 动态维护了pre pre = max(pre + nums[i], nums[i]); // 更新最大和 maxSum = max(maxSum, pre); } return maxSum; }};","link":"/2024/12/07/2024-12-07-Leetcode-Hot100-No.53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"},{"title":"Leetcode Hot100 No.198 打家劫舍","text":"198.打家劫舍 动态规划+滚动数组 动态规划、滚动数组、C++ Problem: 198.打家劫舍 思路 动态规划+滚动数组 推理递推公式 解题过程 具体看注释 复杂度 时间复杂度: O(n) 空间复杂度: O(1) Code 12345678910111213141516171819202122232425262728293031class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { // 推导递推公式： // Sn = // (1)n=1, H1 // (2)n=2, max(S0,H1) // (3)n&gt;2, max(Sn-1, Sn-2 + Hn) // 其中，Hi表示第i间房的金额，Si表示前i间房屋能获得的最大金额 int n = nums.size(); if(n==0) return 0; // 特殊情况1 if(n==1) return nums[0]; // 定义数组存储中间值 // 将states初始化为n个元素，a并赋初值为0 维护n个值来存储中间变量 // vector&lt;int&gt; states(n,0); // 但其实可以只维护两个值即可 使用滚动数组 int first = nums[0]; int second = max(first, nums[1]); // states[0] = nums[0]; // states[1] = max(states[0], nums[1]); // 对前3间房屋开始循环计算 for(int i=2; i&lt;n; i++){ // states[i] = max(states[i-1], states[i-2] + nums[i]); int temp = second; second = max(second, first + nums[i]); first = temp; } return second;// 返回前n个房屋的最大金额 }};","link":"/2024/12/23/2024-12-23-Leetcode-Hot100-No.198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"},{"title":"Leetcode Hot100 No.56 合并区间","text":"56.合并区间 排序巧解 排序、数组、C++ Problem: 56.合并区间 思路 先按数组的第一列进行排序，所得到有序区间； 使用一个数组merged存储答案， 先把第一个区间加入merged, 再按顺序处理之后的区间，判断当前区间的左端点是否大于merged数组最后一个区间的右端点： 如果大于，则说明区间不重叠，直接将当前区间加入merged数组， 否则，说明区间重叠，返回（当前区间右端点 与 merged数组最后一个区间的右端点）二者中较大值用于更新merged数组最后一个区间的右端点。 解题过程 具体看注释 复杂度 时间复杂度: 排序O(nlogN) 处理区间 O(n) 空间复杂度: O(n) Code 12345678910111213141516171819202122232425class Solution {public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) { if(intervals.size()==0) return {}; // 按第一列排序 sort(intervals.begin(),intervals.end()); // 用数组merged存储合并后的数组 vector&lt;vector&lt;int&gt;&gt; merged; // 将第一个区间加入 // merged.push_back(intervals[0]); for(int i=0; i&lt;intervals.size(); ++i){ // 按顺序依次考虑之后的每个区间 int L = intervals[i][0], R = intervals[i][1]; if(!merged.size() || merged.back()[1] &lt; L){ // 如果merged为空 或者 当前区间的左端点大于merged数组中最后一个区间的右端点时 // 将当前区间加入merged merged.push_back({L,R}); }else{ // 否则，说明区间重叠了，返回当前区间的右端点更新数组merged中最后一个区间的右端点，取二者较大值 merged.back()[1] = max(R, merged.back()[1]); } } return merged; }};","link":"/2024/12/14/2024-12-14-Leetcode-Hot100-No.56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"},{"title":"3D Gaussian Splatting 论文笔记","text":"3D Gaussian Splatting 论文笔记 3DGS：来自2023年8月在SIGGRAPH的best paper Title：3D Gaussian Splatting for Real-Time Radiance Field Rendering Paper:https://arxiv.org/pdf/2003.08934.pdf Code:https://github.com/grapgdeco-inria/gaussian-splatting 特点：由椭圆拼接组成的世界 成果:1)1080p(≥30fps)实时渲染 2)现有公开数据集 实时渲染达到sota(State of the Art)(行业顶尖)质量 3)比mipnerf360在相同质量渲染下巨量减少其训练时间 1 SfM初始化稀疏点云 先通过colmap创建出一个初始化点云（一组三维高斯分布） 通过一组照片即可进行估算 保持连续体积辐射场的理想特性，用于场景优化，同时避免了空白空间中不必要的计算 2 3D高斯椭球集的创建 2.1 位置与形状 位置信息：点云位置信息优化(x,y,z) 即高斯椭球的中心点(均值) 形状信息：高斯椭球的协方差矩阵Σ=RSSTRT 其中，R——旋转矩阵 ​ S——缩放矩阵 处理方式的几何意义：先将椭球旋转到与椭球世界平齐，然后沿着轴缩放，再旋转还原回去 上述方式优势：由于Σ不能随机初始化，能保证Σ保持半正定的性质，并且在一定程度上减少运算量 2.2 颜色与不透明度 颜色信息：点云颜色(r,g,b)——用球谐函数(拟合多项式)来表示，使得点云在不同角度呈现不同颜色，有利于提高迭代效率(代码中采用4阶) 不透明度信息：点云不透明度，密度优化α 2.3 傅里叶级数展开与基函数 球谐函数：类似看作一种多项式的拟合 （泰勒展开式） 例如f(x) = ax^3^+bx^2^+cx^1^+dx^0^是三次多项式拟合 有四个参数 将x^3^之类视作为构建多项式函数的基函数 也类似傅里叶级数的展开 分别用sin和cos作为基函数的组合 可以近似拟合不同的周期函数 也可看做将一个周期函数分解开为sin和cos这种基函数 球谐函数：一组能够代表球面上不同位置的值的基函数 阶数越高 表达能力越强 r = f(θ,φ) 球谐函数只和θ（仰角）和φ（方位角）有关，与r（半径）无关 参数量为阶数的平方 让整个球面的数据得到更为连续地表达（可理解为更加光滑 阶数越高 能表达地形状越复杂） 球谐函数用在不同角度的颜色表达 3D高斯中的点云颜色（r,g,b）用球谐函数来表示（每个值一个球谐函数） 使点云在不同角度可以呈现不同颜色 有利于提高迭代效率 代码中用4阶 参数量为n^2^ 球谐函数在一定程度上能弱化高频信息，本质上是一种有损压缩，并能将离散信息转变为连续信息，可计算梯度并进行迭代 2.4 各迭代参数的含义 位置信息：(x,y,z) 高斯的μ 中心点信息 法向量信息：(nx,ny,nz) 不同角度光照呈现的效果 貌似未使用（代码中为0） 颜色信息：代表每个高斯分布的颜色RGB的球鞋（SH）系数（f_dc_0,f_dc_1,f_dc_2）和（f_rest_0到f_rest_44） 不透明度/密度信息：opacity α 缩放矩阵：(scale_0,scale_1,scale_2)，三个方向的缩放轴，即协方差矩阵的参数 旋转矩阵：（rot_0到rot_3），使用旋转四元数（一个实部三个虚部组成）表示 3 计算机图形学投影矩阵 3D高斯协方差（缩放系数）变换是 非线性 的变换 用泰勒一阶展开公式来进行线性的近似 f(x) ≈ f(a) + f’(a)(x - a) f(x) ≈ f(a) + J(x - a) 泰勒公式扩展到三维空间 需要用到雅可比矩阵 于是有 Σ‘=JW Σ W^T^J^T^ 其中雅可比矩阵代表（直接计算得到 不迭代）表示一个多元函数在某一点的局部线性近似 4 渲染公式 和NeRF类似 NeRF： 3DGS也是通过类似point-based的渲染公式： 即通过点云中一定半径范围能影响像素的N个有序点来计算一个像素的颜色C$$C = \\sum_{i∈N}{c_iα_i}\\prod_{j=1}^{i-1}{(1-α_j)}\\其中，c_i代表当前点的颜色值\\\\alpha_i代表当前点i的不透明度（密度）值\\\\alpha_j代表i之前前面点的不透明度（密度）值\\用1-\\alpha_j，进行累乘，作为权重weight\\这代表着前面的点越透明，这个weight就越大，当前\\alpha_i的影响权重越大$$其中：影响范围用标准的球来简化计算，并分tile 16*16，一种快速的排序，CUDA并行加速，光栅化 5 loss定义 损失函数是L1和D-SSIM项：$$L = (1-\\lambda)L_1 + \\lambda L_{D-SSIM}\\\\lambda = 0.2$$ 6 基于梯度自适应改变点云的分布方式 由于刚开始的初始化点云质量不高 所以不能一直依赖 要进行优化 比如每隔个100个epoch会判断点云的分布是否合理 有两个方法： 方法一：Pruning减少伪影的出现 其中不透明度低于设置的阈值或者离相机近的一些点会进行删除 方法二：Densification过渡重构或者欠采样（算loss 基于梯度变化来判断）（高斯椭球和其理想形体差很远） ​ 方差很小（椭球形状小）–&gt;克隆高斯来适应 Under-Reconstruction ​ 方差很大（椭球形状大）–&gt;分割成两个高斯 Over-Reconstruction 7 伪代码 算法1未使用深度学习神经网络，或许可以以此入手找寻一些可以用神经网络优化参数的创新点 算法2为光栅化伪代码","link":"/2024/06/11/3D%20Gaussian%20Splatting%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"title":"Advanced in Neural Rendering 论文笔记","text":"Advanced in Neural Rendering 论文笔记 来源EuroGraphocs 的2022综述论文，2022年3月 ABSTRACT 传统上，场景的合成图像使用 渲染算法 （如光栅化或光线跟踪）生成的； 将特别定义的集合和材质属性表示作为输入。 这些输入定义了实际场景和渲染的内容，称为 场景表示 ，场景由一个或多个目标组成。 示例场景表示是具有伴随纹理的 三角网格（艺术家创建）、点云（来自深度传感器）、体网格（来自CT扫描）或 隐式曲面函数（截断符号距离场）； 使用可微分渲染的损失 从观测中 重建这样的场景表示 被称为 逆图形学或逆渲染。 神经渲染结合了图形学和机器学习的思想，创建了从真实世界观测合成图像的算法； 近年来该领域展示了 可将学习的组件 注入 渲染流水线的不同方法 这篇报告侧重于 将经典渲染原理与学习的3D场景表示（神经场景表示）相结合的方法； 关键优点是在设计上的3D一致性，从而实现了捕获场景的新视点合成等应用； 除了 处理静态场景的方法外，还介绍了用于建模 非刚体变形目标 的神经场景表示以及场景编辑和合成； 这些方法大多时 场景特定的，但也讨论了 跨目标类进行泛化的技术，并可用于生成任务； 回顾这些最先进的方法外 还概述了 使用的基本概念和定义，最后讨论了公开挑战和社会影响。 1. INTRO 传统计算机图形学可以生成高质量的可控图像，但是要基于物理定律并且场景的所有物理参数，比如 摄像机参数、照明和对象的材质都需要作为输入提供； 所以如果想要生成真实场景的可控图像，需要从现有的观测（如图像和视频）中估计这些物理属性，即逆渲染，具有挑战性，尤其是质量达到照片级时的合成图像。 图像合成——需要物理参数——需要进行观测——观测后估计（逆渲染）——达成图像合成目标 挑战性在于逆渲染具有很大的挑战性！ 所以，神经渲染出现，允许场景的紧凑（compact）表示，而且可以通过 神经网络从现有观测中学习渲染。 神经渲染的主要思想是：结合经典（基于物理的）计算机图形学的见解和深度学习的最新进展。 神经渲染的目标：以可控的方式生成照片级真实感图像，例如新视点合成、重照明、场景变形和合成等。 早期的神经绘制方法： 使用神经网络将场景参数转换为输出图像，场景参数也可以直接作为一维输入给定，或者使用经典的图形学流水线生成二维输入。 深度神经网络： 通过对真实世界场景的观察进行训练，并学习对这些场景进行 建模和渲染。 具体来说：一个网络根据输入参数、模型架构和可训练参数定义了一个函数族。使用随机梯度下降，从这空间中找到最能解释由训练损失度量的训练集的函数。 神经绘制的目的是寻找控制参数与对应的输出图像之间的映射。 可以理解为一个复杂且具有挑战性的稀疏数据插值问题。因此，类似于经典的函数拟合，神经绘制需要在欠拟合和过拟合之间进行权衡。如果网络的表征能力不足，那么得到的图像质量就会很低，找到合适的网络架构本身就是一门艺术。在神经渲染的背景下，设计正确的物理驱动的归纳偏差往往需要强大的图形背景。 这方面的一个很好的例子是最近的神经渲染技术 NeRF，该技术试图通过仅学习3D场景表示并依赖计算机图形中的渲染函数进行监督来分离建模和渲染过程。 神经辐射场（NeRF）使用多层感知器（MLP）来近似3D场景的辐射场和密度场。该学习的体表示可以使用解析可微分渲染（即体积分）从任何虚拟摄像头渲染。 对于训练，假设从多个摄像机视点观测场景。从这些训练视点，渲染估计的3D场景，并最小化渲染图像和观察图像之间的差异，根据这些观察结果训练网络。一旦训练完成，由神经网络近似的3D场景可以从新的视点进行渲染，从而实现可控合成。 与使用神经网络学习渲染函数的方法相反，NeRF在该方法中更明确地使用了计算机图形学的知识，由于（物理）归纳偏差，能够更好地概括新视图：场景密度和半径的中间3D结构化表示。因此，NeRF在3D空间中学习物理上有意义的颜色和密度值，物理激发的光线投射和体集成可以持续渲染到新视图中。 所取得的结果质量，以及方法的简单性，导致了该领域的“爆炸式”发展。已经取得了一些进步，提高了适用性，实现了可控性，动态变化场景的捕获以及训练和推理时间。 神经渲染发展非常快，在许多不同的维度上都取得了重大进展，因此对最近的方法及其应用领域进行了分类，以提供发展的简要概述。 2. Scope of This STAR 在本报告中，重点介绍了将经典渲染与可学习3D表示相结合的高级神经渲染方法（见图2）。 先前关于神经渲染的STAR报告主要集中在此范式：2D神经渲染( 2D Neural Rendering )，也称为神经细化、神经重渲染或延迟神经渲染，是基于某个2D信号（例如一个语义标签或者一个栅格化的代理几何）输入 直接映射到输出图像——神经网络被训练用于渲染，例如使用经典的渲染器生成并学习在2D中渲染场景。 本报告聚焦于此范式：3D神经渲染学习在3D中表示一个场景，并使用来自计算机图形学的固定可微的渲染方案。例如NeRF，神经网络是有监督的，以表示特定场景的形状或外观，神经表示用略传统的图形“引擎”来呈现，通过分析定义，并不是被学习的。 通过设计，底层的神经3D表示是3D一致的，并且能够控制不同的场景参数。 在本报告中，全面概述了不同的场景表示，并详细介绍了从经典渲染流水线以及机器学习中借鉴的组件基本原理。进一步关注用神经辐射场以及体渲染的方法。然而，这里忽略主要在2D屏幕空间中推理的神经渲染方法，也不包括光线跟踪图像的神经超采样和去噪方法。 3. Fundamentals of Neural Rendering 神经渲染管道从真实世界的图像中学习渲染和/或表示场景，这些图像可以是无序的图像集，也可以是结构化的多视图图像或视频。 3D神经渲染的一个关键特性是该训练过程中相机捕获过程(即,投影和图像的形成)和3D场景表示的解耦。 这种解耦有许多优点，特别是在图像(例如,对于新颖的视点合成)的合成过程中，可以获得很高的3D一致性。 为了将投影等物理过程从三维场景表示中分离出来，三维神经绘制方法依赖于计算机图形学(例如,栅格化、点散布或体积积分)中已知的图像生成模型。 这些模型受到物理学的启发，特别是发射器的光线与场景以及相机本身的相互作用。这种光传输是使用渲染方程[ Kaj86 ]来描述的。 计算机图形学领域对此渲染方程提供了多种近似。 这些近似依赖于使用的场景表示，范围从经典的栅格化到路径追踪和体积积分。 3D神经渲染利用了这些渲染方法。 下面我们将详细介绍场景表示( 3.1节)以及常用神经绘制方法中使用的渲染方法( 3.2节)。 注意，为了从真实图像中学习，场景表示和渲染方法本身都必须是可微的( 3.3节)。 3.1. 场景表示 几十年来，图形学界探索了各种表征，包括点云、隐式和参数曲面、网格和体积（见图）。 这些表示在 图形学领域有明确定义，但在当前神经渲染的文献中存在混淆，尤其是涉及到 隐式和显式曲面表示和体积表示。 通常，体表示可以表示曲面，反之亦然。 体表示存储 体特征，比如 密度、不透明度或占用率，也可以存储多维特征，如颜色或亮度。 与体表示不同，曲面表示存储目标曲面的特性。 不能用于模拟体物质，如烟雾（除非是粗略近似值）。 对于曲面和体表示，都有连续和离散的对应项（见上图）。 连续表示对于神经渲染方法特别有趣，因为它们可以提供解析梯度。 曲面表示（surface representation）有两种不同的方式——显式和隐式 在欧式空间中有显式曲面函数Sfexplicit的定义（公式3.1 3.2 3.3） 体积表示（volume representation）定义了整个空间的属性（公式3.4） 以上所有表示，各自的功能领域都可以会被限制。具体见3.1。 在神经渲染的背景下，使用神经网络来近似（比如基于MLP的函数逼近器）表面或体积表示函数的场景表示称为神经场景表示。特别的，表面和体积表示都可以扩展以存储额外的信息，如颜色或与视角相关的辐射。 3.1.1. MLPs as Universal Function Approximators 本节讨论了不同的基于MLP的函数逼近器，其构建了最近的神经曲面和体积表示的基础。 3.1.2. Representing Surfaces 本节介绍了不同曲面表示方式，如点云、网格等。 点云(Point Clouds) 点云是欧氏空间的元素集合。一个连续的曲面可以通过点云离散化，点云的每个元素代表曲面上的一个样本点( x , y , z)。对于每个点，可以存储额外的属性，如法线或颜色。 具有法线特征的点云也被称为定向点云。除了简单的点可以看成无穷小的表面面片外，还可以使用半径为(表示位于下垫面切平面上的2D圆盘)的定向点云。这种表象被称为表面元素，别名面元[ PZvBG00 ]。 它们经常被用于计算机图形学中，用于从模拟中渲染点云或粒子。这样的面元的渲染被称为抛雪球，最近的工作表明它是可微的。 使用这种可微的渲染管线，可以直接反向传播到点云位置以及伴随特征(例如,半径或颜色)。 在Neural基于点的图形学和SynSin中，可学习的特征被附加到能够存储关于实际表面的外观和形状的丰富信息的点上。 在ADOP中，这些可学习的特征由一个可以解释视图依赖效应的MLP来解释。值得注意的是，对于离散位置，也可以使用MLP来预测特征，而不是存储特定点的显式特征。 如前所述，点云是欧氏空间的元素集合，因此，除了曲面，它们还可以表示体(例如,存储额外的不透明度或密度值)。对每个点使用一个半径自然会导致一个完整的基于球的公式。 网格(Meshes) 网格。多边形网格表示曲面的分段线性逼近。特别地，三角网格和四边形网格在计算机图形学中被用作表面事实上的标准表示。 优化了图形流水线和图形加速器( GPU )，以每秒处理和光栅化数十亿个三角形。 大多数图形编辑工具使用三角形网格，这使得这种表示对于任何内容创建管道都很重要。为了与这些管线直接兼容，许多”经典”的逆向图形和神经绘制方法都使用了这种基本的曲面表示。 使用可微的渲染器，可以优化顶点位置和顶点属性(例如,颜色)，以再现一幅图像。 神经网络可以被训练来预测顶点的位置，例如，预测动态变化的曲面。而不是使用顶点属性，在三角形内存储表面属性的常用策略是纹理贴图。 2D纹理坐标是贴在网格顶点上的，它参考了纹理图像中的一个位置。利用重心插值，可以计算三角形内任意一点的纹理坐标，并利用双线性插值从纹理中检索属性。纹理的概念也被集成到了标准的图形流水线中，增加了一些额外的功能，如分级细化，它需要妥善处理纹理( c.f. ,采样定理)的采样。 延迟神经绘制( Deferred Neural Rendering )使用包含可学习的视点相关特征的纹理，即所谓的神经纹理。具体来说，一个粗网格被用作底层的3D表示，以光栅化这些神经纹理。神经网络在图像空间中解释这些光栅化的特征。注意到该网络可以是一个像素级的MLP，那么神经纹理就代表了表面辐亮度。 相对于使用离散纹理，可以使用连续纹理。纹理场的作者提出使用MLP来预测每个表面点的颜色值。在神经反射场纹理( NeRF-Tex ) 中，将NeRF的思想与使用2D神经纹理和底层3D网格的思想相结合。NeRF - Tex是基于用户定义的参数来控制外观，因此可以被艺术家编辑。 隐式曲面(Implicit Surfaces) 隐式曲面。隐式曲面将曲面定义为函数的零水平集，见公式3 。最常用的隐式曲面表示方法是符号距离函数( SDF )。这些SDF表示被用于许多使用体积融合增量重建静态或动态物体表面的3D扫描技术中。隐式曲面表示提供了许多优点，因为它们避免了定义网格模板的要求，因此能够在动态场景中表示拓扑未知或拓扑变化的物体。 上述体积融合方法使用离散(截断)的符号距离函数，即使用包含符号距离值的3D网格。Hoppe等人提出了分段线性函数来对输入曲面点样本的符号距离函数进行建模。Carr等人的开创性工作使用径向基函数网络代替。这个径向基函数网络代表了一个连续的隐式曲面函数，可以看作是第一个”神经”隐式曲面表示。 最近的神经隐式曲面表示是基于坐标的多层感知器( MLPs )，见3.1.1节。这种表示方法在神经场景的表示和渲染中得到了广泛应用。它们在[ PFS⋅19 , CZ19]中同时被提出用于形状建模，其中MLP架构用于将连续坐标映射到符号距离值。这种坐标网络表示的信号的保真度，或者说神经隐式表示，主要受限于网络的容量。因此，与上述其他表示法相比，隐式曲面在记忆效率方面具有潜在的优势，并且作为一种连续表示法，理论上可以表示无限分辨率的几何图形。 最初的建议接踵而至，产生了广泛的热情，随后有了各种针对不同侧重点的改进，包括训练方案、利用全局-局部上下文、采用特定参数化或空间分区。（创新点） 由于不需要预先定义网格模板或对象拓扑结构，神经隐式曲面非常适合对不同拓扑结构的对象进行建模。 利用反向传播可以计算输出相对于输入坐标的解析梯度。这使得除了其他几何激励的正则化器外，在梯度上实现正则化项成为可能。 这些表示可以扩展到对场景的辐亮度进行编码。这对于神经渲染是有用的，在这里我们希望场景表示能够同时编码场景的几何和外观。 3.1.3. Representing Volumes 本节介绍了不同体积表示方式，如体素网格、神经体积表示等。 体素网格( Voxel Grids ) 体素网格( Voxel Grids )。作为R^3^中的像素等价体，体素通常被用来表示体积。 它们可以存储几何占有率，或者存储具有体积效应(如透明度)的场景的密度值。 此外，场景的外观可以存储。 使用三线性插值，这些体属性可以在体素网格内的任意点访问。这种插值方法特别适用于光线投射等基于样本的绘制方法。 在存储的属性可以具有特定的语义(例如,占有率)的同时，属性也可以被学习。 西茨曼等人提出使用DeepVoxels，将特征存储在体素网格中。光线投射渲染程序后的特征的积累和解释是使用深度神经网络完成的。这些DeepVoxels可以看作是体积神经纹理，可以直接使用反向传播进行优化。 虽然基于稠密体素的表示可以快速查询，但它们的内存效率很低，并且3D CNNs可能在这些体上运行，计算量很大。 八叉树数据结构（用于描述空间的树状数据结构）可以用稀疏的方式来表示体积。八叉树上的稀疏3D卷积可以帮助缓解一些问题，但这些紧凑的数据结构不能轻易地在工作中更新。因此，它们很难融入到学习框架中。 其他减轻密集体素网格内存挑战的方法包括使用对象特定形状模板，多平面或多球体图像，它们都旨在使用稀疏近似来表示体素网格。 神经体积表征(Neural Volumetric Representations) 神经体积表征(Neural Volumetric Representations)。特征或其他感兴趣的量也可以使用神经网络来定义，类似于神经隐式曲面(见3.1.2节)。MLP网络体系结构可以用于参数化体积，与显式体素网格相比，MLP网络体系结构具有更高的存储效率。 这些表示可能仍然成本巨大，需要根据基础网络的大小进行采样，因为对于每个样本，必须计算通过网络的整个前馈。大多数方法可以粗略地分类为使用全局或局部网络。 同时使用网格和神经网络的混合表示在计算效率和内存效率之间做出了权衡。 与神经隐式曲面类似，神经体积表示允许计算解析梯度，这已被用于定义正则化项。 BACON引入了基于带限坐标的网络，学习了表面的光滑多尺度分解。 总的注释(General remark) 总的注释(General remark)： 使用基于坐标的神经网络对场景进行体积建模(如NeRF)，表面上类似于使用坐标网络对表面进行隐式建模(如在神经隐式曲面中)。 然而，类NeRF的体表示并不一定是隐式的——因为网络的输出是密度和颜色，场景的几何结构是由网络显式地，而不是隐式地参数化的。 尽管如此，这些模型在文献中仍然被称为”隐式”是很常见的，这可能是由于场景的几何形状是由神经网络（SDF文献中使用了一个不同的”隐式”定义）的**权重”隐式”**定义的。 同时注意到，这是一个与深度学习和统计社区通常使用的”隐式”不同的定义，其中**”隐式”通常是指模型的输出被隐式地定义为动态系统的固定点，其梯度使用隐函数定理计算**。 3.2. 可微图像的生成 Differentiable Image Formation 前面几节中的场景表示允许我们表示场景的3D几何和外观。 下一步，我们将描述如何通过渲染从这些场景表示中生成图像。 将三维场景渲染成二维图像平面的一般方法有两种：光线投射和栅格化，见图4。 也可以通过定义场景中的相机来计算场景的渲染图像。 大多数方法使用针孔相机，其中所有相机**光线都通过空间中的单点(焦点)**。 对于给定的相机，可以将来自相机原点的光线投射到场景中，以便计算渲染图像。 (a) 正向渲染(例如,光栅化)——通过 将三维表示投影到图像平面上 生成图像。 (b) 光线投射( Ray Casting )——通过投射观看光线，采样3D表示并累加生成图像。 上图描述： 对于显式曲面表示，曲面是直接可索引的。这使得我们可以使用前向渲染方法，将表面投影到图像平面，并相应地设置一个像素(例如,使用栅格化或点散布)。隐式表面表示和体积表示，不提供允许前向渲染的表面的直接信息，相反，从虚拟相机看到的3D空间必须采样以生成图像(例如,使用光线行进法)。 光线投射。在针孔模型中，基本截距定理可以用来描述一个点p∈R^3^在三维中如何被投影到图像平面中的正确位置q∈R^2^。 它被定义为一个非内射函数，并且很难求逆，这使得它在三维重建问题中处于核心地位。 Pinhole模型对该投影具有单一参数矩阵：本征矩阵K包含经像素尺寸归一化的焦距f = [αx , αy]，轴偏斜度γ和中心点c = [cx , cy]。利用截距定理并假设齐次坐标p′= [ x , y , z , 1]，我们发现投影坐标为q′= K · p′，有 这假设投影的中心在坐标原点，并且相机是轴对齐的。为了推广到任意相机位置，可以使用一个外部矩阵R。这个均匀的4 × 4矩阵E是由 其中R是旋转矩阵，t是平移向量，使得R · pw + t = pc，这里我们用pw表示世界坐标中的点，pc表示相机坐标中的点。R和t的这种定义在计算机视觉(例如, OpenCV使用的)中很常见，被称为”世界到世界”映射，而在计算机图形学(例如,在OpenGL中)中，类似的逆”凸轮到世界”映射更普遍。假设” worldto-cam “约定，利用齐次坐标，我们可以写出pw到qp的全投影为： 如果使用’ cam-to-world ‘约定，光线投射也同样方便。由于深度模糊，这些方程是非单射的，但它们非常适合于自动微分，并且可以在图像形成模型中进行端到端的优化。 为了正确地对当前的相机进行建模，还必须考虑另外一个部件：镜头。 抛开在图像形成过程中必须建模的景深或运动模糊等影响，它们会给投影函数添加失真影响。不幸的是，没有一个单一的、简单的模型来捕获所有不同的镜头效果。 标定包，如OpenCV中的标定包，通常实现最多12个畸变参数的模型。它们是通过五次多项式建模的，因此不是平凡可逆的(这是光线投射相对于点投影所需要的)。 更现代的摄像机标定方法使用了更多的参数，并达到了更高的精度，并且可以实现可逆和可微。 光栅化/栅格化 Rasterization 光栅化。光线投射的一种替代方法是将几何图元栅格化。 该技术并不试图模仿真实世界的图像形成过程，而是利用物体的几何特性来快速生成图像。 它主要用于网格，由顶点v和面f的集合描述，连接顶点的三元组或四元组来定义曲面。 一个基本的见解是，3D中的几何操作可以单独处理顶点：例如，我们可以使用相同的外部矩阵E将世界中的每个点变换到相机坐标系中。 经过这种变换后，可以剔除视锥体之外的点或法线方向错误的点，以减少下一步需要处理的点和面的数量。 通过使用如上所述的内蕴矩阵K，可以再次平凡地找到投影到图像坐标的其余点的位置。 利用人脸信息可以对人脸图元进行深度插值，最上层的人脸可以存储在一个零缓冲器中。 这种实现投影的方式往往比光线投射更快：它主要根据场景中可见顶点的数量进行缩放，而光线投射则根据像素的数量和要与之相交的图元的数量进行缩放。然而，使用(例如,光影、阴影、反射等)来捕获某些效应是比较困难的。它可以通过”软”栅格化使其具有可微性。例如，在[ LLCL19 , RRN⋅20]中已经实现。 3.2.1. 曲面渲染 Surface Rendering 点云渲染 Point Cloud Rendering 点云渲染。点云是连续曲面或体积的离散样本。 点云渲染对应于从不规则分布的离散样本中重建连续信号，例如连续表面的出现，然后在每个像素位置的图像空间中重采样重建信号。 这个过程可以通过两种不同的方式来完成： 第一种方法基于经典信号处理理论，可以看作是一个”软”点抛雪球（Splatting 喷溅）(类似于下面网格渲染部分中的软光栅化器)。它首先利用连续的局部重构核r ( · )构造连续信号，即f =∑f i ( pi )。 本质上，这种方法相当于将离散样本与一些局部确定性模糊核混合，例如EWA抛雪球，它是一种空间变化的重构核，旨在最小化混叠。在神经绘制中，离散样本可以存储一些可学习的特征。相应地，前述步骤有效地将个体特征投影并融合到2D特征图中。 如果特征具有预定义的语义(例如,颜色,法线)，可以使用固定的着色函数或BRDF来生成最终的图像。 如果特征是学习到的神经描述符，则部署2D神经网络将2D特征图转换为RGB图像。 最近采用这种方法的神经点绘制方法包括Sin Syn和Pulsar。为了性能的原因，他们在混合步骤中使用空间不变和各向同性的核。虽然这些简化的内核会导致渲染伪影，如空洞，模糊边缘和锯齿，但这些伪影可以在神经着色步骤中得到补偿，并且在Pulsar的情况下，可以通过优化半径来实现。[ KPLD21 ]还使用了相机选择和概率深度测试的策略，并能够在该框架中处理IBR、风格化和协调。 除了软点绘制方法外，还可以使用传统的OpenGL或directx技术的点渲染器。在这里，每个点被投影到单个像素(或小面积的像素)，从而得到一个稀疏的特征图。可以使用深度神经网络直接在图像空间中重构信号。注意，这种朴素的渲染方法不提供关于点位置p的梯度，只允许区分渲染函数w . r . t . (神经)特征。相比之下，软点散布方法通过重构核r ( p )提供点位置梯度。 然而，即使在这种情况下，梯度在空间上也被限制在局部重建的支持范围内。[ YSW※19b ]通过使用有限差分来近似梯度来解决这个问题，并成功地将渲染器应用于表面去噪、风格化和多视图形状重建。这一思想在文献[ RFS21b ]中被采用，以联合优化几何和相机姿态来进行新的视图合成。 网格渲染 Mesh Rendering 有许多通用的渲染器允许网格被栅格化或以可微的方式渲染。在可微网格栅格化中，Loper和Black开发了一个可微的渲染框架，称为OpenDR，它近似一个主要的渲染器，并通过自动微分来计算梯度。 神经网格渲染器( NMR ) 使用可见度变化的手工函数来近似光栅化操作的向后梯度。 文献[ LTJ18 ]提出了无固定职业的摄影师，一种利用图像滤波器进行网格几何处理的解析可微渲染器。彼得森等人[ PBDCO19 ]提出了Pix2Vex，一种通过邻近三角形的软混合方案的C∞可微渲染器，[ LLCL19 ]提出了Soft光栅化程序，它渲染和聚合网格三角形的概率映射，允许梯度从渲染的像素流向被遮挡的和远程的顶点。虽然大多数栅格化器只支持基于直接光照的渲染，但[ LHL⋅21 ]也支持软阴影的可微渲染。在基于物理的绘制领域，[ LADL18a ]和[ ALKN19 ]引入了可微分的光线示踪器，实现了基于物理的绘制效果的可微分性，处理了相机位置、光照和纹理。此外，Mitsuba 2 [ NDVZJ19 ]和Taichi [ HLA * 19 , HAL * 20]是通用的基于物理的渲染器，通过自动区分支持可微的网格渲染，以及其他许多图形技术。 神经隐式曲面渲染 Neural Implicit Surface Rendering 当输入观测为2D图像时，实现隐式曲面的网络不仅产生几何相关的量，即符号距离值，而且产生外观相关的量。 一个隐式可微渲染器可以通过首先使用神经隐式函数的几何分支找到一条观察光线与曲面的交点，然后从外观分支获得该点的RGB值来实现。曲面求交的搜索通常是基于球面追踪算法[ Har96 ]的一些变体。 球面跟踪在视线方向上从相机中心对三维空间进行迭代采样，直到到达表面。球面追踪是一种优化的射线追踪方法，通过前一位置采样的SDF值来调整步长，但这种迭代策略仍然会带来计算上的开销。泷川等人[ TLY※21 ]通过将光线跟踪算法与稀疏八叉树数据结构相适应，提高了渲染性能。 在二维监督的联合几何和外观估计的隐式曲面渲染中，一个常见的问题是几何和外观的模糊性。在[ NMOG20 , YKM * 20 , KJJ * 21 , BKW21]中，从2D图像中提取前景掩码，为几何分支提供额外的监督信号。最近，[ OPG21 ]和[ YGKL21b ]通过将表面函数转化为体渲染公式(下面介绍)来解决这个问题；另一方面[ ZYQ21 ]利用现成的深度估计方法生成伪地面真值符号距离值来辅助几何分支的训练。 3.2.2 体积渲染 Volumetric Rendering 体积渲染是基于光线投射的，并且已经被证明在神经渲染，特别是在从多视图输入数据中学习场景表示方面是有效的。具体来说，这个场景表示为体积密度或占有率的连续场，而不是硬表面的集合。 这意味着光线在空间中的每一点都有一定的概率与场景内容发生交互，而不是二进制的相交事件。 这种连续模型可以很好地作为机器学习管道的可微渲染框架，这些机器学习管道严重依赖良好行为梯度的存在进行优化。 虽然完全通用的体积渲染确实考虑了光线可以从一个体粒子反射出去的”散射”事件，但我们将这一总结限制在用于视图合成的神经体积渲染方法常用的基本模型中，它只考虑了光线被一个体粒子发射或阻挡的”发射”和”吸收”事件。 给定一组像素坐标，我们可以使用先前描述的相机模型计算通过原点p和方向ωo的3D空间的相应光线。沿着这条射线的入射光可以用一个简单的发射/吸收模型定义为 其中σ为点的体积密度，Le为点和方向的出射光，透射率T为嵌套积分表达式 密度表示光线在特定点与场景的体积”介质”相互作用的微分概率，而透射率描述了光线从点p + tωo回到相机时被衰减的程度。 这些表达式只能针对简单的密度场和色场进行解析计算。在实际应用中，我们通常用求积来近似积分，其中σ和Le被假设为在N个区间{ [ ti - 1，ti ) } ^N^i=1内的分段常数，该区间划分了射线的长度： 对于这个近似的完整推导，我们参考Max和Chen 。注意，当写成这种形式时，逼近L的表达式恰好对应于由后向前合成颜色L^(i)^e的alpha。 NeRF和相关方法使用可微体积渲染将场景表示投影到2D图像中。这使得这些方法可以在”逆向渲染”框架中使用，其中三维或更高维的场景表示是从2D图像中估计出来的。体绘制需要沿一条射线处理多个样本，每个样本都需要通过网络进行完整的前向传递。 最近的工作提出了增强数据结构、重要性采样、快速集成等策略来加快渲染速度，尽管这些方法的训练时间仍然较慢。自适应坐标网络使用多分辨率网络结构加速训练，在训练阶段通过以最优和有效的方式分配可用的网络容量来优化网络结构。 3.3. 优化 Optimization 训练神经网络的核心是非线性优化，其目的是应用训练集的约束，以获得一组神经网络权值。 因此，由神经网络逼近的函数能够拟合给定的训练数据。通常，神经网络的优化是基于梯度的；更具体地说，使用了SGD的变体，如Momentum或Adam，其中梯度是通过反向传播算法获得的。 在神经渲染的背景下，神经网络实现了3D场景表示，训练数据由场景的2D观测值组成。使用神经场景表示的可微渲染得到的渲染结果与使用给定的观察进行了比较。 这些重建损失可以用每个像素的L1或L2项来实现，也可以使用基于感知的甚至基于判别器的损失公式。然而，关键是这些损失直接与各自的可微渲染公式耦合，以更新场景表示，见3.1节。","link":"/2024/06/11/Advanced%20in%20Neural%20Rendering%20%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"title":"Linux命令","text":"设置GPU可见命令 加在运行命令之前 CUDA_VISIBLE_DEVICES = [GPU编号] nvidia-smiwatch -n 0.1 nvidia-smi WIFI 使用nmcli查看可用的WiFi网络：nmcli dev wifi list 选择一个网络，并使用以下命令连接：nmcli –ask dev wifi connect password 您想要创建一个新的WiFi连接配置，可以使用以下命令：nmcli con add type wifi ifname con-name nmcli con modify wifi.ssid nmcli con modify wifi.security nonenmcli con modify wifi.mode managednmcli con modify wifi.hidden falsenmcli con modify wifi.password nmcli con up 将替换为您的无线网络接口名称，为您的连接名称，为网络的名称，为网络的密码。","link":"/2024/10/07/CUDA%E5%91%BD%E4%BB%A4/"},{"title":"Git命令","text":"branch分支相关git branch 显示本地分支git branch -a 显示所有分支 git checkout 切换分支，将替换为你的分支名","link":"/2024/09/29/Git%E5%91%BD%E4%BB%A4/"},{"title":"Leetcode 算法解析","text":"难度：Easy = E | Middle = M E 1.两数之和 2024.3.26 方法一：暴力枚举 两个循环搞定 注意用malloc先分配好空间 int* ret = malloc(sizeof(int)*2); 时间O(N^2^) 空间O(1) ！！！方法二：哈希表 用于方法一的时间复杂度过高——寻找匹配元素 创建一个哈希表，对于每一个x，先查询表中是否存在target-x，再将x插入到表中，保证不会让x与自己匹配 E 9.回文数 2024.3.27 方法一：将数字划分为各个单个数进行循环判断； 常规解法：1.先将数字划分为单个数存入数组，while循环加静态数组；2.循环进行判断，注意循环次数；3.可使用动态数组以防止overflow。 方法二：将其转换为字符串数组，直接进行数组元素的相等判断。循环次数到n/2即可。 E 13.罗马数字转整数 2024.3.29 方法一：字符串的转化 找规律 建立转化表 再进行数字判断并累加 出现了问题“如何建立一个转换表” “switch函数的参数是否能输入多字符结构（字符串）” E 14.最长公共前缀 2024.3.30 指针与字符串——文言一心 指针的定义与类型 char* 是一个指向字符的指针。 char** 或 char* * 是一个指向字符指针的指针，通常用于存储字符串数组。 数组与指针 ： 当有一个字符串数组（如 char* strs[]），strs 是一个指向该数组第一个元素的指针，即 strs 的类型是 char**。 strs[i] 表示数组中的第 i 个字符串，它的类型是 char*。 解引用指针 ： 使用 * 运算符可以解引用指针，获取指针所指向的值。例如，*strs[0] 获取 strs 数组中第一个字符串的第一个字符。 printf 函数与格式说明符 ： %s：用于输出以空字符结尾的字符串。 %d：用于输出整数。 %c：用于输出单个字符。 %p：用于输出指针的地址，通常需要将指针转换为 void* 类型。 字符串与地址的输出 ： 直接使用 printf(&quot;%s\\n&quot;, strs[i]) 可以输出 strs 数组中第 i 个字符串的内容。 使用 printf(&quot;%p\\n&quot;, (void*)strs[i]) 可以输出 strs 数组中第 i 个字符串的地址（即指针的值）。 指针与整数的区别 ： 指针存储的是内存地址，而整数存储的是数值。 错误的格式说明符可能导致输出无意义的结果或未定义的行为。 方法一：横向扫描 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串（对比其各个字符是否相等），更新最长公共前缀，当遍历完所有字符串后，即可得到最长公共前缀。 对比其各个字符是否相等——strs[i][j]==prefix[j] prefix为存储当前最长公共前缀的字符串 如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。 if(prefixLength == 0) 方法二：纵向扫描 纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。 具体思路：把第一个字符先拿出来（循环1），然后依次用用数值的相应字符与其比较（strs[0][i] != strs[j][i]）（循环2），然后判断是否相同，如果有一个字符不同则将这个字符赋’\\0’，然后将新的数组赋给strs[0]，然后return 新的strs[0]; **注意：此方法会更改strs[0]原本的值 如果此变量之后还具有价值的话 会导致值被更改 ** 最好的方法是动态分配一块内存用于存储公共前缀的值，记得在返回后free掉， 除此之外，如果不想使用动态分配的话，可以再传入函数参数时，多传入一个具有足够大空间的静态缓冲区， 因为在函数内部定义的缓冲区是局部变量，会在结束后被释放，所以不能用于返回，返回会为一个null E 20.有效的括号 栈 2024.3.31 括号的正确匹配问题 用到了数据结构——栈 使用栈来跟踪尚未匹配的打开括号 遍历输入字符串：对于字符串中的每个字符，我们检查它是打开括号还是闭合括号。 处理打开括号：如果遇到打开括号（如(、[、{），我们将其压入栈中，表示这个括号尚未找到匹配的闭合括号。 处理闭合括号：如果遇到闭合括号（如)、]、}），我们检查栈顶的元素是否是与之匹配的打开括号。如果是，则从栈中弹出该元素，表示找到了匹配的括号对；如果不是或栈为空，则说明括号无效。 检查栈是否为空：在遍历完整个字符串后，如果栈为空，说明所有的打开括号都找到了匹配的闭合括号，因此括号组合是有效的；如果栈不为空，则说明还有未匹配的打开括号，括号组合无效。 这种算法思想利用了栈的后进先出（LIFO）特性，非常适合处理这种需要匹配成对出现元素的问题。在遍历字符串的过程中，我们只需要维护一个栈，就可以高效地判断括号是否有效。 注意栈的定义与初始化 char* stack = (char*)malloc(strlen(s) * sizeof(char)); 其中因为malloc函数的返回值为void*类型 所以要进行类型转换 int top = -1；这是栈顶指针 初始化为-1 表示栈空 元素入栈时，stack[++top] = s[i]；栈顶指针要自增 再压入栈中 元素出栈时，pop = stack[top–]; 出栈时要先取值再自减 不然取到的值是栈顶第二个元素 E 21.合并两个有序链表 2024.3.29 方法一：双指针遍历 创建一个新链表进行存储合并后的链表 创建链表结点的问题 如果此结点需要存储信息，则要malloc分配空间 如果此结点/指针仅仅用来遍历，则不需要分配空间 注意断链问题 可能需要一个指针防止断链 防止内存泄漏问题 动态分配内存malloc后记得free掉 E 26.删除有序数组中的重复项 2024.4.1 不能使用临时数组存储不需要考虑其他元素 只考虑返回唯一的元素需要记录元素覆盖的位置 思想：定义一个变量pos初始化为1，即时更新 表示当前插入的数组位置，最后可以当作nums的唯一元素数量返回 E 27.移除元素 2024.4.2 原地删除 给一串数字，用两个循环遍历，第一个循环找出对应值的元素，第二个循环从对应值开始向后遍历，找不等于对应值的元素，找到后赋值到第一个循环找到的位置，然后直接退出第二个循环，再如此进入第一个循环继续遍历。 E 28.找出字符串中第一个匹配项的下标 2024.4.3 给了两个字符串，在第一个字符串中找到第二个字符串的第一个匹配项的下标，未匹配到就返回-1。 思想：用双循环，第一个循环遍历第一个字符串，每次从一个字符开始，用第二个循环和第二个字符串匹配，如果不匹配就从第一个字符串的下一个字符开始继续匹配，直到第一个字符串全部遍历结束。 E 35.搜索插入位置 二分查找 2024.4.4 规定了时间复杂度 用二分查找 规定中间值与目标值进行对比，不等时从两侧查找，当前后两个位置值顺序反转或相等时退出循环 要注意整数溢出问题 C或C++中，整数值过大时直接相加会导致整数溢出，此时可以用如下方法： first + (last - first) / 2 等价于 (first + last) / 2 E 70.爬楼梯 动态规划 2024.3.25 方法一：每次爬1或2层 找规律可得递推公式 递归解决 方法二 C++：为了节省时间 记忆化递归 用memo数组记录计算结果 如果已经计算过就直接返回memo中的结果 保证每个结点只计算一次 方法三：动态规划算法 记录n个状态，从1到n依次更新 只记录其中用到的两个状态 可以优化时间复杂度到O(1) 方法四：滚动数组 每次状态更新后 把状态2移到状态1的位置 状态3移到状态2的位置 状态整体向前滚动一位 E 94.二叉树的中序遍历 2024.4.19 递归 由于是左中右的遍历顺序 所以遍历当前节点前要先遍历左子树 遍历当前节点后遍历右子树 迭代 二叉树中序遍历的迭代法，相比较递归法就是显式地维护了一个栈 用数组保存中序遍历 用栈来遍历节点 当根结点不为空且栈不空时 说明树没遍历完 进入循环遍历 用循环将当前节点和所有左子节点压入栈中 全部压入栈中后，再取栈顶元素，出栈，加入结果数组，然后遍历当前结点的右子树 最后返回结果数组 E 104.二叉树的最大深度 2024.4.22 深度优先搜索 递归 当前树的深度 = max（左子树深度 + 右子树深度） + 1 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。 广度优先搜索 迭代 队列 按层数进行节点的遍历，定义一个队列用来存储当前层的节点，遍历节点时，注意其左右孩子节点，如果存在就入队，再进行队列中下一个节点的遍历和操作，每遍历完一层结点（一次循环），记录（h++），最后的遍历层数就是最大深度。 时间复杂度：O(n)。 空间复杂度：O(n)，最大要遍历所有元素n个。 E 118.杨辉三角 2024.4.11 迭代/递归 迭代 先定义一个二维数组，初始化第一第二行，从第三行开始循环算：一行一行初始化一个辅助vector存储当前行的元素，用一个循环计算中间元素，最后将当前行的元素push_back进二位数组中 递归 先确定边界条件0和1，在递归调用生成前numRows-1行，此时会只剩当前行没生成，和迭代相同，创建当前行，使用一个辅助数组存储当前行元素，初始化第一和最后一个元素为1，在计算中间元素，最后将当前行加入整个二维数组中 back()的问题 vec.back()用来返回最后一个元素 vec2D.back()[i] 用来返回一个二维数组的最后一行的第i个元素 E 136.只出现一次的数字 2024.4.10 需要使用异或运算 异或运算的性质： 任何数和0做异或运算，结果仍然是原来的数，即 a ^ 0 = a。 任何数和其自身做异或运算，结果是0，即 a ^ a = 0。 异或运算满足交换律和结合律，即 a ^ b ^ a = b ^ (a ^ a) = b ^ 0 = b。 除了一个元素只出现一次以外，其余每个元素都出现两次。 那么，如果我们对数组中的所有元素进行异或操作，那些出现两次的元素会两两抵消（因为 a ^ a = 0），最后剩下的就是只出现一次的元素。 E 141.环形链表 2024.4.13 判断环 快慢指针判断环 E 160.相交链表 双指针 2024.4.6 方法一：双指针 1.写一个求链表元素的函数2.双指针遍历 比较指针(比较指针所指的值时可能会重复 指针是唯一的)3.遍历前操作：先让链表更长的指针先走 时间复杂度:O*(m+n) 空间复杂度:O*(1) 方法二：循环遍历 用指针实现循环链表 两个指针走了相同距离必定相遇 12345678910111213struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { //定义指针p,q,当两个指针走了相同距离必定相遇 struct ListNode *p = headA; struct ListNode *q = headB; while(p != q) { p = p ? p-&gt;next : headB; q = q ? q-&gt;next : headA; } return p;} 方法三：哈希集合 E 169.多数元素 跟踪者/计数器 摩尔投票算法（Boyer–Moore Voting Algorithm） 这个算法的基本思想是在遍历数组时，用一个变量 count 来记录当前候选众数的出现次数，用另一个变量 candidate 来记录当前的候选众数。如果当前元素与candidate相等，则count++；否则count–。count==0时，更新此时candidate= 当前元素。 这样做由于是多数元素，最终的count一定会是正数，而多数元素就是此时candidate记录的元素。 E 206.反转链表 2024.4.7 逐个翻转结点法 初始化两个指针，一个指向当前节点（prev），另一个指向下一个节点（curr）。 将prev初始化为NULL，curr初始化为head。 遍历链表，每次迭代将curr的next指针指向prev，然后移动prev和curr到下一个位置。 当curr为NULL时，遍历结束，此时prev就是反转后的头节点。 头结点的问题 一般提到头结点head时，可以将其理解为指向第一个结点的指针 所以head-&gt;val=第一个结点的值 head-&gt;next=第二个结点 递归解法 主要关键在于反向工作 用C++解决 构造函数 1234567struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; ListNode() : val(0), next(nullptr) {} 这是ListNode的默认构造函数。当你创建一个ListNode对象而不提供任何参数时，这个构造函数会被调用。它将val初始化为0，并将next初始化为nullptr（即空指针）； 以此类推，如果传入int x 或 int x与一个next指针，则会调用相应的构造函数 解法 M 215.数组中的第k个最大元素 2024.4.14 1.快速选择2.堆排序3.先排序后直接返回 一般用这个就够了根据快速排序算法的快速选择算法，在划分之后，如果枢轴元素正好是第k个，就找到了目标值，如果k在枢轴元素左边，则向左递归划分，否则向右递归划分。需要重点掌握的算法：划分、快排 E 226. 翻转二叉树 2024.4.23 递归 递归交换 只需要声明两个指针，用于递归地翻转左右子树，再进行交换，交换时直接交换节点而不是节点的值 时间和空间都是O(n) E 283.移动零 双指针 2024.4.5 双指针 一个指针遍历整个数组找非0值 一个指针标记0的位置（即要插入的位置）用非0值覆盖0值的位置 E 543.二叉树的直径 2024.6.6 这道题主要搞清楚几点：1.深度优先遍历 需要用其来计算深度 深度=max（左儿子深度，右儿子深度）+ 12.路径长度 = 根结点左右儿子的深度之和3.最长路径长度 用一个MAX来在计算深度时顺便记录 计算完左右孩子的深度时进行更新4.用到一个class内的局部变量MAX 只需定义一次5.注意：MAX是求深度depth时顺便记录的 depth返回的是深度 最长路径是MAX","link":"/2024/03/26/Leetcode/"},{"title":"NeRF入门及进阶——中恩实验室","text":"NeRF原理快速入门 1 关于渲染与反渲染（图形学） 渲染rendering：基于一个三维模型以及材质和光照的信息，通过一个特定的视角，将物体渲染成一个精美的画面。（上图） 反渲染inverse rendering（三维重建）：通过渲染出来的图像，重新得到三维模型。一般会用网格、点云或者体素的方式表现。 2 NeRF NeRF也是三维重建的一种技术，但是和以往技术不同： 以往技术：通过图片重建模型 NeRF：通过神经隐式重建模型 神经隐式：将三维模型的信息存在于神经网络中，输入相机位姿，输出图片的RGB和不透明度alpha。 可简单理解为：使用一个NeRF神经网络采取体积雾（带不透明度的点云）的渲染方式，通过已知视角的图片进行训练，然后输入其他相机视角的参数，从而预测出未出现视角的图片。 此时三维模型的信息存储在NeRF神经网络之中，所以是一种隐式的表示方法，而不是像点云、网格显示表示。 一个NeRF网络模型只能存储一个三维物体或场景的信息（单对单训练模型），现在有一些相关工作：希望网络可以同时使用在多个场景和多个三维模型（泛化）。 3 原理 3.1 输入：相机位姿——5D Input Position 相机位置：(x，y，z) Direction 相机方向：(θ，φ)，这是球坐标的表现方法，只要两个参数，方位角和俯仰角，代表的是相机位置与成像平面所对应像素连线发出的“光线”射线的方位，类似与Yaw，Pitch，Roll中的Yaw和Pitch，但不包含Roll。 注： θ是点在xOy平面上的投影 与 原点的连线 和 x轴正方向所成夹角，也就是一般说的极坐标的θ，取值范围为[0,2π)或[0,2π]。 φ是点与原点所成连线和z轴正半轴所成夹角，取值范围为[-π,π]（闭区间，否则顶点取不到）。 实际上在网络输入的仍然是三维向量，来表示射线方向xyz，和相机位置的xyz不同。 3.2 神经网络 F(θ) 最后目的就是把在这个相机角度下所拍摄到的图片的成像内容给输出出来。 一个像素点对应的射线和相机位置就是一个训练资料，一个神经网络模型只需要40mb的大小就可以存储下3D模型内容。 3.3 输出：一根射线上一组采样点的属性——4D Output 输出像素点对应射线上的一组采样点颜色值(r,g,b)和不透明度值(α)。 如图b，在一定范围内取了一组采样点（橙色小点，每个点带有rgba的值），代码中使用near和far参数来表示光线能到达的最近及最远点。 在射线方向上对采样渲染点进行积分得到确切颜色值（通过体积雾渲染的方式，图c，d），在第一次出现波峰对该像素点的着色影响最大。（所以NeRF渲染出来的物体有一种看起来像雾一样的感觉） 注： Density密度值/不透明度：α 该值与观测角度无关 3.4 位置编码γ(x,y,z) Positional Encoding 将图像中的高频信息体现出来，可以大幅度提高图片的细节质量 NeRF中的位置编码是通过concat 的方式将信息融合起来 Fθ=F‘θ ○ γ γ(p) = (sin(2^0^πp),cos(2^0^πp),…,sin(2^L-1^πp),cos(2^L-1^πp)). sin和cos两个为一项，空间坐标中用10项，即20维离开分别表示(x,y,z)位置编码 相机方向用4项，及8维来分别表示(x,y,z)位置编码 4 网络图 用全连接层一直连得到最终结果 5 Volume Render部分 采用一种体积雾的渲染方式，在获取一定范围采样点的(r,g,b,a)后需要再进行特定积分运算，最终得到对应像素最终的(r,g,b,a)，在训练时通过光线采样点积分得到的像素值 存在一个问题：光线穿透不透明的物体时 物体是存在前面和后面 后面的内容是不应该被成像出来的（物体不透明） 解决方式：通过一种特定的积分方式，主要是计算了第一个波峰所对应的颜色和不透明度值来产生对应的画面中的像素值 总结 通过一组图片（和对应的相机位姿）去训练一个网络，网络存储对应模型信息，再输入一个不一样视角的相机参数，就能呈现我们想要看到的物体的一个角度的成像。","link":"/2024/06/11/NeRF%E5%85%A5%E9%97%A8%E5%8F%8A%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E4%B8%AD%E6%81%A9%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"title":"Python笔记-Mosh","text":"Python笔记-Mosh 1.关于输入输出 ·input() 输入 括号里可以加想打在屏幕上的字 ·print（） 输出 其中可以用 运算符 ·可以用双引号和单引号 2.关于字符串 ·格式化字符串 以某个字符为开头 如 f‘{first} [{last}] is a coder’ down_payment = 0.2 * price print(f”Down payment: ${down_payment}”) （输出）Down payment: $100000.0 ·len() 函数返回长度 ·字符串改为大写 course.upper 小写 .lower (course是字符串变量) unit.lower() == “k” unit.upper()== “L” · .title 将字符串中每个单词首字母变成大写 其余变为小写 · .find找到字符或字符串的位置 · .replace 替换字符或字符串 ·用in运算符 可以判断字符串是否在其变量中 如‘python’ in course ，这会产生一个布尔型的值 true or false 3.关于加减乘除运算 ·**是次方（取幂） ·//是整除 /是除（浮点数） ·注意运算符之间的优先级 4.关于数字的处理 ·round函数 四舍五入 ·abs函数 输出其绝对值 ·导入数学模块 import math 用来使用math点函数 ·ceil函数 印章？ ·floor函数 取整 5.关于if语句 is_hot = True is_cold = True if is_hot: print(“It’s a hot day”) print(“Drink plenty of water”) elif is_cold: print(“It’s a cold day”) print(“Wear warm clothes”) else: print(“It’s a lovely day”) print(“Enjoy your day”) 6.关于逻辑运算符 and 和 or not：非 7.关于比较运算符 &lt;= &gt;= != == 等等 8.强制转换类型 int()函数：转换为int类型 weight = int(input(“Weight: “)) 9.关于while循环 While循环中也有类似于else的语句 一般用在循环结束时执行 secret_num = 9 guess_count = 0 guess_limit = 3 while guess_count &lt; guess_limit: guess = int(input(“Guess: “)) guess_count += 1 if guess == secret_num : print(f”Congraculation! It’s {guess} !”) break else: print(“Sorry you failed!”) 此语句 会在循环结束时执行else语句中的内容 除非在此之前循环中通过break跳出 10.练习-开车小游戏 我的代码： is_start = True command = input(“&gt;”) while is_start: if command == “help”: print(“start - to start the car”) print(“stop - to stop the car”) print(“quit - to exit”) command = input(“&gt;”) elif command == “start”: print(“Car started…Ready to go!”) command = input(“&gt;”) elif command == “stop”: print(“Car stopped.”) command = input(“&gt;”) elif command == “quit”: break else: print(“I don’t understand that …”) command = input(“&gt;”) 示例代码： command = “” flag_start = False while True: command = input(“&gt; “).lower() if command == “help”: print(“”” start - to start the car stop - to stop the car quit - to quit “””) elif command == “start”: if flag_start == False: print(“Car started…Ready to go!”) flag_start = True elif flag_start == True: print(“Car already started!”) elif command == “stop”: if flag_start == True: print(&quot;Car stopped.&quot;) flag_start = False elif flag_start == False: print(&quot;Car already stopped!&quot;) elif command == “quit”: break; else: print(“I don’t understand that …”) 11.关于for循环 适合用于循环遍历取值 ·range(起始, 结束, 步长)函数 从0到n-1 循环打印数字 for 变量名 in 可迭代对象（字符串、列表、字典等） for item in range(5,10,2): print(item) 例 遍历计算总和 prices = [10,20,30] total = 0 for price in prices: total += price print(f”Total:{total}”) 12.关于嵌套循环 输出一个用x组成的图形F —— 设置一个空字符串 循环加入x 再打印 numbers = [5,2,5,2,2] for x_count in numbers: output = ‘’ for count in range(x_count): output += ‘x’ print(output) 13.关于列表list 类似数组 可以用数组名[起始: 结束] 来选定特定的组内元素 如果忽略起始/结束符 则默认从开头/到结尾选定 names = [‘John’,’Bob’,’Mosh’,’Sarah’,’Mary’] print(names[2:4]) 通过修改索引项直接修改组内元素内容 names[1] = ‘Ann’ 例 找出列表中最大的数值 numbers = [12,32,57,4,86,998,324,102,10,90] max = numbers[0] for number in numbers: if number &gt; max: max = number print(max) number变量可以直接访问列表！ 14.关于二维列表2D list 定义： matrix = [ [1,2,3], [4,5,6], [7,8,9] ] 可以单个修改其中的元素： matrix[0][1] = 20 可以通过循环嵌套访问每个元素： for row in matrix: for item in row: print(item) 15.关于列表函数或列表方法List Methods ·.append（n） 列表末尾添加n ·.insert（索引数, n）在索引处添加n 其他数后移一位 ·.remove（n）删除一个n（最左边） ·.clear（） 删除列表中所有的值 ·.pop（） 删除最后一项 ·.index（n）找到列表中值为n的元素 并返回其索引值 也可以检查list中是否有n 当然 可以用in运算符来判断 会返回一个布尔值 ·.count（n）返回list中值等于n的元素的个数 ·.sort（） 不返回任何值（返回None）对list进行升序排序 ·.reverse（） 对list进行反转 可以配合sort函数进行list的降序排列 ·.copy（） 对列表进行复制 例 删除表中重复项 numbers = [5,2,1,7,4,5,9,5,20,20] uniques = [] for number in numbers: if number not in uniques: uniques.append(number) print(uniques) 16.关于元组Tuples 适用于不可改变值的list 类似于list 但是不同于list Tuples不可改变 不可赋值 只有count函数和index函数 17.关于解包Unpacking 可以避免多次赋值 将元组解包为三个变量 也可以用于列表list coordinates = (1,2,3) x = coordinates[0] y = coordinates[1] z = coordinates[2] x,y,z = coordinates 18.关于字典Dictionaries 存储以键值对形式出现的信息 可以修改其中的值 可以用方括号取值 也可以用get函数取值（get函数不会报错 只会返回None值） customer = { “name”:”John Smith”, “age”:30, “is_verified”:True } customer[“name”] = “Jack Smith” print(customer[“name”]) print(customer.get(“birthday”,”Jan 1 1980”)) 例 输入一串数字 将其中每个数字用英文输出 numbers_chinese = { “0”:”Zero”, “1”:”One”, “2”:”Two”, “3”:”Three”, “4”:”Four”, “5”:”Five”, “6”:”Six”, “7”:”Seven”, “8”:”Eight”, “9”:”Nine”, } Phone_numbers = input(“Phone: “) for i in Phone_numbers: print(f”{numbers_chinese[i]}”,end = ‘ ‘) 示例代码： numbers_chinese = { “0”:”Zero”, “1”:”One”, “2”:”Two”, “3”:”Three”, “4”:”Four”, “5”:”Five”, } Phone_numbers = input(“Phone: “) output = “” for i in Phone_numbers: output += numbers_chinese.get(i, “!”) + “ “ print(output) 将其一个一个加入了空的输出字符串中 而且每个字符后加了一个空格符 将数据放在一行上输出 并用空格隔开 用end参数——规定print函数输出的结尾字符 默认为回车符 for i in Phone_numbers: print(f”{numbers_chinese[i]}”,end = ‘ ‘) 19.关于表情Emoji Converter：) 一个小游戏 Split(‘ ‘) 函数 可以以字符’ ‘为界限 分割字符串中的各个字符 并返回一个列表list 20.关于函数 Functions 定义函数： def greet_user(): print(“Hi there!”) print(“Welcome!Here is a happy place!”) greet_user() 先定义 再调用 定义之后要空一行 21.关于传递参数parameters 将信息传递给函数 def greet_user(name): print(f”Hi {name}!”) greet_user(“John”) greet_user(“Mary”) 定义函数时 在括号里设定变量参数 def greet_user(first_name, last_name): print(f”Hi {first_name} {last_name}!”) greet_user(“John”,”Smith”) 可以对参数进行规定 提高可读性 greet_user(first_name=”John”,last_name=”Smith”) 如果同时传递位置和关键字参数 请使用位置参数之后的关键字参数 22.关于创建返回的函数 Return Statement def square(number): return number * number 一般情况下 函数默认（没有Return语句时）返回None 23.关于创建一个可重复使用的函数 Reusable Function def emoji_converter(message): words = message.split(“ “) emojis = { “:)”:”0.0”, “:(“:”QAQ” } output = “” for word in words: output += emojis.get(word,word) + “ “ return output message = input(“&gt;”) print(emoji_converter(message)) 24.关于处理异常情况/错误 try except （尝试接受块） try: age = int(input(‘Age: ‘)) print(age) except ValueError: print(‘Invalid value’) try：尝试运行以下代码 当错误信息为ValueError时 不要报错 而是执行以下代码（输出错误信息） 25.关于注释comments 注释一般要用来解释why或者how 而不是whats # 这是一行注释 ‘’’* 这是多行注释 ‘’’* # ctrl+/ 可以快捷设置注释 三个单引号和三个双引号都可以实现多行注释 26.关于类 classes 定义新的类型 帕斯卡命名法 命名规则：对于变量和函数 总是使用小写字母和下划线 可以分割多个单词 但对于类的命名 不使用下划线 而是大写每个单词的第一个字母 class EmailClient 定义类 类中可以定义函数 也可以像C中的结构体 定义新的变量并修改 class Point: def move(self): print(“move”) def draw(self): print(“draw”) point1 = Point() point1.x = 10 point1.y = 20 print(point1.x) point1.draw()","link":"/2023/04/21/Python%E7%AC%94%E8%AE%B0-Mosh/"},{"title":"limb_compound开发文档试写","text":"3.3 compound3.3.1 接口调用第一步：在x86环境调用mathimf.h库中的compound函数 12345678910111213141516#include &quot;stdio.h&quot;#include &quot;mathimf.h&quot; //调用mathimf.h库#include &quot;convert.h&quot;int main() { double inputValue1; double inputValue2; printf(&quot;please input an integer1: &quot;); scanf(&quot;%llx&quot;, &amp;inputValue1); printf(&quot;please input an integer2: &quot;); scanf(&quot;%llx&quot;, &amp;inputValue2); double result = compound(inputValue1,inputValue2); //调用mathimf.h库中的compound函数 printf(&quot;The result of _libm_compound is: %llx\\n&quot;, *(unsigned long long*)&amp;result); printf(&quot;The result of _libm_compound is: %lf\\n&quot;, *(unsigned long long*)&amp;result); return 0;} 第二步：Makefile编译 1234567891011121314151617181920212223242526VERSION =CC =iccDEBUG =-gCFLAGS =-fp-model precise -no-ftzifeq ($(COMPOUND), TRUE) SOURCES =compound_acc_test.c TARGET =compound_accendifINCLUDES =-I../src/includeLIB_NAMES =LIB_PATH =OBJ =$(patsubst %.c, %.o, $(SOURCES))#links$(TARGET): $(OBJ) $(CC) $(OBJ) $(LIB_PATH) $(LIB_NAMES) -o $(TARGET)$(VERSION) @rm -rf $(OBJ) #compile%.o: %.c $(CC) $(INCLUDES) $(DEBUG) -c $(CFLAGS) $&lt; -o $@.PHONY:cleanclean: @echo &quot;Remove linked and compiled files......&quot; rm -rf $(OBJ) $(TARGET) 3.3.2 IDA Pro反汇编第一步：使用IDA Pro打开编译后的文件compound，点击Tab键即可打开反汇编之后的伪代码。 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp){ double v3; // xmm0_8 double inputValue1; // [rsp+18h] [rbp-28h] BYREF double inputValue2; // [rsp+20h] [rbp-20h] BYREF double v7; // [rsp+28h] [rbp-18h] double result; // [rsp+30h] [rbp-10h] printf(&quot;please input an integer1: &quot;); __isoc99_scanf(&quot;%llx&quot;, &amp;inputValue1); printf(&quot;please input an integer2: &quot;); __isoc99_scanf(&quot;%llx&quot;, &amp;inputValue2); v7 = compound(inputValue1, inputValue2); v3 = v7; result = v7; printf(&quot;The result of _libm_compound is: %llx\\n&quot;, *(_QWORD *)&amp;v7); printf(&quot;The result of _libm_compound is: %lf\\n&quot;, v3); return 0;} 第二步：双击compound进入函数内部，找到对应的接口_libm_compound_ex。 1234__int64 compound(){ return _libm_compound_ex();} 第三步：双击_libm_compound_ex进入接口内部，又找到接口sub_4012E4。 1234__int64 _libm_compound_ex(){ return sub_4012E4();} 第四步：双击sub_4012E4进入接口内部，此时的伪代码就是我们需要实现的。例： 12345678910111213141516171819202122232425262728293031323334353637v2 = a2; v4 = *(_QWORD *)&amp;a2; v70 = a1; v5 = (*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FFLL; v6 = (*(_QWORD *)&amp;a2 &gt;&gt; 52) &amp; 0x7FFLL; if ( (unsigned int)(HIDWORD(a1) + 0x100000) &gt;= 0xBFF00000 || (_DWORD)v5 == 2047 || (unsigned int)(v6 - 1) &gt;= 0x7FE || (int)v6 + (int)v5 &lt; 1988 || ((unsigned __int16)(*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FFu) &gt;= 0x3FF &amp;&amp; (unsigned int)(v6 - 965) &gt;= 0x45 ) { v7 = 2LL * *(_QWORD *)&amp;a2; if ( !(2LL * *(_QWORD *)&amp;a2) ) { v69 = 0.0; return 1.0 + 0.0; } if ( ((*(_QWORD *)&amp;a1 &gt;&gt; 52) &amp; 0x7FF) == 2047 ) { if ( (unsigned __int64)(2LL * *(_QWORD *)&amp;a1) &gt; 0xFFE0000000000000LL ) { v69 = 0.0; return v70 + 0.0; } if ( v7 &lt;= 0xFFE0000000000000LL ) { if ( a1 &lt; 0.0 ) return 0.0 * v70; result = 0.0; if ( a2 &gt; 0.0 ) { v69 = INFINITY; return INFINITY; } return result; } } 3.3.3 double类型常用宏定义1、HIDWORD(double x) 12345678static uint32_t HiDword(double x){ uint32_t ret; uint64_t xUint64; xUint64 = Asuint64(x); ret = (xUint64 &gt;&gt; 0x20) &amp; 0xFFFFFFFF; return ret;} 2、LOBYTE(double x) 123456static uint8_t LowByte(double x){ uint8_t ret; ret = Asuint64(x) &amp; 0xFF; return ret;}","link":"/2023/12/21/limb_compound%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E8%AF%95%E5%86%99/"},{"title":"gdb调试","text":"第一步：gdb ./compoundf第二步：打断点 b *0x。。。第三步：layout asm第四步：r第五步：输入第六步：走一步 si第七步：i r 寄存器 看寄存器的值","link":"/2023/10/25/limb_gdb%E8%B0%83%E8%AF%95/"},{"title":"limb规范标准（试行）","text":"未规范代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115__int64 sincos_k32(double *a1, double *a2,int a3, double a4){ double v11_data[2]; unsigned __int64 v4; __int64 result; unsigned int v5; int v6; double v7; unsigned int v8; int v9; struct __m128d v10; struct __m128d v11; int v12; int v13; int v14; double v15; double v16; __int64 v17; double v18; double v19; double v21; double v22; double inputX; double v24; double v25; double v26; double v27; double v28; double ones[2] = {1.0, -1.0}; double iones[2]={1,-1}; v28 = a4; v4 = HIDWORD(a4) &gt;&gt; 31; v5 = HIDWORD(a4) &amp; 0x7FFFFFFF;//将上述读取的 64 位整数值与 0x7FFFFFFF 进行按位与操作。 v6 = iones[v4] * a3; v7 = fabs(a4); if (v5 &gt;= 0x41C00000) { v28 = v7; v17 = reduce_pi04d(&amp;v28, v6, v7); v8 = v17 + 1; v7 = v28; //v9 = ((_BYTE)(v17) + 1) &amp; 2;// 是从一个 double 类型的值中提取指定索引位置的字节，并对提取的字节进行处理，最终得到一个 uint8_t 类型的结果。 //v9 = (getByteFromDouble(v17, 0) + 1) &amp; 2; v9 = ((_BYTE)v17 + 1) &amp; 2; } else if (v5 &gt; 0x3FF90000) { v10.m128d_f64[0] = Asdouble(0x3FF45F306DC9C883) * v7; v28 = v7; v27 = Asdouble(0x3FF45F306DC9C883) * v7 + Asdouble(0x4338000000000000); //v11_data[1] = (double)SLODWORD(v27); //v11 = *((__m128d*)v11_data); v11.m128d_f64[0] = (double)SLODWORD(v27); //v11.m128d_f64[1] = v11_data[1]; v12 = compare(&amp;v10, &amp;v11); v13 = LODWORD(v27) - v12 + v6; v14 = v13 &amp; 1; v8 = v14 + v13; v15 = (double)(v14 + LODWORD(v27) - v12); v9 = v8 &amp; 2; if (v5 &gt;= 0x41000000){ v16 = v28 - Asdouble(0x3FE921FB40000000) * v15 - Asdouble(0x3E64442D00000000) * v15 - Asdouble(0x3CE8469880000000) * v15; } else{ v16 = v7 - Asdouble(0x3FE921FB54440000) * v15 - Asdouble(0x3D768C234C400000) * v15; } v7 = v16 - v15 * Asdouble(0x3B68CC51701B839A); v28 = v7; } else{ v8 = v6 + 1; v9 = v8 &amp; 2; if (v8 &amp; 2){ v7 = v7 - Asdouble(0x3FE921FB54442D18); } v28 = v7; } v18 = v7 * v7; v19 = (Asdouble(0x3EC71D9AA585BFC4) * (v18 * v18) + Asdouble(0x3F81111110FD4208)) * (v18 * v18) * v7 + v7 + ((Asdouble(0xBE5AA2880297FC43) * (v18 * v18) + Asdouble(0xBF2A019FD9BD0882)) * (v18 * v18) + Asdouble(0xBFC555555555516D))* v18* v7; result = ((v8 + 2) &gt;&gt; 2) &amp; 1; v21 = (Asdouble(0x3EFA01299942AB00) * (v18 * v18) + Asdouble(0x3FA5555555150951)) * (v18 * v18) + Asdouble(0x3FF0000000000000) + ((Asdouble(0x0BE9247507B5EE59E) * (v18 * v18) + Asdouble(0xBF56C16BAE710FF8)) * (v18 * v18) + Asdouble(0xBFDFFFFFFFFFE6A2)) * v18; v22 = ones[(v8 &gt;&gt; 2) &amp; 1 ^ v4]; if (v9){ inputX = v21 * v22; v24 = ones[result]; *a1 = inputX; *a2 = v19 * v24; } else{ v25 = v19 * v22; v26 = ones[result]; *a1 = v25; *a2 = v21 * v26; } return result;} 规范代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int64_t SincosK32(double* outputX, double* outputY, int y, double x){ uint64_t xSign; unsigned int magnitude; int signedMultiplier; double doubleTemp; double xAbs; unsigned int uint32Temp; int uint32SetBit; double xAbsMulTemp; double xAbsTemp; double xAbsTempConInt; double retCompare; int temp; int getLastBit; double doubleTempSquare; int onesIndex; double intTemp; double xAbsSubTemp; double onesConvDouble; double doubleTempX; double doubleTempY; int retReduce; double input; xSign = hiDoubleDword(x) &gt;&gt; 0x1F; magnitude = hiDoubleDword(x) &amp; 0x7FFFFFFF; signedMultiplier = ones[xSign] * y; xAbs = fabs(x); if (magnitude &gt;= 0x41C00000) { retReduce = ReducePi04d(&amp;input, signedMultiplier, xAbs ); uint32Temp = retReduce + 1; doubleTemp = input; uint32SetBit = (retReduce + 1) &amp; 0x2; } else if (magnitude &gt; 0x3FF90000) { xAbsMulTemp = Asdouble(0X3FF45F306DC9C883) * xAbs; xAbsTemp = Asdouble(0X3FF45F306DC9C883) * xAbs + Asdouble(0x4338000000000000); xAbsTempConInt = lowDoubleDword(xAbsTemp); retCompare = compare(xAbsMulTemp, xAbsTempConInt); temp = xAbsTempConInt - retCompare + signedMultiplier; getLastBit = temp &amp; 1; uint32Temp = getLastBit + temp; intTemp = getLastBit + xAbsTempConInt - retCompare; uint32SetBit = uint32Temp &amp; 0x2; if (magnitude &gt;= 0x41000000) { xAbsSubTemp = xAbs - Asdouble(0x3FE921FB40000000) * intTemp - Asdouble(0x3E64442D00000000) * intTemp - Asdouble(0x3CE8469880000000) * intTemp; } else { xAbsSubTemp = xAbs - Asdouble(0x3FE921FB54440000) * intTemp - Asdouble(0x3D768C234C400000) * intTemp; } doubleTemp = xAbsSubTemp - intTemp * Asdouble(0x3B68CC51701B839A); } else { uint32Temp = signedMultiplier + 1; uint32SetBit = uint32Temp &amp; 0x2; if (uint32Temp &amp; 0x2) { doubleTemp = xAbs - Asdouble(0x3FE921FB54442D18); } else { doubleTemp = xAbs; } } doubleTempSquare = doubleTemp * doubleTemp; doubleTempX = (Asdouble(0x3EC71D9AA585BFC4) * (doubleTempSquare * doubleTempSquare) + Asdouble(0x3F81111110FD4208)) * (doubleTempSquare * doubleTempSquare) * doubleTemp + doubleTemp + ((Asdouble(0xBE5AA2880297FC43) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBF2A019FD9BD0882)) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBFC555555555516D)) * doubleTempSquare * doubleTemp; onesIndex = ((uint32Temp + 0x2) &gt;&gt; 0x2) &amp; 1; doubleTempY = (Asdouble(0x3EFA01299942AB00) * (doubleTempSquare * doubleTempSquare) + Asdouble(0x3FA5555555150951)) * (doubleTempSquare * doubleTempSquare) + 1.0 + ((Asdouble(0xBE9247507B5EE59E) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBF56C16BAE710FF8)) * (doubleTempSquare * doubleTempSquare) + Asdouble(0xBFDFFFFFFFFFE6A2)) * doubleTempSquare; onesConvDouble = ones[(uint32Temp &gt;&gt; 0x2) &amp; 1 ^ xSign]; if (uint32SetBit) { *outputX = doubleTempY * onesConvDouble; *outputY = doubleTempX * ones[onesIndex]; } else { *outputX = doubleTempX * onesConvDouble; *outputY = doubleTempY * ones[onesIndex]; } return 0;}","link":"/2023/09/28/limb%E8%A7%84%E8%8C%83%E6%A0%87%E5%87%86%EF%BC%88%E8%AF%95%E8%A1%8C%EF%BC%89/"},{"title":"limb_compound开发项目日志","text":"关于compound_float函数的代码调试及精度测试2023.10.13当前状态：代码未通过编译 ‘_libm_error_support‘ 报错为 未声明的函数 此函数是否为库函数 是否需要进行链接 解决办法：直接注释 ‘_libm_exp‘ 同上 compound_float0.c:198:1: warning: non-void function does not return a value in all control paths [-Wreturn-type] 非void函数 在每个分支都没有返回值 ida中反汇编的源代码函数为void类型 log1p 在ida源代码中为**_libm_log1p** vscode中报错为未定义的函数 2023.10.30 compound double类型函数 调试后 修改代码205行和208行 为result和v77值添加负号 结果：精度从60%提升到79% ida第87行代码 第999993个测试数上 x86结果为nan 即-(0.0/0.0)，但arm上结果为 1.0 若进行更改则精度降低 比如第999998个测试数上x86又为1.0，arm为-nan 是否要进行加入条件分支？条件如何选择？","link":"/2023/10/13/limb%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/"},{"title":"linux_01_open","text":"12345678910111213141516171819202122232425262728293031323334#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()int main(int argc, char **argv){ int fd; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } fd = open(argv[1], O_RDWR);//can read &amp;&amp; can write if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ sleep(10); } close(fd); return 0;}","link":"/2024/10/07/linux_01_open/"},{"title":"linux_02_create","text":"1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()int main(int argc, char **argv){ int fd; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0777);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ sleep(10); } close(fd); return 0;}","link":"/2024/10/07/linux_02_create/"},{"title":"linux_03_write","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./write 1.txt str1 str2*/int main(int argc, char **argv){ int fd; int i; int len; if (argc &lt; 3){ printf(&quot;Usage: %s &lt;file&gt; &lt;str1&gt; &lt;str2&gt; ...\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, 0644);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } for (i = 2; i &lt; argc; i++){ len = write(fd, argv[i], strlen(argv[i])); if(len != strlen(argv[i])){ perror(&quot;write&quot;); break; } write(fd, &quot;\\r\\n&quot;, 2); } close(fd); return 0;}","link":"/2024/10/07/linux_03_write/"},{"title":"linux_04_read","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./read 1.txt*/int main(int argc, char **argv){ int fd; int i; int len; unsigned char buf[100]; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDONLY);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;read&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } while (1){ len = read(fd, buf, sizeof(buf)-1); if(len &lt; 0){ perror(&quot;read&quot;); close(fd); return -1; }else if(len == 0){ break; }else{ buf[len-1] = '\\0';// set the end sign printf(&quot;%s\\n&quot;,buf); } } close(fd); return 0;}","link":"/2024/10/07/linux_04_read/"},{"title":"linux_03_write_in_pos","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* ./write 1.txt str1 str2*/int main(int argc, char **argv){ int fd; int i; int len; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;,argv[0]); return -1; } // heart of code fd = open(argv[1], O_RDWR | O_CREAT, 0644);//can read &amp;&amp; can write // heart of code if (fd &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); printf(&quot;errno = %d\\n&quot;, errno);// error number printf(&quot;err: %s\\n&quot;, strerror(errno));// error string info perror(&quot;open&quot;); } else { printf(&quot;fd = %d\\n&quot;, fd); } printf(&quot;lseek to offset 3 from file head\\n&quot;); lseek(fd, 3, SEEK_SET); // SEEK_SET: from the begin to offset write(fd, &quot;123&quot;, 3); close(fd); return 0;}","link":"/2024/10/07/linux_03_write_in_pos/"},{"title":"linux_05_Makefile","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152CROSS_COMPILE = AS = $(CROSS_COMPILE)asLD = $(CROSS_COMPILE)ldCC = $(CROSS_COMPILE)gccCPP = $(CC) -EAR = $(CROSS_COMPILE)arNM = $(CROSS_COMPILE)nmSTRIP = $(CROSS_COMPILE)stripOBJCOPY = $(CROSS_COMPILE)objcopyOBJDUMP = $(CROSS_COMPILE)objdumpexport AS LD CC CPP AR NMexport STRIP OBJCOPY OBJDUMPCFLAGS := -Wall -O2 -gCFLAGS += -I $(shell pwd)/includeLDFLAGS := export CFLAGS LDFLAGSTOPDIR := $(shell pwd)export TOPDIRTARGET := testobj-y += main.oobj-y += sub.oobj-y += a/all : start_recursive_build $(TARGET) @echo $(TARGET) has been built!start_recursive_build: make -C ./ -f $(TOPDIR)/Makefile.build$(TARGET) : start_recursive_build $(CC) -o $(TARGET) built-in.o $(LDFLAGS)clean: rm -f $(shell find -name &quot;*.o&quot;) rm -f $(TARGET)distclean: rm -f $(shell find -name &quot;*.o&quot;) rm -f $(shell find -name &quot;*.d&quot;) rm -f $(TARGET)","link":"/2024/10/07/linux_05_Makefile/"},{"title":"linux_05_Process_excel","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */static int read_line(int fd, unsigned char *buf){ // read for loop a char // how to judge already read a line, read until 0x0d 0x0a unsigned char c; int len; int i = 0; int err = 0; while (1){ len = read(fd, &amp;c, 1); if(len &lt;= 0){ // read no data err = -1; break; }else{ if (c != '\\n' &amp;&amp; c != '\\r'){ buf[i] = c; i++; }else{ // read \\n and \\r, already read a line err = 0; break; } } } // read end OR \\r\\n, fix \\0 in the buf, \\0 means null char, ASCII = 0 buf[i] = '\\0'; if(err &amp;&amp; i==0){ // read end but no data return -1; }else{ return i; }}void process_data(unsigned char *data_buf, unsigned char *result_buf){ /* test 1: data_buf = &quot;,yuwen,shuxue,yingyu,zongfen,pingjia&quot; result_buf = &quot;,yuwen,shuxue,yingyu,zongfen,pingjia&quot; test 2: data_buf = &quot;zhangsan,90,91,92,,&quot; result_buf = &quot;zhangsan,90,91,92,273,A+&quot; */ char name[100]; int scores[3]; int sum = 0; int level; char *levels[] = {&quot;A+&quot;,&quot;A&quot;,&quot;B&quot;};// &gt;=90, &gt;=80, &lt;80 if(data_buf[0] == 0xef){ // for UTF-8 (BOM), first line, first 3 chars: 0xef 0xbb 0xbf strcpy(result_buf, data_buf); // help: man strcpy(shell) // printf(&quot;data_buf: %s&quot;,data_buf); }else{ // use sscanf() separate ',' and other char // %[] means scanf be ruled, '^' means NO, '^,' means NO ',' but other char could sscanf(data_buf, &quot;%[^,],%d,%d,%d,&quot;, name, &amp;scores[0], &amp;scores[1], &amp;scores[2]); // printf(&quot;result: %s,%d,%d,%d\\n&quot;,name, scores[0], scores[1], scores[2]); sum = scores[0] + scores[1] + scores[2]; level = sum &gt;= 270? 0: (sum &gt;= 240? 1:2); sprintf(result_buf,&quot;%s,%d,%d,%d,%d,%s&quot;, name, scores[0], scores[1], scores[2], sum, levels[level]); // printf(&quot;result: %s&quot;,result_buf); }}/* ./process_excel data.csv result.csv argc = 3 argv[0] = &quot;./process_excel&quot; argv[1] = &quot;data.csv&quot; argv[2] = &quot;result.csv&quot;*/int main(int argc, char **argv){ int fd_data, fd_result; int i; int len; unsigned char data_buf[1000]; unsigned char result_buf[1000]; if (argc != 3){ printf(&quot;Usage: %s &lt;data csv file&gt; &lt;result csv file&gt;\\n&quot;,argv[0]); return -1; } // open the first csv file fd_data = open(argv[1], O_RDONLY);//can read &amp;&amp; can write if (fd_data &lt; 0){ printf(&quot;can not open file %s\\n&quot;, argv[1]); perror(&quot;open&quot;); return -1; } else { printf(&quot;data file fd = %d\\n&quot;, fd_data); } // create by open the result csv file fd_result = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0644);//can read &amp;&amp; can write if (fd_result &lt; 0){ printf(&quot;can not create file %s\\n&quot;, argv[2]); perror(&quot;create&quot;); return -1; } else { printf(&quot;data file fd = %d\\n&quot;, fd_result); } // processing while (1){ // read 1 line from data file len = read_line(fd_data, data_buf); if (len == -1){ break; } //if (len != 0){ // printf(&quot;line: %s\\n\\r&quot;,data_buf); //} if (len != 0){ // process data from 1 line process_data(data_buf,result_buf); // write data in result file write(fd_result, result_buf, strlen(result_buf)); write(fd_result,&quot;\\r\\n&quot;,2); // printf(&quot;result_buf: %s&quot;,result_buf); } } close(fd_data); close(fd_result); return 0;}","link":"/2024/10/11/linux_05_process_excel/"},{"title":"linux_07_dup","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */int main(int argc, char **argv){ char buf[10]; char buf2[10]; if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;, argv[0]); return -1; } int fd = open(argv[1], O_RDONLY); int fd2 = open(argv[1], O_RDONLY); int fd3 = dup(fd); printf(&quot;fd = %d\\n&quot;, fd); printf(&quot;fd2 = %d\\n&quot;, fd2); printf(&quot;fd3 = %d\\n&quot;, fd3); if (fd &lt; 0 || fd2 &lt; 0 || fd3 &lt; 0){ printf(&quot;can not open %s\\n&quot;, argv[1]); return -1; } read(fd, buf, 1); read(fd2, buf2, 1); printf(&quot;data get from fd : %c\\n&quot;, buf[0]); printf(&quot;data get from fd2: %c\\n&quot;, buf2[0]); read(fd3, buf, 1); printf(&quot;data get from fd3: %c\\n&quot;, buf[0]); return 0;}","link":"/2024/10/17/linux_07_dup/"},{"title":"linux_11_input_01_get_input_info","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;/* ./01_get_input_info /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } return 0;}","link":"/2024/10/30/linux_11_input_01_get_input_info/"},{"title":"linux_11_input_03_input_read_poll","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;/* ./03_input_read_poll /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; struct pollfd fds[1]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd; fds[0].events = POLLIN; fds[0].revents = 0; ret = poll(fds,nfds,5000); if(ret &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_03_input_read_poll/"},{"title":"linux_11_input_03_input_read_poll_more","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;/* ./03_input_read_poll_more /dev/input/event0 /dev/input/event1**/int main(int argc, char **argv){ int fd1,fd2; int err1,err2; int len1,len2; int ret1,ret2; int i; unsigned char byte; int bit; struct input_id id[2]; unsigned int evbit[2]; struct input_event event; struct pollfd fds[2]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc &lt; 2){ printf(&quot;Usage: %s &lt;dev&gt; &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd1 = open(argv[1], O_RDWR | O_NONBLOCK); if(fd1 &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } fd2 = open(argv[2], O_RDWR | O_NONBLOCK); if(fd2 &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[2]); return -1; } // get dev info err1 = ioctl(fd1, EVIOCGID, &amp;id[0]); if(err1 == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id[0].bustype); printf(&quot;vendor = 0x%x\\n&quot;, id[0].vendor ); printf(&quot;product = 0x%x\\n&quot;, id[0].product); printf(&quot;version = 0x%x\\n&quot;, id[0].version); } err2 = ioctl(fd2, EVIOCGID, &amp;id[1]); if(err2 == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id[1].bustype); printf(&quot;vendor = 0x%x\\n&quot;, id[1].vendor ); printf(&quot;product = 0x%x\\n&quot;, id[1].product); printf(&quot;version = 0x%x\\n&quot;, id[1].version); } // get evbit len1 = ioctl(fd1, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len1 &gt; 0 &amp;&amp; len1 &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len1;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } len2 = ioctl(fd2, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len2 &gt; 0 &amp;&amp; len2 &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len2;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd1; fds[0].events = POLLIN; fds[0].revents = 0; fds[1].fd = fd2; fds[1].events = POLLIN; fds[1].revents = 0; ret1 = poll(&amp;fds[0],nfds,5000); ret2 = poll(&amp;fds[1],nfds,5000); if(ret1 &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd1,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret1 == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } if(ret2 &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd2,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret2 == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_03_input_read_poll_more/"},{"title":"linux_11_input_02_input_read","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;/* ./02_input_read /dev/input/event0 noblock **/int main(int argc, char **argv){ int fd; int err; int len; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc &lt; 2){ printf(&quot;Usage: %s &lt;dev&gt; [noblock]\\n&quot;,argv[0]); return -1; } // open dev file if(argc == 3 &amp;&amp; !strcmp(argv[2],&quot;noblock&quot;)){ fd = open(argv[1], O_RDWR | O_NONBLOCK); }else{ fd = open(argv[1], O_RDWR); } if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ len = read(fd,&amp;event,sizeof(event)); if(len == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); }else{ printf(&quot;read err %d\\n&quot;,len); } } return 0;}","link":"/2024/10/31/linux_11_input_02_input_read/"},{"title":"linux_06_app_libc_kernel","text":"12345678910111213141516171819202122232425262728#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt; // .h file for sleep() and close()/* return value n : data number from read a line (n &gt;= 0) return value -1: read end OR error */int main(int argc, char **argv){ if (argc != 2){ printf(&quot;Usage: %s &lt;file&gt;\\n&quot;, argv[0]); return -1; } int fd = open(argv[0], O_RDONLY); printf(&quot;fd = %d\\n&quot;, fd); while (1){ sleep(100); } return 0;}","link":"/2024/10/17/linux_06_app_libc_kernel/"},{"title":"linux_11_input_04_input_read_select","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;poll.h&gt;#include &lt;sys/select.h&gt;/* ./04_input_read_select /dev/input/event0 **/int main(int argc, char **argv){ int fd; int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; struct input_event event; struct pollfd fds[1]; nfds_t nfds = 1; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // open dev file fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } while(1){ fds[0].fd = fd; fds[0].events = POLLIN; fds[0].revents = 0; ret = poll(fds,nfds,5000); if(ret &gt; 0){ if(fds[0].revents == POLLIN){ while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); } } }else if(ret == 0){ printf(&quot;time out\\n&quot;); }else{ printf(&quot;poll err\\n&quot;); } } return 0;}","link":"/2024/10/31/linux_11_input_04_input_read_select/"},{"title":"linux_11_input_05_input_read_fasync","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;linux/input.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* ./05_input_read_fasync /dev/input/event0 **/int fd;void my_sig_handler(int sig){ struct input_event event; while(read(fd,&amp;event,sizeof(event)) == sizeof(event)){ printf(&quot;get event: type = 0x%x, code = 0x%x, value = 0x%x\\n&quot;,event.type, event.code, event.value); }}int main(int argc, char **argv){ int err; int len; int ret; int i; unsigned char byte; int bit; struct input_id id; unsigned int evbit[2]; unsigned int flags; int count = 0; char *ev_names[] = { &quot;EV_SYN &quot;, &quot;EV_KEY &quot;, &quot;EV_REL &quot;, &quot;EV_ABS &quot;, &quot;EV_MSC &quot;, &quot;EV_SW &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;NULL &quot;, &quot;EV_LED &quot;, &quot;EV_SND &quot;, &quot;NULL &quot;, &quot;EV_REP &quot;, &quot;EV_FF &quot;, &quot;EV_PWR &quot;, }; if(argc != 2){ printf(&quot;Usage: %s &lt;dev&gt;\\n&quot;,argv[0]); return -1; } // register siganl process function signal(SIGIO,my_sig_handler); // open drive app fd = open(argv[1], O_RDWR | O_NONBLOCK); if(fd &lt; 0){ printf(&quot;open %s err\\n&quot;,argv[1]); return -1; } // get dev info err = ioctl(fd, EVIOCGID, &amp;id); if(err == 0){ printf(&quot;bustype = 0x%x\\n&quot;, id.bustype); printf(&quot;vendor = 0x%x\\n&quot;, id.vendor ); printf(&quot;product = 0x%x\\n&quot;, id.product); printf(&quot;version = 0x%x\\n&quot;, id.version); } // get evbit len = ioctl(fd, EVIOCGBIT(0,sizeof(evbit)), &amp;evbit); if(len &gt; 0 &amp;&amp; len &lt;= sizeof(evbit)){ printf(&quot;support ev type: &quot;); for(i=0;i&lt;len;i++){ byte = ((unsigned char *)evbit)[i]; for(bit=0;bit&lt;8;bit++){ if(byte &amp; (1&lt;&lt;bit)){ printf(&quot;%s &quot;,ev_names[i*8 + bit]); } } } printf(&quot;\\n&quot;); } // bring pid of app to drive app fcntl(fd,F_SETOWN,getpid()); // make fasync flags = fcntl(fd,F_GETFL); fcntl(fd,F_SETFL,flags | FASYNC); while(1){ printf(&quot;main loop count = %d\\n&quot;,count++); sleep(2); } return 0;}","link":"/2024/10/31/linux_11_input_05_input_read_fasync/"},{"title":"linux_11_socket_tcp_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket connect send/recv*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_STREAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // connect iAddrLen = sizeof(struct sockaddr); iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; } // send while(1){ if(fgets(ucSendBuf, 999, stdin)){ iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_tcp_client/"},{"title":"linux_11_socket_tcp_server","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* socket bind listen accept send/ recv*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;#define SERVER_PORT 8888#define BACKLOG 10int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// accpet int iSocketClient; int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept signal(SIGCHLD, SIG_IGN); // socket // (IPv4,TCP,protocol) iSocketServer = socket(AF_INET, SOCK_STREAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // listen iRet = listen(iSocketServer, BACKLOG); if(iRet == -1){ printf(&quot;listen error!\\n&quot;); return -1; } // accept while(1){ iAddrLen = sizeof(struct sockaddr); iSocketClient = accept(iSocketServer, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iSocketClient != -1){ iClientNum++; printf(&quot;Get connect from client %d : %s\\n&quot;, iClientNum, inet_ntoa(tSocketClientAddr.sin_addr)); if(!fork()){ // son while(1){ // accpet and display data from client iRecvLen = recv(iSocketClient, ucRecvBuf, 999, 0); if(iRecvLen &lt;= 0){ close(iSocketClient); return -1; }else{ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %d: %s\\n&quot;, iClientNum, ucRecvBuf); } } } } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_tcp_server/"},{"title":"linux_11_socket_udp_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket connect sendto/recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_DGRAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // connect iAddrLen = sizeof(struct sockaddr); iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; } // send while(1){ if(fgets(ucSendBuf, 999, stdin)){ iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_udp_client/"},{"title":"linux_11_socket_udp_no_connect_client","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;/* socket sendto/recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; connect int iRet;// connect unsigned char ucSendBuf[1000];// send int iSendLen; int iAddrLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } // socket iSocketClient = socket(AF_INET, SOCK_DGRAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host if(inet_aton(argv[1], &amp;(tSocketServerAddr.sin_addr)) == 0){ printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset()#if 0 // connect iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;connect error!\\n&quot;); return -1; }#endif // send while(1){ if(fgets(ucSendBuf, 999, stdin)){#if 0 iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); #else iAddrLen = sizeof(struct sockaddr); iSendLen = sendto(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen);#endif if(iSendLen &lt;= 0){ close(iSocketClient); return -1; } } } return 0;}","link":"/2024/10/27/linux_11_socket_udp_no_connect_client/"},{"title":"linux_11_socket_udp_no_connect_server","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* socket bind sendto/ recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// recvfrom int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept // socket // (IPv4,UDP,protocol) iSocketServer = socket(AF_INET, SOCK_DGRAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // recvfrom while(1){ // accpet and display data from client iAddrLen = sizeof(struct sockaddr); iRecvLen = recvfrom(iSocketServer, ucRecvBuf, 999, 0, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iRecvLen &gt; 0){ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %s: %s\\n&quot;, inet_ntoa(tSocketClientAddr.sin_addr), ucRecvBuf); } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_udp_no_connect_server/"},{"title":"linux_11_socket_udp_server","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;signal.h&gt;/* socket bind sendto/ recvfrom*/#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketServer;// socket struct sockaddr_in tSocketServerAddr;// socket &amp;&amp; bind struct sockaddr_in tSocketClientAddr;// recvfrom int iRet;// bind int iAddrLen;//accept int iRecvLen; // accept unsigned char ucRecvBuf[1000];// accept int iClientNum = -1;// accept // socket // (IPv4,UDP,protocol) iSocketServer = socket(AF_INET, SOCK_DGRAM, 0); if(iSocketServer == -1){ printf(&quot;socker error!\\n&quot;); return -1; } // bind // sockaddr *addr tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT);// host to net, short tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// all ip from host memset(tSocketServerAddr.sin_zero, 0, 8); // set sin_zero to zero by memset() // (sockfd,sockaddr *addr, socklen_t addrlen) iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(iRet == -1){ printf(&quot;bind error!\\n&quot;); return -1; } // recvfrom while(1){ // accpet and display data from client iAddrLen = sizeof(struct sockaddr); iRecvLen = recvfrom(iSocketServer, ucRecvBuf, 999, 0, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(iRecvLen &gt; 0){ ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %s: %s\\n&quot;, inet_ntoa(tSocketClientAddr.sin_addr), ucRecvBuf); } } close(iSocketServer); return 0;}","link":"/2024/10/27/linux_11_socket_udp_server/"},{"title":"linux_13_pthread0","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;// static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic pthread_cond_t g_tConVar = PTHREAD_COND_INITIALIZER;// conditionstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); // sem_wait(&amp;g_sem); pthread_mutex_lock(&amp;g_tMutex); pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex); /*print*/ // pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; // sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_cond_signal(&amp;g_tConVar);/*notice recv thread*/ pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 1; // sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread0/"},{"title":"linux_13_pthread1","text":"1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;static void *my_thread_func (void *data){ while(1){ sleep(1); }}int main(int argc, char **argv){ pthread_t tid; int ret; /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ sleep(1); } return 0;}","link":"/2024/10/27/linux_13_pthread1/"},{"title":"linux_13_pthread2","text":"12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;static char g_buf[1000];static int g_hasData = 0;static void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ while(g_hasData == 0); /*print*/ printf(&quot;recv: %s\\n&quot;, g_buf); g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(g_buf, 1000, stdin); /*notice recv thread*/ g_hasData = 1; } return 0;}","link":"/2024/10/27/linux_13_pthread2/"},{"title":"linux_13_pthread3","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;static char g_buf[1000];// static int g_hasData = 0;static sem_t g_sem; //signalstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); sem_wait(&amp;g_sem); /*print*/ printf(&quot;recv: %s\\n&quot;, g_buf); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(g_buf, 1000, stdin); /*notice recv thread*/ // g_hasData = 1; sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread3/"},{"title":"linux_13_pthread4","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); sem_wait(&amp;g_sem); /*print*/ pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_mutex_unlock(&amp;g_tMutex); /*notice recv thread*/ // g_hasData = 1; sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread4/"},{"title":"linux_13_pthread5","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;semaphore.h&gt;#include &lt;string.h&gt;static char g_buf[1000];// static int g_hasData = 0;// static sem_t g_sem; //signalstatic pthread_mutex_t g_tMutex = PTHREAD_MUTEX_INITIALIZER;// mutexstatic pthread_cond_t g_tConVar = PTHREAD_COND_INITIALIZER;// conditionstatic void *my_thread_func (void *data){ while(1){ sleep(1); /*waiting notice*/ // while(g_hasData == 0); // sem_wait(&amp;g_sem); pthread_mutex_lock(&amp;g_tMutex); pthread_cond_wait(&amp;g_tConVar, &amp;g_tMutex); /*print*/ // pthread_mutex_lock(&amp;g_tMutex); printf(&quot;recv: %s\\n&quot;, g_buf); pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 0; } return NULL;}int main(int argc, char **argv){ pthread_t tid; int ret; char buf[1000]; // sem_init(&amp;g_sem, 0, 0); /*1. create &quot;recv thread&quot;*/ ret = pthread_create(&amp;tid, NULL, my_thread_func, NULL); if(ret != 0){ printf(&quot;pthread_create err!\\n&quot;); return -1; } /*2. read stdio by main thread, send to &quot;recv thread&quot;*/ while(1){ fgets(buf, 1000, stdin); pthread_mutex_lock(&amp;g_tMutex); memcpy(g_buf, buf, 1000); // reduce time of main thread which uses g_buf pthread_cond_signal(&amp;g_tConVar);/*notice recv thread*/ pthread_mutex_unlock(&amp;g_tMutex); // g_hasData = 1; // sem_post(&amp;g_sem); } return 0;}","link":"/2024/10/27/linux_13_pthread5/"},{"title":"linux_i2c_at24c02","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;sys/ioctl.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;linux/i2c.h&gt;#include &lt;linux/i2c-dev.h&gt;#include &lt;i2c/smbus.h&gt;#include &quot;i2cbusses.h&quot;#include &lt;time.h&gt;/* ./at24c02 &lt;i2c_bus_number&gt; w &quot;100ask.taobao.com&quot; ./at24c02 &lt;i2c_bus_number&gt; r*/int main(int argc, char **argv){ unsigned char dev_addr = 0x50; unsigned char mem_addr = 0; unsigned char buf[32]; int file; char filename[20]; unsigned char *str; struct timespec req; int ret; if(argc != 3 &amp;&amp; argc !=4){ printf(&quot;Usage:\\n&quot;); printf(&quot;write eeprom: %s &lt;i2c_bus_number&gt; w string\\n&quot;,argv[0]); printf(&quot;read eeprom: %s &lt;i2c_bus_number&gt; r\\n&quot;,argv[0]); return -1; } // open i2c device file = open_i2c_dev(argv[1][0]-'0', filename, sizeof(filename), 0); if(file &lt; 0){ printf(&quot;can't open %s\\n&quot;,filename); return -1; } // set slave address if(set_slave_addr(file, dev_addr, 1)){ printf(&quot;can't set_slave_addr\\n&quot;); return -1; } // write or read data if(argv[2][0]=='w'){ // argv[2] is a string, argv[2][0] is a char from the string // write str: argv[3] str = argv[3]; req.tv_sec = 0; req.tv_nsec = 20000000;// 20ms while(*str){ // mem_addr, *str // mem_addr++, str++ ret = i2c_smbus_write_byte_data(file, mem_addr, *str); if(ret){ printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; } // wait tWR(10ms) nanosleep(&amp;req, NULL); mem_addr++; str++; } ret = i2c_smbus_write_byte_data(file, mem_addr, 0);// string end char if(ret){ printf(&quot;i2c_smbus_write_byte_data err\\n&quot;); return -1; } }else{ // read ret = i2c_smbus_read_i2c_block_data(file, mem_addr, sizeof(buf), buf); if(ret &lt; 0){ printf(&quot;i2c_smbus_read_i2c_block_data err\\n&quot;); return -1; } buf[31] = '\\0'; printf(&quot;get data: %s\\n&quot;,buf); } return 0;}","link":"/2024/10/30/linux_i2c_at24c02/"},{"title":"pa0_homework","text":"12345678910111213141516171819202122232425262728293031#include&lt;cmath&gt;#include&lt;eigen3/Eigen/Core&gt;#include&lt;eigen3/Eigen/Dense&gt;#include&lt;iostream&gt;int main(){ // a point P(2,1) a vector Eigen::Vector3f P(2.0f,1.0f,1.0f); std::cout &lt;&lt; &quot;old P \\n&quot; &lt;&lt; P.head&lt;2&gt;() &lt;&lt; std::endl; // a rotation matrix R // [cost, -sint // sint, cost] float t = (45.0 / 180.0) * acos(-1); Eigen::Matrix3f R; R &lt;&lt; cos(t), -sin(t), 0, sin(t), cos(t) , 0, 0 , 0 , 1; // run rotation P = R * P; // + B Eigen::Vector3f B(1.0f,2.0f,0.0f); P = P + B; //output P std::cout &lt;&lt; &quot;new P \\n&quot; &lt;&lt; P.head&lt;2&gt;() &lt;&lt; std::endl; return 0;}","link":"/2024/09/21/pa0_homework/"},{"title":"pa0_main","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cmath&gt;#include&lt;eigen3/Eigen/Core&gt;#include&lt;eigen3/Eigen/Dense&gt;#include&lt;iostream&gt;int main(){ // Basic Example of cpp std::cout &lt;&lt; &quot;Example of cpp \\n&quot;; float a = 1.0, b = 2.0; std::cout &lt;&lt; a &lt;&lt; std::endl; std::cout &lt;&lt; a/b &lt;&lt; std::endl; std::cout &lt;&lt; std::sqrt(b) &lt;&lt; std::endl; std::cout &lt;&lt; std::acos(-1) &lt;&lt; std::endl; std::cout &lt;&lt; std::sin(30.0/180.0*acos(-1)) &lt;&lt; std::endl; // Example of vector std::cout &lt;&lt; &quot;Example of vector \\n&quot;; // vector definition Eigen::Vector3f v(1.0f,2.0f,3.0f); Eigen::Vector3f w(1.0f,0.0f,0.0f); // vector output std::cout &lt;&lt; &quot;Example of output \\n&quot;; std::cout &lt;&lt; v &lt;&lt; std::endl; // vector add std::cout &lt;&lt; &quot;Example of add \\n&quot;; std::cout &lt;&lt; v + w &lt;&lt; std::endl; // vector scalar multiply std::cout &lt;&lt; &quot;Example of scalar multiply \\n&quot;; std::cout &lt;&lt; v * 3.0f &lt;&lt; std::endl; std::cout &lt;&lt; 2.0f * v &lt;&lt; std::endl; // Example of matrix std::cout &lt;&lt; &quot;Example of matrix \\n&quot;; // matrix definition Eigen::Matrix3f i,j; i &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0; j &lt;&lt; 2.0, 3.0, 1.0, 4.0, 6.0, 5.0, 9.0, 7.0, 8.0; // matrix output std::cout &lt;&lt; &quot;Example of output \\n&quot;; std::cout &lt;&lt; i &lt;&lt; std::endl; // matrix add i + j std::cout &lt;&lt; &quot;add i + j \\n&quot; &lt;&lt; i + j &lt;&lt; std::endl; // matrix scalar multiply i * 2.0 std::cout &lt;&lt; &quot;scalar multiply i * 2.0 \\n&quot; &lt;&lt; i * 2.0f &lt;&lt; std::endl; // matrix multiply i * j std::cout &lt;&lt; &quot;multiply i * j \\n&quot; &lt;&lt; i * j &lt;&lt; std::endl; // matrix multiply vector i * v std::cout &lt;&lt; &quot;multiply vector i * v \\n&quot; &lt;&lt; i * v &lt;&lt; std::endl; return 0;}","link":"/2024/09/21/pa0_main/"},{"title":"医学AI学术交流会","text":"基金项目申请-青年基金评审-赵宏 题目很重要 摘要 给出内容和重点 研究背景和意义 研究的紧迫性 研究成果的重要性 研究现状 时效性、全面性、针对性、SOTA 研究内容 重点 拟解决的关键问题 来源于研究内容 研究方案和技术路线 与研究内容对应 体现理论和技术的高度 创新点 来源于研究内容，关键问题 少数即可 年度计划、预期成果 与研究内容相对应 论文、专利、软著、学术交流、人才培养 研究基础和条件 已发表的论文、代表作 需要有相关性 支撑研究的条件 其他 师承、工作单位、文笔、领域、地域、科研经历、评审中出现D一票否决 医生眼中的人工智能-兰州大学第二医院核磁共振科-胡万均 大模型 深度学习神经网络 基于U-net的医学图像问题研究 结合临床实际的研究 前景很好 主要的问题还是 数据集私密的问题 拿不到医学类的数据 医工交叉前景无限 主要是落地到临床实现的应用几乎很少 所有研究都是基于大量数据 缺乏算力 难以进行大模型研究 医学内部的数据量很充分 医学内部的方法学很薄弱 而CS在这方面是强项 医学数据很多 耗费时间很大 而且需要专业的医生或者懂医学的人对模型进行调整 包括对训练结果的监督 利用临床二维图像 基于三维重建模型 生成三维模型 很有意义 医学图像分割 低维图像变高维图像 低分辨率图像变高分辨率图像 神经调控研究-脑电-崔琨博 抑郁症 治疗：经颅磁刺激 TMS 数据采集：脑电采集 设备成本巨大 实验需依靠实验室 源定位 脑电信号 传导到头皮容易受到其中皮层组织的干扰 脑组织电导率不均匀 脑源信号对各个方向都会施加影响 正问题：从头皮映射到源上 逆问题：根据头皮脑信号推算出脑内源活动 应用场景： 边缘计算硬件 对现有框架施加约束项优化定位精度 小型化设备 脑电伪迹去除 动作影响伪迹 设备伪迹 脉冲 充放电 滤波去除伪迹 神经网络方法去除眼电 神经调控 Neuralink 脑机接口 基于行为信息的抑郁识别研究-陶博士 通过提取人的面部表情特征点及语音特征点对于抑郁症的识别 深度学习模型的可解释性-常兆斌 事先可解释性：小样本图像语义分割 主要在语音分割的support与query上进行创新 基于query的信息对support进行指导 提取support与query的信息 找出其共同信息（之间的联系） 主要在特征处理上做 特征解耦 特征重构 大模型与写作技巧-郭岚 大模型微调 大模型迁移 知识蒸馏 数据优先，只要有其他人没有的数据就能做 写作技巧 生成公式 或 代码优化 小样本动作识别与因果学习/因果推理的探索-陈志文 小样本动作识别 因果推理（方法）","link":"/2024/06/01/%E5%AD%A6%E6%9C%AF%E4%BA%A4%E6%B5%81%E4%BC%9A%202024.6.1/"},{"title":"神经渲染：图形学 + 深度学习","text":"神经渲染：图形学 + 深度学习 利用深度学习和图形学技术，实现高质量、高效率、高灵活性的图像合成和渲染的方法，并且能够对图像进行编辑，从而实现多种应用，主要应用于影视动画、游戏开发、虚拟现实、自动驾驶等领域 原理 利用深度学习模型来模拟图形学渲染的过程，实现从输入到输出的端到端映射。 神经渲染是基于数据驱动和统计推断的概率模型，对场景中的信息进行隐式的表示和学习，通过大量的数据来模拟渲染过程； 传统图形学渲染需要基于物理规律和数学模型的确定性算法，需要对场景中的几何、材质和光照等要素进行精确的描述和计算。 主要流程 「空间表示」：指将三维空间中的信息以一种适合于深度学习模型处理的方式进行编码和存储。常见的空间表示方法有体素voxel、点云point cloud、网格mesh、隐函数implicit function等。 「几何重建」：几何重建是指根据输入的二维图像或视频，恢复出三维空间中的几何结构。常见的几何重建方法有多视图立体（multi-view stereo）、结构光（structured light）、深度相机（depth camera）等。 「光照模拟」：光照模拟是指根据输入或预设的光照条件，计算出三维空间中各个位置的光强度和颜色。常见的光照模拟方法有光线追踪（ray tracing）、光线投射（ray casting）、辐射度（radiosity）等。 「视觉合成」：视觉合成是指根据给定或期望的视点位置，生成出对应视角下的二维图像或视频。常见的视觉合成方法有纹理映射（texture mapping）、着色器（shader）、后处理（post-processing）等。 主要特点 「高质量」：生成高分辨率、高真实度、高一致性的图像，从而达到与真实世界或传统图形学渲染相媲美甚至超越的效果。 「高效率」：利用深度学习模型的并行计算和近似推断的能力，大大降低图像合成和渲染的时间和空间复杂度。 「高灵活性」：根据用户的需求和喜好，对图像进行多样化的操控、变换和编辑，实现个性化和创意化的图像生成。神经渲染的深度生成模型 可能用到的模型 「变分自编码器（VAE）」：基于概率图模型的生成模型，由编码器和解码器两部分组成，编码器将输入数据映射到一个潜在空间中的随机变量，解码器将潜在变量映射回输出数据。通过最大化输入数据和输出数据之间的条件对数似然，以及最小化潜在变量和先验分布之间的散度，来学习数据的潜在分布和特征。可以用于神经渲染中的语义图像合成与操控，如根据用户给定的语义标签或草图，生成对应的真实图像，并且对图像中的内容进行添加、删除、移动、替换等操作。 「生成对抗网络（GAN）」：基于博弈论的生成模型，由生成器和判别器两部分组成，生成器将随机噪声或条件输入映射到输出数据，判别器将输入数据判断为真实或伪造。通过最小化生成器和判别器之间的对抗损失，来学习数据的潜在分布和特征。可以用于神经渲染中的目标和场景的新视角合成，如根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 「自回归模型（AR）」：基于链式法则的生成模型，它将输出数据分解为一系列条件概率分布，每个分布依赖于之前生成的数据。通过最大化输出数据的联合对数似然，来学习数据的潜在分布和特征，用于神经渲染中的自由视点视频合成，如根据用户给定的视频序列，生成任意视点下的视频，并且保持视频中的动态物体和背景的运动和连贯性不变。 图形学知识 「光线追踪」：基于物理光学原理的渲染技术，它通过模拟光线从视点出发，在三维空间中与物体表面发生反射、折射、散射等过程，从而计算出每个像素点的颜色和亮度。光线追踪可以用于神经渲染中提供真实感强烈的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中光照条件变化的约束和指导。 「光照模型」：基于数学公式的渲染技术，它通过描述光源、物体表面和观察者之间的光照关系，从而计算出每个像素点的颜色和亮度。光照模型可以用于神经渲染中提供不同复杂度和效果的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中材质和纹理变化的约束和指导。 「几何变换」：基于线性代数的渲染技术，它通过对三维空间中的物体进行平移、旋转、缩放等操作，从而改变物体的位置、方向和大小。几何变换可以用于神经渲染中提供不同视角和姿态的图像合成和渲染效果，以及提供对深度生成模型训练和推理过程中几何结构变化的约束和指导。 光栅化 可能用到的端到端训练方式 「监督学习」：基于标注数据的训练方式，它通过给定输入数据和期望输出数据之间的对应关系，来训练深度生成模型。可以用于神经渲染中提供高质量和高精度的图像合成和渲染效果，但是需要大量的标注数据和计算资源。 「无监督学习」：基于无标注数据的训练方式，它通过利用输入数据或输出数据本身的统计特征或结构信息，来训练深度生成模型。可以用于神经渲染中提供高效率和高灵活性的图像合成和渲染效果，但是需要复杂的模型设计和优化方法。 「弱监督学习」：介于监督学习和无监督学习之间的训练方式，它通过利用输入数据或输出数据之间的部分或隐含的对应关系，来训练深度生成模型。可以用于神经渲染中提供高质量、高效率和高灵活性的图像合成和渲染效果，但是需要合适的先验知识和约束条件。 神经渲染的应用领域 语义图像合成与操控应用的例子 「SPADE」：基于GAN的语义图像合成方法，它通过使用空间自适应归一化（Spatially-Adaptive Normalization）层，将语义标签图作为生成器的输入，并在每个卷积层中根据语义标签图调整特征图的归一化参数，从而实现了对语义标签图中不同区域内容的精确控制。它能够根据用户给定的任意语义标签图，生成逼真且多样化的真实图像，并且能够对图像中的内容进行添加、删除、移动、替换等操作。 「GauGAN」：基于SPADE改进的语义图像合成方法，它通过使用自注意力机制（Self-Attention Mechanism）和多尺度判别器（Multi-Scale Discriminator），增强了生成器的感知能力和判别器的区分能力，从而实现了对语义标签图中细节和全局的更好的生成和判断。它能够根据用户给定的任意草图，生成逼真且多样化的真实图像，并且能够对图像中的内容进行添加、删除、移动、替换等操作。 目标场景新视角合成应用的例子 「NeRF」：基于隐函数的新视角合成方法，它通过使用一个深度神经网络，将三维空间中的每个位置映射到一个颜色和不透明度的值，从而隐式地表示一个连续的三维场景。它能够根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 「NSVF」：基于体素的新视角合成方法，它通过使用一个稀疏体素网格，将三维空间中的每个体素映射到一个颜色和不透明度的值，从而显式地表示一个离散的三维场景。它能够根据用户给定的目标或场景的部分视角，生成其他视角下的图像，并且保持目标或场景的几何结构和光照条件不变。 自由视点视频合成应用的例子 「Neural Volumes」：基于体素和光场的自由视点视频合成方法，它通过使用一个时变体素网格，将三维空间中每个体素映射到一个颜色和不透明度的值，并且使用一个光场编码器，将每个体素进一步映射到一个光线方向相关的颜色和不透明度的值，从而表示一个动态且具有视差效果的三维场景。Neural Volumes能够根据用户给定的视频序列，生成任意视点下的视频，并且保持视频中的动态物体和背景的运动和连贯性不变。 「Relightables」：基于神经网络和光场的学习重新打光方法，它通过使用一个神经网络，将三维空间中的每个位置映射到一个颜色和不透明度的值，并且使用一个光场编码器，将每个位置进一步映射到一个光照相关的颜色和不透明度的值，从而表示一个具有光照信息的三维场景。Relightables能够根据用户给定的目标或场景以及期望的光照条件，生成重新打光后的图像，并且保持目标或场景的材质和纹理不变。 「Neural Relighting」：基于GAN和光照模型的学习重新打光方法，它通过使用一个生成器，将输入图像和期望的光照条件映射到输出图像，并且使用一个判别器，将输出图像和真实图像进行对比。Neural Relighting能够根据用户给定的目标或场景以及期望的光照条件，生成重新打光后的图像，并且保持目标或场景的材质和纹理不变。 人体重建渲染应用的例子 「Neural Body」：基于隐函数和自注意力机制的人体重建渲染方法，它通过使用一个时变隐函数，将三维空间中的每个位置映射到一个颜色和不透明度的值，并且使用一个自注意力机制，将每个位置进一步映射到一个视角相关的颜色和不透明度的值，从而表示一个动态且具有视差效果的人体模型。Neural Body能够根据用户给定的人体图片或视频，生成人体的三维模型，并且能够对人体进行姿态、表情、服装等属性的修改和变换。 「Neural Human」：基于GAN和几何变换的人体重建渲染方法，它通过使用一个生成器，将输入图片或视频中的人体分割、关键点、姿态等信息映射到输出图片或视频，并且使用一个判别器，将输出图片或视频和真实图片或视频进行对比。Neural Human能够根据用户给定的人体图片或视频，生成人体的三维模型，并且能够对人体进行姿态、表情、服装等属性的修改和变换。 神经渲染面临的挑战 技术上面临的挑战： 「真实性和一致性」：神经渲染需要生成与真实世界或传统图形学渲染相媲美甚至超越的图像合成和渲染效果，这需要深度生成模型能够捕捉到数据中的复杂和细微的特征和规律，以及图形学知识能够提供有效和准确的约束和指导。此外，神经渲染还需要保证在不同视角、光照、姿态等条件下，生成的图像具有一致性和连贯性，这需要深度生成模型能够处理数据中的多样性和变化性，以及图形学知识能够提供稳定和可靠的转换和映射。 「复杂性和动态性」：神经渲染需要处理复杂和动态的场景，如多个物体、多种材质、多个光源、多个运动等，这需要深度生成模型能够表示和生成高维度和高分辨率的数据，以及图形学知识能够模拟和计算复杂的物理过程和效果。此外，神经渲染还需要适应用户的需求和喜好，对图像进行多样化的操控、变换和编辑，这需要深度生成模型能够响应和反馈用户的输入，以及图形学知识能够支持和实现用户的操作。 「开销和资源」：神经渲染需要消耗大量的数据、计算、内存等资源，这需要深度生成模型能够有效地利用和优化资源的使用，以及图形学知识能够简化和加速资源的处理。此外，神经渲染还需要考虑用户的体验和满意度，对图像进行实时或近实时的合成和渲染，这需要深度生成模型能够快速地训练和推理，以及图形学知识能够并行地渲染和显示。 应用上面临的挑战： 「质量和可信度」：神经渲染需要保证生成的图像具有高质量和高可信度，这需要对图像进行有效的评估和保证，如使用客观的指标和标准，如峰值信噪比（PSNR）、结构相似性（SSIM）、感知损失（Perceptual Loss）等，来衡量图像的真实性、一致性、清晰度等；或使用主观的方法和手段，如使用人类评估员或用户反馈，来衡量图像的美观性、满意度、偏好等。 「需求和反馈」：神经渲染需要满足用户的需求和喜好，这需要对用户进行有效的分析和理解，如使用用户画像（User Profile）、用户行为（User Behavior）、用户情感（User Emotion）等，来获取用户的基本信息、兴趣爱好、情绪状态等；或使用用户交互（User Interaction）、用户反馈（User Feedback）、用户评价（User Evaluation）等，来获取用户的输入输出、意见建议、评分评价等。 「隐私和版权」：神经渲染需要保护用户的隐私和版权，这需要对数据进行有效的管理和保护，如使用加密（Encryption）、哈希（Hashing）、水印（Watermarking）等，来防止数据被窃取、篡改、泄露等；或使用授权（Authorization）、认证（Authentication）、审计（Audit）等，来防止数据被滥用、侵权、盗用等。 神经渲染是一种将图形学与深度学习相结合的创新方法，它能够实现高质量、高效率、高灵活性的图像合成和渲染，也能够实现多种创意和应用，为图像处理和计算机视觉领域带来了新的可能性和挑战。神经渲染还有着广阔的发展前景和潜力，它可以与其他领域的技术和知识相结合，探索更多的应用场景和领域，促进社会和经济的进步和发展。","link":"/2024/06/11/%E7%A5%9E%E7%BB%8F%E6%B8%B2%E6%9F%93%EF%BC%9A%E5%9B%BE%E5%BD%A2%E5%AD%A6%20+%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"鲲鹏数学库limb精度库 项目文档及部分命令","text":"编译命令 icc -fp-model precise -no-ftz -g filename.cpp -o filename 生成可执行文件 文件 IDA Pro v7.7版本：https://www.52pojie.cn/thread-1640829-1-1.html 类似于IDApro的可以转伪C代码的软件ghidra，https://github.com/NationalSecurityAgency/ghidra/releases 需要java 17 y0f在两个工具上的表现，具有较大差异性，可以参考两者的共性和差异性分析局部代码的实际作用 https://www.cnblogs.com/HDK2016/p/10506083.htmlIEEE 754浮点的存储定义，是一些基本原理在涉及7F和FF开头的NaN和INF两类极端情况值得参考 Linux下编辑、编译、调试命令总结——gcc和gdb描述 Linux常用（实用）命令大全 [C] C语言中的nan和inf使用","link":"/2023/10/30/%E9%B2%B2%E9%B9%8F%E6%95%B0%E5%AD%A6%E5%BA%93limb%E7%B2%BE%E5%BA%A6%E5%BA%93%20%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E5%8F%8A%E9%83%A8%E5%88%86%E5%91%BD%E4%BB%A4/"},{"title":"Leetcode Hot100 46.全排列 递归 回溯法","text":"46.全排列 递归 回溯法 数组、回溯法、C++ Problem: 46.全排列 思路 递归、回溯法 将问题转化为在空数组中填入不重复的数字，不重复的数字则使用标记数组标记 解题过程 定义一个答案数组存储答案，一个临时数组存储排序，一个标记数组标记填过的数字； 递归地，对这个临时数组的每个空位填入给定nums数组的数字，填入后将其标记为true；填入数字后，对其之后的位置继续递归填数，直到当前要填的位置大于等于给定数组即临时数组的长度时将其传入答案数组；每次递归回传之后，再将标记数字的标志变为false，以便于上一层使用。 复杂度 时间复杂度: O(N!) 空间复杂度: O(N) Code 1234567891011121314151617181920212223242526272829303132333435class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; //保存答案 vector&lt;bool&gt; vis; //标记数组，标记数字是否填过 int n;// 数组长度 vector&lt;int&gt; p;// 当前排列 void dfs(const vector&lt;int&gt;&amp; nums, int cur){ // 递归出口 if(cur &gt;= nums.size()){ // 数字全部填完 加入答案数组 res.emplace_back(p); return; } // 遍历空位置进行填数,数字得是没填过的 for(int i = 0; i &lt; n; i++) if(!vis[i]){ vis[i] = true; p[cur] = nums[i]; dfs(nums, cur+1); vis[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { // 给定一个不含重复数字的数组nums // 返回其所有可能的全排列 n = nums.size(); vis.assign(n,false); p.assign(n,0); dfs(nums, 0); return res; }};","link":"/2024/12/27/2024-12-27-Leetcode-Hot100-No.46-%E5%85%A8%E6%8E%92%E5%88%97/"},{"title":"Leetcode Hot100 200.岛屿数量 图论 深度&#x2F;广度优先搜索","text":"200.岛屿数量 图论 深度/广度优先搜索 图论、深度优先搜索、广度优先搜索、C++ Problem: 200.岛屿数量 思路 深度优先搜索 递归实现 广度优先搜索 迭代实现 解题过程 深度优先搜索 1.1 对于给定的二维数组将其视为无向图，对其所有元素进行遍历，如果遇到值为1的元素，就对其进行深度优先搜索（1.2），并赋值为0表示已经遍历过（1.2），岛屿数量+1。 1.2 深度优先搜索。首先将当前值赋0，再判断当前值的上下左右点是否为1，如果为1，对其递归地进行深度优先搜索。 广度优先搜索 2.1 对于给定的二维数组将其视为无向图，对其所有元素进行遍历，如果遇到值为1的元素，就对其进行广度优先搜索（2.2），并赋值为0表示已经遍历过（2.2），岛屿数量+1。 2.2 广度优先搜索。首先定义一个队列，将当前值入队并赋值为0，在队不空时进行操作：将队头元素出队，并判断其上下左右点是否为1，如果为1，则将其加入队列。 复杂度 时间复杂度: O(MN) 空间复杂度: 深度O(MN) 广度 O(min(M,N)) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class Solution {private: // 深度优先搜索 递归实现 void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c){ // 获取数组行数和列数 int nr = grid.size(); int nc = grid[0].size(); // 深度搜索时的操作：将当前格的值设为0，表示已经遍历过 grid[r][c] = '0'; // 遍历上下左右四个 if(r-1 &gt;= 0 &amp;&amp; grid[r-1][c]=='1') dfs(grid,r-1,c);// 上 if(r+1 &lt; nr &amp;&amp; grid[r+1][c]=='1') dfs(grid,r+1,c);// 下 if(c-1 &gt;= 0 &amp;&amp; grid[r][c-1]=='1') dfs(grid,r,c-1);// 左 if(c+1 &lt; nc &amp;&amp; grid[r][c+1]=='1') dfs(grid,r,c+1);// 右 } // 广度优先搜索 队列实现 void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int r, int c){ // 获取数组行数和列数 int nr = grid.size(); int nc = grid[0].size(); // 深度搜索时的操作：将当前格的值设为0，表示已经遍历过 grid[r][c] = '0'; // 定义一个队列实现bfs queue&lt;pair&lt;int, int&gt;&gt; neighbors; // 将当前点入队 neighbors.push({r, c}); // 当队列不空的时候进行循环操作 while (!neighbors.empty()) { // 获取队头元素的值 auto rc = neighbors.front(); // 将队头元素出队 neighbors.pop(); // 获取当前点的行和列 int row = rc.first, col = rc.second; // 对当前点的上边判断 如果值为1 则将其入队 并赋值为0 if (row - 1 &gt;= 0 &amp;&amp; grid[row-1][col] == '1') { neighbors.push({row-1, col}); grid[row-1][col] = '0'; } // 对当前点的下边判断 如果值为1 则将其入队 并赋值为0 if (row + 1 &lt; nr &amp;&amp; grid[row+1][col] == '1') { neighbors.push({row+1, col}); grid[row+1][col] = '0'; } // 对当前点的左边判断 如果值为1 则将其入队 并赋值为0 if (col - 1 &gt;= 0 &amp;&amp; grid[row][col-1] == '1') { neighbors.push({row, col-1}); grid[row][col-1] = '0'; } // 对当前点的右边判断 如果值为1 则将其入队 并赋值为0 if (col + 1 &lt; nc &amp;&amp; grid[row][col+1] == '1') { neighbors.push({row, col+1}); grid[row][col+1] = '0'; } } }public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) { /* 方法一 深度优先搜索 思路：将二维网格看成一个无向图，竖直或水平相邻的1之间有边。 线性扫描二位网络，如果一个结点包含1，则以其为根据点进行深度优先搜索。 在深度优先搜索过程中，每个访问过的节点被标记为0。 计数启动深度优先搜索的根结点数量，就是岛屿的数量。 */ // 获取数组行数和列数 int nr = grid.size(); if(!nr) return 0; int nc = grid[0].size(); // 岛屿计数 int num_islands = 0; // 遍历数组中每个元素 for(int r=0;r&lt;nr;++r){ for(int c=0;c&lt;nc;++c){ if(grid[r][c]=='1'){ ++num_islands; // dfs(grid,r,c); bfs(grid,r,c); } } } return num_islands; }};","link":"/2024/12/24/2024-12-24-Leetcode-Hot100-No.200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"},{"title":"Leetcode Hot100 2.两数相加 链表","text":"2.两数相加 链表 链表、C++ Problem: 2.两数相加 思路 只需掌握链表和初等数学基本知识即可 解题过程 对于两个链表的每个值进行以下操作： 将两个链表的值逐步进行加和，并计算其是否进位，如果进位，下一位数字加上进位值，进位值一般是1，初始为0； 在每次进行逐值加和之后，将其插入新链表，新链表维护一个头指针和一个尾指针； 如果l1和l2的长度不相等，则将更长的链表后续值视为0进行加和即可，在遍历完后要对长度更长的链表的指针进行移一位操作； 在计算完所有数字后，如果进位值大于0，表示最后一位的数值加和进位了，两数之和升了一位，则将进位值加入新链表即可。 复杂度 时间复杂度: O(max(m,n)) 空间复杂度: O(1) Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { // 先将结果链表的头指针和尾指针置空 ListNode *head = nullptr, *tail = nullptr; // 初始化进位值 int carry = 0; // 遍历l1和l2链表 while(l1 || l2){ // 如果l1不指向空（l1是第一个链表的指针） int n1 = l1 ? l1-&gt;val:0; int n2 = l2 ? l2-&gt;val:0; // 将每两个节点的值之和加起来加入新链表 int sum = n1 + n2 + carry; if(!head){ // 如果新链表为空 则将头尾指针都初始化为第一个值 head = tail = new ListNode(sum % 10); }else{ // 否则逐个在尾指针后加入 tail-&gt;next = new ListNode(sum % 10); tail = tail-&gt;next; } // 计算进位值 下一位数字使用 carry = sum / 10; // 如果l1还未结束 则将l2的值看作0 再次加和即可 if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; } // 如果计算完所有值后进位值大于0 说明两数之和升了一位 if(carry &gt; 0) tail-&gt;next = new ListNode(carry); return head; }};","link":"/2024/12/30/2024-12-30-Leetcode-Hot100-No.2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"Leetcode Hot100 3. 无重复字符的最长子串 字符串 哈希表 滑动窗口","text":"3. 无重复字符的最长子串 C++、哈希表、字符串、滑动窗口 Problem: 3. 无重复字符的最长子串 思路 1.无重复子串=哈希表2.子串问题=滑动窗口 解题过程 具体看注释：思路懂，代码没理解透彻，需要再次看一两遍视频和代码 复杂度 时间复杂度: O(n) 空间复杂度: O(n) Code 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int lengthOfLongestSubstring(string s) { // 判断值 if(s.length()==0) return 0; // 不重复字符：使用散列表 // unordered_map是基于哈希表的键值对map，其中的每个键是唯一的 unordered_map&lt;char,int&gt; hashTable; int maxLength = 0; int currentLength = 0; int startIndex = 0; // 遍历字符串 for(int i=0;i&lt;s.length();i++){ // 如果当前遍历到的字符s[i]不在哈希表里，则加入子串=当前子串长度加1并将其索引加入哈希表 if(hashTable.find(s[i]) == hashTable.end()){ // find如果找到该字符则会返回该字符的位置，没有找到则会返回哈希表的最后一个元素的位置 currentLength++; hashTable[s[i]] = i; }else{ // 此分支表明字符在哈希表里，说明字符重复 if(currentLength &gt; maxLength){ // 更新最大子串长度 maxLength = currentLength; } // 重定位滑动窗口开始位置 startIndex = max(hashTable[s[i]], startIndex); currentLength = i - startIndex; hashTable[s[i]] = i; } } if(currentLength &gt; maxLength){ // 更新最后一次 maxLength = currentLength; } return maxLength; }};","link":"/2025/02/06/2025-2-6-Leetcode-Hot100-No.3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"title":"Leetcode Hot100 49. 字母异位词分组 哈希表 字符串分类","text":"49. 字母异位词分组 哈希表 字符串分类 C++、哈希表、字符串分类 Problem: 49. 字母异位词分组 思路 字母异位词：单词的字母按顺序排序后得到的词 题目转变1：把字母排序一致的单词放在一起 题目转变2：把单词中每个字母的个数相同的单词放在一起 模式识别：需要根据特征进行归类——散列表 解题过程 此题解为方法一，具体看代码注释，方法二需要自定义哈希函数，不采用。 复杂度 方法一： 时间复杂度: O(NK logK ) 分类时间：O(N) 排序时间：O(KlogK) 空间复杂度: O(NK) Code 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: int lengthOfLongestSubstring(string s) { // 判断值 if(s.length()==0) return 0; // 不重复字符：使用散列表 // unordered_map是基于哈希表的键值对map，其中的每个键是唯一的 unordered_map&lt;char,int&gt; hashTable; int maxLength = 0; int currentLength = 0; int startIndex = 0; // 遍历字符串 for(int i=0;i&lt;s.length();i++){ // 如果当前遍历到的字符s[i]不在哈希表里，则加入子串=当前子串长度加1并将其索引加入哈希表 if(hashTable.find(s[i]) == hashTable.end()){ // find如果找到该字符则会返回该字符的位置，没有找到则会返回哈希表的最后一个元素的位置 currentLength++; hashTable[s[i]] = i; }else{ // 此分支表明字符在哈希表里，说明字符重复 if(currentLength &gt; maxLength){ // 更新最大子串长度 maxLength = currentLength; } // 重定位滑动窗口开始位置 startIndex = max(hashTable[s[i]], startIndex); currentLength = i - startIndex; hashTable[s[i]] = i; } } if(currentLength &gt; maxLength){ // 更新最后一次 maxLength = currentLength; } return maxLength; }};","link":"/2025/02/07/2025-2-7-Leetcode-Hot100-No.49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"title":"Leetcode Hot100 102. 二叉树的层序遍历 广度优先搜索 队列","text":"102. 二叉树的层序遍历 广度优先搜索 队列 队列、广度优先搜索、C++ Problem: 102. 二叉树的层序遍历 思路 广度优先搜索，队列 解题过程 遍历时使用广度优先遍历，首先遍历到根节点，此时根节点入队，队列中只有根节点，表示根节点单独一层；当队不空时，依次（计算队列元素）对队头元素出队并操作（加入结果数组），操作完后将其左右孩子节点入队。此时，遍历完此层所有节点时，也将其下层节点按顺序入队了，下一轮循环在计算下一层的队列元素个数再进行遍历操作，直到队空，表示所有节点处理完毕。具体看注释。 复杂度 时间复杂度: O(n) 空间复杂度: O(n) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { // 定义一个返回数组 vector&lt;vector&lt;int&gt;&gt; ret; // 如果根结点不存在 直接返回空ret if(!root) return ret; // 定义一个队列 queue&lt;TreeNode*&gt; q; // 先将根节点入队 q.push(root); // 当队列不空时，进行循环 while(!q.empty()){ // 定义一个表示当前层节点数的值：就是队列当前的元素值 int currentLevelSize = q.size(); // 将空的内层加入返回数组 ret.push_back(vector&lt;int&gt; ()); // 从左到右遍历当前层的所有节点：即从左到右依次处理队列中的元素 for(int i=1;i&lt;=currentLevelSize;++i){ // 取队头元素值并将队头元素出队 auto node = q.front(); q.pop(); // 对返回数组的最后一个元素中加入当前节点的值 ret.back().push_back(node-&gt;val); // 判断是否有左右孩子，有的话将其入队 if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return ret; }};","link":"/2024/12/25/2024-12-25-Leetcode-Hot100-No.102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"},{"title":"Leetcode Hot100 189.轮转数组 临时数组&#x2F;vector的拷贝构造函数","text":"189.轮转数组 临时数组/vector的拷贝构造函数 C++、数组、数学 Problem: 189.轮转数组 思路 以空间换时间，临时数组，计算轮转公式 解题过程 具体看代码注释 复杂度 时间复杂度: O(N ) 空间复杂度: O(N) Code 123456789101112131415161718192021222324252627class Solution {public: void rotate(vector&lt;int&gt;&amp; nums, int k) { // 合理值验证 if(nums.size() &lt; 1 || nums.size() &gt; 10e5 || k &lt; 0 || k &gt; 10e5) return; /* 思想：以空间换时间，声明一个新的数组（临时变量）用于存储轮转k次后的结果，最后将其复制到原数组中， 计算轮转公式：结果 = i+k % nums.size */ // 声明一个新的临时数组 int numsSize = nums.size(); vector&lt;int&gt; tempNums(numsSize); // 循环遍历nums,对于每个元素，计算轮转后的位置并将其放入临时数组的正确位置 int curLoc = 0; int endLoc = 0; for(int i: nums){ endLoc = (curLoc + k) % numsSize; // 得到结果位置 // 将其加入结果位置 // tempNums.insert(tempNums.begin() + endLoc, i); tempNums[endLoc] = i; curLoc++; } // 循环完毕，临时数组中得到结果，全部复制给原数组 nums = tempNums;// vector的拷贝构造函数 }};","link":"/2025/03/15/2025-3-15-Leetcode-Hot100-No.189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/"},{"title":"Leetcode Hot100  560. 和为 K 的子数组 前缀和 哈希表","text":"560. 和为 K 的子数组 前缀和 哈希表 C++、哈希表、前缀和 Problem: 560. 和为 K 的子数组 思路 1.暴力枚举 2.前缀和+哈希表 解题过程 1.逐个遍历数组，将每个元素作为子数组的结尾，再根据当前子数组的结尾，向前遍历累加，找到符合和为k的子数组，个数加1； 2.前缀和+哈希表。没听太懂，可以再次听一遍。 复杂度 时间复杂度: O(n^2) （暴力） O(n) （前缀） 空间复杂度: O(1)（暴力） O(n) （前缀） Code 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) { /* 方法1：暴力枚举 方法2：前缀和+哈希表，以空间换时间 */ // 方法1： int count = 0;// 记录答案 // 遍历数组，考虑每个位置end作为子数组结尾的情况 for(int end=0; end &lt; nums.size(); ++end){ int sum = 0;// 当前子数组的和 for(int start=end; start &gt;= 0; --start){ // 从后往前遍历当前子数组 sum += nums[start]; if(sum == k){ count++; } } } // 方法2： unordered_map&lt;int,int&gt; mp; mp[0] = 1; int count = 0, pre = 0; for(auto&amp; x:nums){ pre += x;// 累加前缀和 if(mp.find(pre - k) != mp.end()){ // 如果在哈希表中找到符合条件的pre - k count += mp[pre -k]; } mp[pre]++; } return count; }};","link":"/2025/02/08/2025-2-8-Leetcode-Hot100-No.560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"Leetcode Hot100 19. 删除链表的倒数第 N 个结点 栈 双指针","text":"19. 删除链表的倒数第 N 个结点 栈 双指针 C++、链表、双指针 Problem: 19. 删除链表的倒数第 N 个结点 思路 方法一：计算单链表的节点数量，倒数换为正数。 方法二：栈。后进先出，将链表遍历一遍，依次入栈，全部入栈后再出栈n个结点,第n个就是目标结点。 方法三：双指针。用first和second指针同时对链表遍历。 解题过程 具体看代码注释 复杂度 时间复杂度: O(N) 空间复杂度: 计数O(1) 栈O(N) 双指针O(1) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: int ListNodeSize(ListNode* head){ if(head == nullptr) return 0; int cnt = 0; while(head != nullptr){ cnt++; head = head-&gt;next; } return cnt; } ListNode* removeNthFromEnd(ListNode* head, int n) { // 方法一：计数。倒数第n个结点 = 正数第length - n + 1个结点 // 异常处理 if(head == nullptr) return nullptr; // 单链表只能一个一个遍历，倒数换为正数，然后删除这个结点 int len = ListNodeSize(head); if(n &gt;len) return head;// 如果n大于链表长度 // 如果目标结点是头结点 if(len == n){ ListNode* newHead = head-&gt;next; delete head; return newHead; } // 找到倒数第n个节点的前一个节点 ListNode *p = head; for(int i = 0; i &lt; len - n - 1; ++i){ p = p-&gt;next; } // 删除目标结点 ListNode* toDelete = p-&gt;next; p-&gt;next = toDelete-&gt;next; delete toDelete; return head; }};class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 方法二：栈。后进先出，将链表遍历一遍，依次入栈，全部入栈后再出栈n个结点,第n个就是目标结点。 ListNode* dummy = new ListNode(0, head);// 初始化一个值为0，下一个结点指向head的头结点dummy // 初始化一个栈 stack&lt;ListNode*&gt; stk; // 初始化一个工作指针cur ListNode* cur = dummy; // 遍历链表，将每个节点入栈 while(cur){ stk.push(cur); cur = cur-&gt;next; } // 再出栈n个结点 for(int i = 0; i &lt; n; ++i){ stk.pop(); } // 出栈n个后，当前栈顶元素就是原链表的目标结点的前驱结点 ListNode* prev = stk.top(); // 删除结点并重新连接链表 prev-&gt;next = prev-&gt;next-&gt;next; ListNode* ans = dummy-&gt;next; delete dummy; return ans; }};class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 方法三：双指针。用first和second指针同时对链表遍历 // 且first比second超前n+1个结点，当first指向链表末尾时，second正好指向倒数第n个结点的前驱结点。 ListNode* dummy = new ListNode(0, head);// 初始化一个哑节点，指向head // 初始化两个指针 ListNode* first = head; ListNode* second = dummy; // 先让first遍历n个结点 for(int i = 0; i &lt; n; ++i){ first = first-&gt;next; } // 再两个指针一起遍历 while(first != nullptr){ first = first-&gt;next; second = second-&gt;next; } // 此时second指向目标结点的前驱结点 // 删除结点并重新连接链表 second-&gt;next = second-&gt;next-&gt;next; ListNode* ans = dummy-&gt;next; delete dummy; return ans; }};","link":"/2025/03/18/2025-3-18-Leetcode-Hot100-No.19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"title":"Leetcode Hot100 238.除自身以外数组的乘积 前缀数组和后缀数组 正向和逆向","text":"238.除自身以外数组的乘积 前缀数组和后缀数组 正向和逆向 C++、数组、前缀和 Problem: 238.除自身以外数组的乘积 思路 方法一：左右乘积列表 ​ 结果 = 当前数组前缀元素乘积 * 当前数组后缀元素乘积 ​ 前缀之积L = {1,11,112,1123} = {1,1,2,6} 从前往后算 ​ 后缀之积R = {1432,143,14,1} = {24,12,4,1} 从后往前算 ​ 结果 = L[i] * R[i] = {24,12,8,6} 方法二：左右乘积列表的进阶————空间复杂度降为O1(返回的数组不算，不是额外辅助空间) ​ 只用两轮循环计算，1个临时变量存储。 ​ 在第一轮循环直接用answer数组存储前缀之积L， ​ 第二轮循环逐个计算后缀之积后将其乘进对应的answer数组， ​ 直接得到最终答案。 ​ 由于只用了1个临时变量用于存储计算结果，结果都是放在answer数组中的，所以空间复杂度O1 解题过程 具体看代码注释 复杂度 时间复杂度: O(N) 空间复杂度: O(N) 最低降为O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) { /* 给定整数数组nums，返回数组answer, 其中answer[i] = nums中 除去nums[i]之外 其余各元素的 乘积 条件1：nums中任意元素的全部前缀元素和后缀的成绩都在32位证书范围内 条件2：不要使用除法，时间复杂度O(n) 例子：nums={1,2,3,4} answer={24,12,8,6} {24,12,8,6} = {2*3*4, 1*3*4, 1*2*4, 1*2*3} 方法一：左右乘积列表 结果 = 当前数组前缀元素乘积 * 当前数组后缀元素乘积 前缀之积L = {1,1*1,1*1*2,1*1*2*3} = {1,1,2,6} 从前往后算 后缀之积R = {1*4*3*2,1*4*3,1*4,1} = {24,12,4,1} 从后往前算 结果 = L[i] * R[i] = {24,12,8,6} 方法二：左右乘积列表的进阶————空间复杂度降为O1(返回的数组不算，不是额外辅助空间) 只用两轮循环计算，1个临时变量存储。 在第一轮循环直接用answer数组存储前缀之积L， 第二轮循环逐个计算后缀之积后将其乘进对应的answer数组， 直接得到最终答案。 由于只用了1个临时变量用于存储计算结果，结果都是放在answer数组中的，所以空间复杂度O1 */ int length = nums.size(); // L 和 R 分别表示左右两侧的乘积列表 vector&lt;int&gt; L(length, 0), R(length, 0); vector&lt;int&gt; answer(length); // L[i]为索引i左侧所有元素的乘积 // 第一个元素左侧的L为1 L[0] = 1; for(int i = 1; i &lt; length; i++){ L[i] = nums[i-1] * L[i-1]; } // R[i]为索引i右侧所有元素的乘积 // 最后个元素右侧的R为1 R[length - 1] = 1; for(int i = length - 2; i &gt;= 0; i--){ R[i] = nums[i+1] * R[i+1]; } // 所得的答案数组就是L[i] * R[i] for(int i = 0; i &lt;length; i++){ answer[i] = L[i] * R[i]; } return answer; }};","link":"/2025/03/16/2025-3-16-Leetcode-Hot100-No.238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/"},{"title":"Leetcode Hot100 24. 两两交换链表中的节点 递归&#x2F;迭代","text":"24. 两两交换链表中的节点 递归/迭代 C++、链表、递归 Problem: 24. 两两交换链表中的节点 递归/迭代 思路 方法一：递归。递归地两两交换链表中的节点，终止条件是链表中没有节点或只有一个结点。 方法二：迭代。双指针，一个prev指向两个结点的前驱结点，防止断链；一个cur指向第一个交换节点，进行交换工作，交换之后再一起向后遍历两个节点，如果cur为nullptr则说明交换完毕。 解题过程 具体看代码注释 复杂度 时间复杂度: O(N) 空间复杂度: 递归使用栈 O(n) 迭代 O(1) Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public: ListNode* swapPairs(ListNode* head){ // 方法一：递归。递归地两两交换链表中的节点，终止条件是链表中没有节点或只有一个结点。 if(head == nullptr || head-&gt;next == nullptr){ return head; } ListNode* newHead = head-&gt;next; head-&gt;next = swapPairs(newHead-&gt;next); newHead-&gt;next = head; return newHead; } ListNode* swapPairs(ListNode* head) { // 方法二：迭代。双指针，一个prev指向两个结点的前驱结点，防止断链； // 一个cur指向第一个交换节点，进行交换工作，交换之后再一起向后遍历两个节点， // 如果cur为nullptr则说明交换完毕 if(head == nullptr) return nullptr; ListNode* dummy = new ListNode(0, head); ListNode* prev = dummy; ListNode* cur = head-&gt;next; // 处理只有一个结点的情况 if(head &amp;&amp; head-&gt;next == nullptr) return head; // 处理第一对结点 // 交换cur和cur的next指向的节点 if(cur == nullptr) return head; prev-&gt;next-&gt;next = cur-&gt;next; cur-&gt;next = prev-&gt;next; prev-&gt;next = cur; dummy-&gt;next = prev-&gt;next; // 交换后重置指针位置 cur = cur-&gt;next; prev = cur; // cur向后遍历两个结点 if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next){ cur = cur-&gt;next-&gt;next; }else{ cur = nullptr; } while(cur){ // 交换cur和cur的next指向的节点 prev-&gt;next-&gt;next = cur-&gt;next; cur-&gt;next = prev-&gt;next; prev-&gt;next = cur; // 交换后重置指针位置 cur = cur-&gt;next; prev = cur; // cur向后遍历两个结点 if(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next){ cur = cur-&gt;next-&gt;next; }else{ cur = nullptr; } } ListNode* ans = dummy-&gt;next; delete dummy; return ans; }};","link":"/2025/03/19/2025-3-19-Leetcode-Hot100-No.24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"},{"title":"Leetcode Hot100 45. 跳跃游戏 II 贪心算法","text":"45. 跳跃游戏 II 贪心算法 C++、贪心 Problem: 45. 跳跃游戏 II 贪心算法 思路 贪心算法。 解题过程 方法一：/* ​ 贪心算法：正向的查找可到达的最大位置。维护一个能够到达的最大下标位置，记为边界； ​ 这个边界 = max(当前结点能跳跃的几个位置中的跳跃次数，即当前节点能跳跃的几个位置中谁跳的最远) ​ 从左往右遍历数组，到达边界时，更新边界并将跳跃次数加一。 ​ 遍历数组时不访问最后一个元素，因为在访问最后一个元素之前的边界一定是大于等于最后一个位置的。 ​ 如果访问最后一个元素，边界正好也是最后一个位置的情况下，会增加一次不必要的跳跃次数。 ​ */ 方法二：贪心算法。从后往前找最大跳跃位置。 ​ // 首先，维护一个变量pos，表示当前位置，初始化是最后一个位置， ​ // 然后我们要对当前位置之前的元素从小到大进行遍历，判断能否跳越到当前位置； ​ // 如果可以，则跳跃次数加一，然后将当前位置更新为此时跳跃的位置 ​ // （因为是从小到大，所以这里最小，也表示跳的最远） 复杂度 时间复杂度: 正向O(n) 反向O(n^2) 空间复杂度: O(1) Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution {public: int jump(vector&lt;int&gt;&amp; nums){ /* 贪心算法：正向的查找可到达的最大位置。维护一个能够到达的最大下标位置，记为边界； 这个边界 = max(当前结点能跳跃的几个位置中的跳跃次数，即当前节点能跳跃的几个位置中谁跳的最远) 从左往右遍历数组，到达边界时，更新边界并将跳跃次数加一。 遍历数组时不访问最后一个元素，因为在访问最后一个元素之前的边界一定是大于等于最后一个位置的。 如果访问最后一个元素，边界正好也是最后一个位置的情况下，会增加一次不必要的跳跃次数。 */ int len = nums.size(); int maxPos = 0; int end = 0, steps = 0; for(int i = 0; i &lt; len-1; ++i){ if(maxPos &gt;= i){ maxPos = max(maxPos, i + nums[i]); } if(i == end){ end = maxPos; ++steps; } } return steps; } int jump(vector&lt;int&gt;&amp; nums) { /* 贪心算法。从后往前找最大跳跃位置。 首先，维护一个变量pos，表示当前位置，初始化是最后一个位置， 然后我们要对当前位置之前的元素从小到大进行遍历，判断能否跳越到当前位置； 如果可以，则跳跃次数加一，然后将当前位置更新为此时跳跃的位置 （因为是从小到大，所以这里最小，也表示跳的最远） */ // 当前位置为最后一个位置 int pos = nums.size() - 1; // 记录跳跃次数 int steps = 0; while(pos &gt; 0){ for(int i = 0; i &lt; pos; i++){ // 从头遍历到当前位置 if(i + nums[i] &gt;= pos){ // 如果符合条件，说明在i这里可以跳到当前位置 pos = i;// 更新当前位置到i steps++;// 跳跃次数+1 break;// 找到了最小跳跃位置，直接退出这轮循环 } } } return steps; }};","link":"/2025/03/20/2025-3-20-Leetcode-Hot100-No.45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"},{"title":"Leetcode Hot100 55. 跳跃游戏 贪心算法","text":"55. 跳跃游戏 贪心算法 C++、贪心 Problem: 55. 跳跃游戏 贪心算法 思路 贪心算法。 解题过程 首先，维护一个变量maxReach，表示能到达的最大位置， ​ 然后我们遍历每个元素，判断当前位置是否大于最大位置， ​ 如果大于，则表示当前已经遍历到能够到达的最大位置之后了，最大位置没能覆盖到这里，更别说最后一个位置了； ​ 如果不大于，就更新能到达的最大位置，最大位置 = max(当前位置i + 能跳的位置, maxReach); ​ 遍历结束后，maxReach应该是大于len-1的，说明能到最后一个位置。 复杂度 时间复杂度: O(N) 空间复杂度: O(1) Code 1234567891011121314151617181920212223class Solution {public: bool canJump(vector&lt;int&gt;&amp; nums) { /* 贪心算法。首先，维护一个变量maxReach，表示能到达的最大位置， 然后我们遍历每个元素，判断当前位置是否大于最大位置， 如果大于，则表示当前已经遍历到能够到达的最大位置之后了，最大位置没能覆盖到这里，更别说最后一个位置了； 如果不大于，就更新能到达的最大位置，最大位置 = max(当前位置i + 能跳的位置, maxReach); 遍历结束后，maxReach应该是大于len-1的，说明能到最后一个位置。 */ int len = nums.size(); int maxReach = 0;// 表示能到达的最远位置 for(int i = 0; i &lt; len; ++i){ if(i &gt; maxReach){ // 当前位置在比maxReach还靠后的位置，此时跳不到最远位置了 return false; } maxReach = max(i + nums[i], maxReach);// 当前在i位置，还可以跳nums[i]步 } return true; }};","link":"/2025/03/20/2025-3-20-Leetcode-Hot100-No.55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"title":"Leetcode Hot100 763. 划分字母区间 贪心 字符串","text":"763. 划分字母区间 贪心 字符串 C++、贪心、字符串 Problem: 763. 划分字母区间 贪心 字符串 思路 贪心算法。 解题过程 1.同一个字母只能出现在同一个片段 = 同一个字母的第一次出现的下标位置 ​ 和最后一次出现的下标位置必须出现在同一片段：遍历字符串，得到每个字母最后一次出现的下标位置 ​ 2.得到每个字母最后一次出现的下标位置后，只用贪心方法将字符串划分为尽可能多的片段： ​ · 从左到右遍历字符串，维护当前片段的开始下标start和结束下标end，start==end==0 ​ · end = max(end,endc) c为当前访问的字母 ​ · 当访问到下标end时，当前片段访问结束，下标范围是[start, end]， ​ 长度为end - start + 1，将长度添加到返回值，令start = end + 1，继续下一个片段。 ​ · 重复上述过程，直到遍历完字符串。 复杂度 时间复杂度: O(n) 空间复杂度: O( |σ| ),|σ|为字符串中不重复的字符个数 Code 123456789101112131415161718192021222324252627282930313233class Solution {public: vector&lt;int&gt; partitionLabels(string s) { /* 贪心算法。 1.同一个字母只能出现在同一个片段 = 同一个字母的第一次出现的下标位置 和最后一次出现的下标位置必须出现在同一片段：遍历字符串，得到每个字母最后一次出现的下标位置 2.得到每个字母最后一次出现的下标位置后，只用贪心方法将字符串划分为尽可能多的片段： · 从左到右遍历字符串，维护当前片段的开始下标start和结束下标end，start==end==0 · end = max(end,endc) c为当前访问的字母 · 当访问到下标end时，当前片段访问结束，下标范围是[start, end]， 长度为end - start + 1，将长度添加到返回值，令start = end + 1，继续下一个片段。 · 重复上述过程，直到遍历完字符串。 */ // 定义一个数组存储每个字母最后一次出现的下标位置 int last[26]; int len = s.size(); for(int i = 0; i &lt; len; i++){ last[s[i] - 'a'] = i; } // 得到每个字母最后一次出现的下标位置后，用贪心将字符串划分为尽可能多的片段。 vector&lt;int&gt; partition; int start = 0, end = 0; for(int i = 0; i &lt; len; i++){ end = max(end, last[s[i] - 'a']); if(i == end){ partition.push_back(end - start + 1); start = end + 1; } } return partition; }};","link":"/2025/03/21/2025-3-21-Leetcode-Hot100-No.763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/"},{"title":"GCC编译","text":"GCC编译 1.介绍GCC全称是GNU编辑器套件，是一个多语言编译器，主要的特点就是跨平台，支持多种编程语言和处理器架构。 在linux环境下，主要还是直接使用编译工具，在编译的时候要添加一些编译选项。 2.编译过程一个C/C++文件要经过**预处理(preprocessing)、编译(compilation)、汇编(assembly)和链接(linking)**等4步才能变成可执行文件。 通过不同的GCC选项可以控制这些过程： 在日常交流中通常使用“编译”统称这 4 个步骤。 2.1 预处理C/C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令“#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一步处理。 使用cc1命令将hello.c文件预处理生成hello.i文件： 2.2 编译编译就是把C/C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用到的工具为cc1(它的名字就是cc1，x86有自己的cc1命令，ARM板也有自己的cc1命令)。 使用cc1命令将hello.i文件编译生成hello.s文件： 2.3 汇编汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux系统上一般表现为ELF目标文件(OBJ文件)，用到的工具为as。x86有自己的as命令，ARM版也有自己的as命令，也可能是xxxx-as（比如armlinux-as）。“反汇编”是指将机器代码转换为汇编代码，这在调试程序时常常用到。使用as命令将hello.s文件汇编生成hello.o文件： 2.4 链接链接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件，用到的工具为ld或collect2。 使用collect2命令将hello.o文件链接生成hello可执行文件，并运行hello程序： 使用gcc -o hello hello.c一条命令可以完成预处理、编译、汇编和链接4个步骤，直接生成可执行文件程序： 3. 编译多个文件假设当前目录下有3个文件：main.c、sub.c、sub.h： 编译这3个文件有2种方法： 1、一起编译： 1gcc -o test main.c sub.c 2、分开编译再链接到一起： 1234gcc -c -o main.o main.cgcc -c -o sub.o sub.cgcc -o test main.o sub.o 4. 制作和使用动态库在C语言中，动态库（Dynamic Library）是一种可执行文件或库的一部分，它在程序运行时被加载和链接。动态库提供了一个灵活的方式来组织和管理代码，使多个程序可以共享相同的代码段，从而节省内存和磁盘空间。 还是以main.c、sub.c、sub.h三个文件为例，制作和使用动态库。 1234gcc -c -o main.o main.cgcc -c -o sub.o sub.cgcc -shared -o libsub.so sub.o sub2.o sub3.o(可以使用多个.o 生成动态库)gcc -o test main.o -lsub -L /libsub.so/所在目录/ 2、使用动态库 使用动态库有2种方法： 1）把libsub.so放到Ubuntu的/lib目录中，然后就能执行test3程序了 1sudo cp libsub.so /lib 2）如果不想把libsub.so放到/lib，也可以放在自己指定的目录下，配置环境变量： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a 5. 制作、使用静态库静态库（Static Library）是一种包含多个编译好的目标文件（.o 文件）的集合，这些目标文件在链接阶段被合并到最终的可执行文件中。 在Linux系统中，静态库通常以.a（archive）文件的形式存在。在Windows系统中，静态库则以.lib文件的形式存在。静态库安全、独立，不依赖外部库文件，可移植性强。 静态库（Static Library）和动态库（Dynamic Library）都是用于组织和管理代码的库文件，但它们在使用方式、链接时机、更新方式等方面存在明显的区别。 静态库 动态库 链接时机 在编译阶段，静态库中的目标文件会被直接嵌入到最终生成的可执行文件中。 在编译阶段，动态库中的函数只是被标记为需要在运行时加载。在程序运行时，动态库才会被加载到内存中，并与程序进行链接。 文件大小 可执行文件通常较大。 生成的可执行文件相对较小。 内存占用 在程序运行时全部存在于内存中，因此内存占用较大。 内存占用相对较小。动态库的代码在内存中只需加载一次，所有使用该库的程序都可以共享这段内存。 更新 更新静态库需要重新编译和链接整个程序才能生效。 只要不改变动态库的接口（ABI），更新后的动态库可以直接被现有的程序使用。 依赖关系 不需要额外的依赖文件。 需要确保动态库文件存在于系统中，并且系统知道如何找到这些文件（通过环境变量或库路径配置）。 安全性 不容易被其他程序篡改或替换。 动态库是一个独立的文件，如果被恶意替换，可能会影响程序的正常运行。 跨平台性 通常与特定的编译器和平台绑定，跨平台时需要重新编译。 跨平台时只需要确保新平台上有对应的动态库版本即可。 还是以main.c、sub.c、sub.h三个文件为例，制作和使用静态库。 1234gcc -c -o main.o main.cgcc -c -o sub.o sub.car crs libsub.a sub.o sub2.o sub3.o(可以使用多个.o 生成静态库)gcc -o test main.o libsub.a (如果.a 不在当前目录下，需要指定它的绝对或相对路径) 移动静态库位置后，链接时需要指定静态库的路径。 6. 常用编译选项6.1 很好用的编译选项 gcc -E main.c // 查看预处理结果，比如头文件是哪个 gcc -E -dM main.c &gt; 1.txt // 把所有的宏展开，存在 1.txt 里 gcc -Wp,-MD,abc.dep -c -o main.o main.c // 生成依赖文件 abc.dep，一般Makefile会用到 echo 'main(){}'| gcc -E -v - // 它会列出头文件目录、库目录(LIBRARY_PATH) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#### 6.2 GCC总体选项(OverallOption)1、**-c****预处理、编译和汇编源文件，但是不作链接，编译器根据源文件生成OBJ文件**。缺省（默认）情况下，GCC通过用`.o`替换源文件名的后缀`.c`，`.i`，`.s`等，产生OBJ文件名。可以使用-o选项选择其他名字。GCC忽略-c选项后面任何无法识别的输入文件。2、**-S****编译后即停止，不进行汇编**。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。缺省情况下，GCC通过用`.s`替换源文件名后缀`.c`，`.i`等等，产生汇编文件名。可以使用-o选项选择其他名字。GCC忽略任何不需要汇编的输入文件。3、**-E****预处理后即停止，不进行编译**。预处理后的代码送往标准输出。4、**-o file****指定输出文件为file**。无论是预处理、编译、汇编还是链接，这个选项都可以使用。如果没有使用`-o`选项，默认的输出结果是：可执行文件为`a.out`；修改输入文件的名称是`source.suffix`，则它的OBJ文件是`source.o`，汇编文件是`source.s`，而预处理后的C源代码送往标准输出。5、**-v****显示**制作GCC工具自身时的**配置命令**；同时**显示编译器驱动程序、预处理器、编译器的版本号**。#### 6.3 警告选项(Warning Option)-Wall这个选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明之前就使用的函数、局部变量除了声明就没再使用等。#### 6.4 调试选项(Debugging Option)-g以操作系统的本地格式(stabs，COFF，XCOFF，或DWARF)产生调试信息，**GDB能够使用这些调试信息**。在大多数使用stabs格式的系统上，`-g`选项加入**只有GDB才使用的额外调试信息**。可以使用下面的选项来生成额外的信息：`-gstabs+`，`-gstabs`，`-gxcoff+`，`-gxcoff`，`-gdwarf+`或`-gdwarf`，具体用法请读者参考GCC手册。#### 6.5 优化选项(Optimization Option)**1、-O或者-O1****优化：对于大函数，优化编译的过程将占用稍微多的时间和相当大的内存**。不使用`-O'或`-O1’选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的：如果在两条语句之间用断点中止程序，可以对任何变量重新赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确地获取你所期待的结果。**不使用`-O'或`-O1’选项时，只有声明了register的变量才分配使用寄存器****使用了`-O'或`-O1’选项，编译器会试图减少目标码的大小和执行时间**。如果指定了`-O`或`-O1`选项,，`-fthread-jumps`和`-fdefer-pop`选项将被打开。在有delayslot的机器上，`-fdelayed-branch`选项将被打开。在即使没有帧指针(frame pointer)也支持调试的机器上，`-fomit-framepointer`选项将被打开。某些机器上还可能会打开其他选项。**2、-O2****多优化一些**。**除了涉及空间和速度交换的优化选项**，**执行几乎所有的优化工作**。例如不进行循环展开(loop unrolling)和函数内嵌(inlining)。和`-O`或`-O1`选项比较，这个选项既增加了编译时间，也提高了生成代码的运行效果。**3、-O3**优化的更多。除了打开`-O2`所做的一切，它还打开了`-finline-functions`选项。**4、-O0**不优化。如果指定了多个`-O`选项，不管带不带数字，生效的是最后一个选项。 在一般应用中，经常使用-O2选项。 1234567891011121314151617181920212223242526272829303132333435363738394041#### 6.6 链接器选项(Linker Option)**1、object-file-name**如果某些文件**没有特别明确的后缀**(a special recognized suffix)，GCC**就认为他们是OBJ文件或库文件**(根据文件内容,链接器能够区分OBJ文件和库文件)。如果GCC执行链接操作，这些OBJ文件将成为链接器的输入文件。比如上面的`gcc -o test main.o sub.o`中，`main.o`、`sub.o`就是输入的文件。**2、-llibrary**链接名为library的库文件。链接器在标准搜索目录中寻找这个库文件，库文件的真正名字是`liblibrary.a`。搜索目录除了一些系统标准目录外，还包括**用户以`-L`选项指定的路径**。一般说来用这个方法找到的文件是库文件──即由OBJ文件组成的归档文件(archive file)。链接器处理归档文件的方法是：扫描归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果链接器找到普通的OBJ文件，而不是库文件，就把这个OBJ文件按平常方式链接进来。**指定`-l`选项和指定文件名的唯一区别**是，`-l`选项用`lib`和`.a`把library包裹起来，而且搜索一些目录。即使不明显地使用-llibrary选项，一些默认的库也被链接进去，可以使用-v选项看到这点：**3、-nostartfiles**不链接系统标准启动文件，而标准库文件仍然正常使用：启动文件crt1.o、crti.o、crtend.o、crtn.o没有被链接进去。需要说明的是，对于一般应用程序，这些启动文件是必需的，这里仅是作为例子(这样编译出来的test文件无法执行)。**在编译bootloader、内核时，将用到这个选项**。**4、-nostdlib**不链接系统标准启动文件和标准库文件，只把指定的文件传递给链接器。这个选项**常用于编译内核、bootloader等程序，它们不需要启动文件、标准库文件，它们用到的很多函数是自包含的。****5、-static**在支持动态链接(dynamicl inking)的系统上，阻止链接共享库。仍以options程序为例，是否使用-static选项编译出来的可执行程序大小相差巨大：其中test6文件为8360字节，test7_static文件为845304字节。当不使用-static编译文件时，程序执行前要链接共享库文件，所以还需要将共享库文件放入文件系统中。**6、-shared**生成一个共享OBJ文件，它可以和其他OBJ文件链接产生可执行文件。只有部分系统支持该选项。当**不想以源代码发布程序时**，可以使用-shared选项生成库文件，比如对于options程序，可以如下制作库文件： gcc -c -o sub.o sub.c gcc -shared -o libsub.so sub.o 123以后要使用sub.c中的函数sub_fun时，在链接程序时，指定引脚libsub.so即可，比如： gcc -o test main.o -lsub -L /libsub.so/所在的目录/ 123可以将多个文件制作为一个库文件，比如： gcc -shared -o libsub.so sub.o sub2.o sub3.o 123456789101112131415161718192021222324252627282930313233343536373839404142434445**7、-Xlinker option**把选项option传递给链接器。可以用来传递系统特定的链接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次`-Xlinker`，一次传递选项，另一次传递其参数。例如，如果传递`-assert definitions`，要成`-Xlinker -assert -Xlinker definitions`，而不能写成`-Xlinker &quot;-assert definitions&quot;`，因为这样会把整个字符串当做一个参数传递，显然这不是链接器期待的。**8、-Wl,option**把选项option传递给链接器。如果option中含有逗号，就在逗号处分割成多个选项。链接器通常是通过gcc、arm-linux-gcc等命令间接启动的，要向它传入参数时，参数前面加上`-Wl,`。**9、-u symbol**使链接器认为取消了symbol的符号定义，从而链接库模块以取得定义。可以使用多个`-u`选项，各自跟上不同的符号，使得链接器调入附加的库模块。#### 6.7 目录选项(Directory Option)**1、-Idir****在头文件的搜索路径列表中添加dir目录。**头文件的搜索方法为：如果以“#include &lt; &gt;”包含文件，则只在标准库目录开始搜索(包括使用-Idir选项定义的目录)；如果以“#include “ ””包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。**2、-I-**任何在`-I-`前面用`-I`选项指定的搜索路径只适用于`#include&quot;file&quot;`这种情况；它们不能用来搜索`#include&lt;file&gt;`包含的头文件。如果用`-I`选项指定的搜索路径位于`-I-`选项后面，就可以在这些路径中搜索所有的`#include`指令(一般说来-I选项就是这么用的)。还有，`-I-`选项能够阻止当前目录(存放当前输入文件的地方)成为搜索`#include&quot;file&quot;`的第一选择。`-I-`不影响使用系统标准目录，因此，`-I-`和`-nostdinc`是不同的选项。**3、-Ldir**在`-l`选项的搜索路径列表中添加dir目录。仍使用options程序进行说明，先制作库文件 libsub. a：![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f1392a8ddd9049d0811d0fdd32a1d026.png#pic_center)**4、-Bprefix**这个选项指出**在何处寻找可执行文件，库文件，以及编译器自己的数据文件**。编译器驱动程序需要使用某些工具，比如：`cpp`，`cc1`(或C++的`cc1plus`)，`as`和`ld`。它把prefix当作欲执行的工具的前缀，这个前缀可以用来指定目录，也可以用来修改工具名字。对于要运行的工具，**编译器驱动程序**首先试着加上`-B`前缀(如果存在)，如果没有找到文件，或没有指定`-B`选项，编译器接着会试验两个标准前缀`/usr/lib/gcc/`和`/usr/local/lib/gcc-lib/`。如果仍然没能够找到所需文件，编译器就在`PATH`环境变量指定的路径中寻找没加任何前缀的文件名。如果有需要，运行时(run-time)支持文件`libgcc.a`也在`-B`前缀的搜索范围之内。如果这里没有找到，就在上面提到的两个标准前缀中寻找，仅此而已。如果上述方法没有找到这个文件，就不链接它了。多数情况的多数机器上，`libgcc.a`并非必不可少。可以通过环境变量GCC_EXEC_PREFIX获得近似的效果；如果定义了这个变量，其值就和上面说的一样被用作前缀。如果同时指定了`-B`选项和GCC_EXEC_PREFIX变量，编译器首先使用`-B`选项，然后才尝试环境变量值。---### make和makefile**make是一个命令，makefile是一个文件。** 1.make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。 2.makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879我们先创建一个文件mycode.c,在里面写好程序![image-20221119154527481](https://img-blog.csdnimg.cn/img_convert/7d067c41e6d281aa7f98198c51bfb630.png)再创建一个文件，文件名为Makefile（makefile也可）；然后在里面写![image-20221119154657036](https://img-blog.csdnimg.cn/img_convert/a5467f8891f1ad5276fdcd68f42886ec.png)**Makefile文件的第一行要写依赖关系**【儿子：爸爸 —即儿子依赖爸爸—即前者依赖后者】**第二行要以table键开头！****第二行写依赖方法**【儿子为什么要依赖爸爸呢？—以这个代码为例编译mycode.c形成mycode—mycode的产生得由mycode.c来决定！】然后我们出去make一下，发现执行了依赖方法的代码，然后我们去运行可执行程序发现可以运行![image-20221119155601211](https://img-blog.csdnimg.cn/img_convert/04e16bc62ee3b7a4b0ca8e9e7b7de75e.png)然后我们再加点东西进去![image-20221119155759553](https://img-blog.csdnimg.cn/img_convert/f505e57f08ab5c76756c77a228cdcb5f.png)首先我们来看这个**clean**这里也是一个依赖关系，但clean冒号后面没有接东西说明clean不依赖任何文件或程序。然后**它的依赖方法是删除mycode**我们出去执行，发现它确实能执行![image-20221119160134125](https://img-blog.csdnimg.cn/img_convert/32726d88ea25b3859d4240beb7f9d790.png)但这次clean前面有个.**PHONY:clean** 这里又与上面mycode的依赖关系和方法有什么区别呢？我们连续make，发现后面的都提示mycode已经是最新的了，不需要再编译了![image-20221119160355686](https://img-blog.csdnimg.cn/img_convert/1847338b9d6e36b37d795e2c15f027b5.png)但是我们连续make clean，就算mycode已经被删除了，还是能执行make clean，那是为什么呢？![image-20221119160617497](https://img-blog.csdnimg.cn/img_convert/9f14660866dd5fce60126eab4a7c1ed1.png)别急，我们先来看这个—mycode.c的时间![image-20221119161133373](https://img-blog.csdnimg.cn/img_convert/f8bdbf1128ab070b5604602d1002206b.png)###### stat 查看文件或目录时间| Access | 文件访问的时间—新版的系统对更新频率做了修正，访问过一段时间或者访问了多次才会改变 || ---------- | ------------------------------------------------------------ || **Modify** | **内容修改时间—内容改变时间随之改变** || **Change** | **文件属性修改时间—文件属性改变时间随之改变（内容修改了文件属性也会变-比如文件大小等等）** |然后我们改变一下mycode.c的内容![image-20221119162439503](https://img-blog.csdnimg.cn/img_convert/e0fbbb897634400c2341f19176a80f2e.png)我们发现时间变了。**是否能make 是根据依赖关系两边的文件时间改变而决定的。**我们知道**编译文件产生目标文件，所以编译文件修改时间在目标文件修改时间之前**。比如编译mycode.c产生mycode，那么mycode.c的修改时间肯定在mycode的修改时间之前，如果是这样那么**Makefile文件识别到这样就不需要在make了**。举例：![img](https://i-blog.csdnimg.cn/direct/ad69edd1bd194a17916ea49eacb7d70a.png)**依赖关系**- 上面的文件hello，它依赖hello.o- hello.o，它依赖hello.s- hello.s，它依赖hello.i- hello.i，它依赖hello.c**依赖方法**- **gcc hello.\\* -option hello.\\*，就是与之对应的依赖关系**### 原理 make是如何工作的,在默认的方式下，也就是我们只输入make命令。那么， make会在当前目录下找名字叫“Makefile”或“makefile”的文件。2.对于不生成实际文件的目标（如 all、clean），使用 .PHONY 明确声明。all 是伪目标，不生成实际文件，它的作用是触发 hello 的构建。如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“hello”这个文件，并把这个文件作为最终的目标文件。3.如果hello文件不存在，或是hello所依赖的后面的hello.o文件的文件修改时间要比hello这个文件新（可以用 touch 测试），那么，他就会执行后面所定义的命令来生成hello这个文件。 如果hello所依赖的hello.o文件不存在，那么make会在当前文件中找目标为hello.o文件的依赖性，如果找到则再根据那一个规则生成hello.o文件。（这有点像一个堆栈的过程） 当然，你的C文件和H文件是存在的啦，于是make会生成 hello.o 文件，然后再用 hello.o 文件声明make的终极任务，也就是执行文件hello了。 这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。 在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。 make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。makefile 的核心：目标、依赖、命令。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#### **不改变代码，只可以make一次**- 因为提供编译效率- 怎么做到：**一定是源文件形成可执行文件**，先有源文件，才有可执行文件，一般而言，**源文件的最近修改时间是比可执行文件要老**的。- 如果我们更改了源文件，历史上曾经还有可执行文件，那么源文件的最近修改时间一定比可执行程序要新！ 只需要比较可执行程序的最近修改时间 和 源文件的最近可修改时间： .exe 新于 .c 源文件是老的，不需要重新编译 **.exe 老于 .c 源文件是新的，需要重新编译**### 项目清理- 像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。- 但是一般我们这种clean的目标文件，我们将它设置为伪目标,用 .PHONY 修饰,伪目标的特性是，总是被执行的。---## 2.Linux调试器-gdb使用### 1、背景- 程序发布的方式有两种，debug模式和release模式- Linux gcc/g++出来的二进制程序，默认是release模式- 要使用gdb调试，必须在源代码生成二进制程序的时候，加上-g选项![img](https://i-blog.csdnimg.cn/direct/9382b703269348b99c6a488b4464ac6e.png)### 2、使用gdb binFill![img](https://i-blog.csdnimg.cn/direct/a6114a60c15748a69a8135c897dce9c6.png)退出：ctrl+d / quit调试命令：- list / l 行号：显示源代码，接着上次的位置往下列，每次列10行&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/9cbd1857123442239a1f7c4c8d97f10f.png&quot; alt=&quot;img&quot; style=&quot;zoom: 50%;&quot; /&gt;- list / l 函数名：列出某个函数的源代码 &lt;img src=&quot;https://i-blog.csdnimg.cn/direct/523ac22af7bd469290afc07bacb5e629.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;- r / run：运行程序![img](https://i-blog.csdnimg.cn/direct/ac987f5a20c143fe8e40eef0c122d9fb.png)- break(b) 行号：在某一行设置断点：![img](https://i-blog.csdnimg.cn/direct/47778a22c310467b8c44bba359851926.png)- n / next：单条执行（逐过程进行）：![img](https://i-blog.csdnimg.cn/direct/f8b80ce0bdf9437f9a12b33f4a98954b.png)- s / step：进入函数调用（逐语句进行）：![img](https://i-blog.csdnimg.cn/direct/be272d3dbd0c40c7a7dbafa5c59f6ae2.png)- break 函数名：在某个函数开头设置断点![img](https://i-blog.csdnimg.cn/direct/cd4f9500f18d47869a197a51b12ef491.png)- info break(b)：查看断点信息&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/2e7e4eeb9d4e45a4b1ec5034556d9e7b.png&quot; alt=&quot;img&quot; style=&quot;zoom:150%;&quot; /&gt; 1.Num：断点编号。2.Type：断点类型（普通断点）。3.Disp：断点处置方式（keep 表示断点会一直保留，即使程序重新启动）。4.Enb：是否启用（y 表示启用）。5.Address：断点对应的内存地址。6.What：断点的具体位置。123456789- finish：执行到当前函数返回，然后停下来等待命令（可以查看问题出现在哪个函数）![img](https://i-blog.csdnimg.cn/direct/83a25d6769d94a81a9fe1ed36b94759f.png)- print(p)：打印表达式的值，通过表达式可以修改变量的值或者调用函数&lt;img src=&quot;https://i-blog.csdnimg.cn/direct/278c41087d30454f9bd040a9208b31a0.png&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;- set var：修改变量的值，快速到达某次循环![img](https://i-blog.csdnimg.cn/direct/84499600bb944a019ccb6f58e4ceb418.png) continue(c)：从当前位置开始连续而非单步执行(直接到下一个断点)run(r)：从开始连续而非单步执行delete breakpoints：删除所有断点delete breakpoint n：删除序号为n的断点disable breakpoints：禁用断点enable breakpoint：启动断点info breakpoints(i b):查看当前设置了哪些断点display 变量名：跟踪查看一个变量，每次停下来都显示它的值undisplay：取消对先前设置的哪些变量的跟踪until x行号：跳至x行(可以跳出循环）breaktrace(bt)：查看各级函数调用及参数info(i) locals：查看当前栈帧局部变量的值quit(q)：退出gdb12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455---### 交叉编译交叉编译是指**在一个平台上编译代码，使其能够在另一个不同的平台上运行的过程**。交叉编译是使用一种编译器（称为交叉编译器），该编译器在宿主机（host）上运行，但生成的目标代码却可以在目标机（target）上运行。宿主机和目标机通常有不同的硬件架构和操作系统环境。一般应用在：- **嵌入式系统**：如物联网设备、路由器、工业控制器等。- **移动设备**：如智能手机、平板电脑等。- **特定架构的服务器**：如ARM服务器。- **操作系统开发**：如为不同架构编译Linux内核。一些特点：- 忽略硬件限制：目标机可能资源有限（如内存、CPU），无法运行完整的编译环境。- 避免操作系统差异：目标机可能运行的是实时操作系统、嵌入式系统或其他特殊的操作系统，这些系统可能不具备完整的开发工具链。- 增加开发便利性：在功能强大的宿主机上进行开发和测试更加方便，可以使用丰富的调试工具和IDE。- 提升优化和调试效果：宿主机上的高级开发工具可以帮助更好地优化和调试代码。### 3. 交叉编译器交叉编译器是专门为生成目标平台机器码而设计的编译器。一个典型的交叉编译器通常包含以下几个组件：- **编译器**（如GCC）：用于将**源代码编译成汇编代码**。- **汇编器**：将**汇编代码转换为目标机的机器码**。- **链接器**：**将多个目标文件链接成最终的可执行文件**。- **其他工具**：如**ar（静态库管理工具）、ranlib（更新静态库索引）、strip（去除调试信息）**等。### 4. 交叉编译工具链交叉编译工具链是一套工具的集合，包含了编译器、链接器、汇编器等工具，以及相关的库文件和系统头文件。工具链通常针对特定的目标平台定制，例如：- **ARM交叉编译工具链**：用于编译ARM架构的代码。- **MIPS交叉编译工具链**：用于编译MIPS架构的代码。- **x86交叉编译工具链**：用于编译x86架构的代码。### 5. 交叉编译的一般步骤- **准备工具链**：获取适用于目标平台的交叉编译工具链。- **配置环境**：设置环境变量，确保编译器知道工具链的位置。- **编写Makefile或配置工具**：使用适当的配置工具（如autotools、CMake等）来生成Makefile，确保这些工具能够识别交叉编译器。- **编译源代码**：运行编译命令，生成目标平台的二进制文件。- **测试和调试**：在目标平台上测试生成的二进制文件，并进行必要的调试。开发板编译工具链的例子：```shellarm-buildroot-linux-gnueabihf-gcc -o hello hello.c 可以用file命令查看文件的类型 CMake1.什么是CMake不同的IDE所集成的make工具所遵循的规范和标准都不同，也就导致其语法、格式不同，也就不能很好的跨平台编译，会再次使得工作繁琐起来。 那么cmake为了解决这个问题而诞生了，其允许开发者指定整个工程的编译流程，在根据编译平台，生成本地化的Makefile和工程文件，最后用户只需make编译即可 简而言之，*可以把cmake看成一款自动生成 Makefile的工具，所以编译流程就变成了：cmake—&gt;make–&gt;用户代码–&gt;可执行文件* 2.CMakeflie的安装和版本的查看首先我们需要安装我们的CMake 1sudo yum install cmake 然后我们可以通过 1cmake -version 来查看自己的cmake的版本 3.几个简单示例事实上，cmake的用法特别简单 *编写CMakeLists.txt* *执行命令cmake .* *执行命令make* *运行执行程序* 看几个例子来 3.1.编译一个.cc文件 首先让我们从最简单的代码入手，先来体验下cmake是如何操作的。编写main.cc，如下， 1234567#include &lt;stdio.h&gt; int main(void){ printf(&quot;Hello World\\n&quot;); return 0;} 然后在main.cc相同目录下编写CMakeLists.txt，内容如下， 12345cmake_minimum_required (VERSION 2.8)project (demo)add_executable(main main.cc) 第一行意思是表示cmake的最低版本要求是2.8，我们安装的是3.20.2； 第二行是表示本工程信息，也就是工程名叫demo； 第三行比较关键，表示最终要生成的elf文件的名字叫main，使用的源文件是main.cc 在终端下切到main.cc所在的目录下，然后输入以下命令运行下面这个命令 1cmake . 执行之后，就会有下面这样子的情况发生 我们再看看当前目录下面 我们发现当前目录下面有Makefile了，我们打开看看 好像不认识啊 ，这个我们不管，我们退出来make一下 完美啊！ 3.2.编译一个.hpp文件和一个.cc文件接下来我将编译一个.hpp文件和一个.cc文件 method.hpp 1234567#pragma once#include&lt;iostream&gt;void Printf(){ std::cout&lt;&lt;&quot;hello world!&quot;&lt;&lt;std::endl;} main.cc 123456#include&quot;method.hpp&quot;int main(){ Printf();} CMakeLists.txt 12345678910111213cmake_minimum_required(VERSION 2.8) project(demo) # 添加可执行文件，只需要列出源文件，头文件不需要列出 add_executable(main main.cc) # method.hpp 是 main.cc 依赖的头文件，确保它位于正确的路径下 # CMake 会自动处理包含路径（如果设置了正确的包含目录） # 如果需要，可以使用 include_directories 来指定头文件搜索路径 # include_directories(path/to/headers) # 但头文件和源文件在同一目录下，通常不需要这样做 我们执行 1cmake . 完美！ 3.3.编译一个.hpp文件和两个.cc文件接下来进入稍微复杂的例子：这次我们决定编译一个.h文件和两个.cc文件 method.hpp 123#pragma once#include&lt;iostream&gt;void Printf(); method.cc 12345#include&quot;method.hpp&quot;void Printf(){ std::cout&lt;&lt;&quot;hello world&quot;&lt;&lt;std::endl;} main.cc 123456#include&quot;method.hpp&quot; int main(){ Printf();} 我们现在就来编写CMakeLists.txt CMakeLists.txt 12345cmake_minimum_required (VERSION 2.8)project (demo)add_executable(main main.cc method.cc) 注意我这里只是在main.cc后面加路method.cc 我们使用一下 1cmake . 完美啊！！ 3.4.编译两个.hpp文件和一个.cc文件接下来我们将使用method.hpp，way.hpp，main.cc文件来编译 way.hpp 123456#pragma once#include&lt;iostream&gt;void Printf1(){ std::cout&lt;&lt;&quot;Printf1&quot;&lt;&lt;std::endl;} method.hpp 123456#pragma once#include&lt;iostream&gt;void Printf2(){ std::cout&lt;&lt;&quot;Printf2&quot;&lt;&lt;std::endl;} main.cc 1234567#include&quot;way.hpp&quot;#include&quot;method.hpp&quot;int main(){ Printf1(); Printf2();} CMakeLists.txt 12345cmake_minimum_required (VERSION 2.8)project (demo)add_executable(main main.cc) 注意：因为我这里只有一个源文件，所以我们写一个main.cc就好 我们执行 1cmake . 完美！ 4.CMakeLists.txt​ 编写CMakeLists.txt最常用的功能就是调用其他的.h头文件和.so/.a库文件，将.cpp/.c/.cc文件编译成可执行文件或者新的库文件。 4.1.CMakeLists.txt常用的几条指令CMakeLists.txt 文件使用一系列的 CMake 指令来描述构建过程。常见的指令包括： 1、指定 CMake 的最低版本要求： 1cmake_minimum_required(VERSION &lt;version&gt;) 例如： 1cmake_minimum_required(VERSION 3.10) 2、定义项目的名称和使用的编程语言： 1project(&lt;project_name&gt; [&lt;language&gt;...]) 例如： 1project(MyProject CXX) 3、指定要生成的可执行文件和其源文件： 1add_executable(&lt;target&gt; &lt;source_files&gt;...) 例如： 1add_executable(MyExecutable main.cpp other_file.cpp) 4、创建一个库（静态库或动态库）及其源文件： 1add_library(&lt;target&gt; &lt;source_files&gt;...) 例如： 1add_library(MyLibrary STATIC library.cpp) 5、链接目标文件与其他库： 1target_link_libraries(&lt;target&gt; &lt;libraries&gt;...) 例如： 1target_link_libraries(MyExecutable MyLibrary) 6、添加头文件搜索路径： 1include_directories(&lt;dirs&gt;...) 例如： 1include_directories(${PROJECT_SOURCE_DIR}/include) 7、设置变量的值： 1set(&lt;variable&gt; &lt;value&gt;...) 例如： 1set(CMAKE_CXX_STANDARD 11) 8、设置目标属性： 1234target_include_directories(TARGET target_name [BEFORE | AFTER] [SYSTEM] [PUBLIC | PRIVATE | INTERFACE] [items1...]) 例如： 1target_include_directories(MyExecutable PRIVATE ${PROJECT_SOURCE_DIR}/include) 9、安装规则： 1234567install(TARGETS target1 [target2 ...] [RUNTIME DESTINATION dir] [LIBRARY DESTINATION dir] [ARCHIVE DESTINATION dir] [INCLUDES DESTINATION [dir ...]] [PRIVATE_HEADER DESTINATION dir] [PUBLIC_HEADER DESTINATION dir]) 例如： 1install(TARGETS MyExecutable RUNTIME DESTINATION bin) 10、条件语句 (if, elseif, else, endif 命令) 1234567if(expression) # Commandselseif(expression) # Commandselse() # Commandsendif() 例如： 123if(CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;) message(&quot;Debug build&quot;)endif() 11、自定义命令 (add_custom_command 命令)： 123456789add_custom_command( TARGET target PRE_BUILD | PRE_LINK | POST_BUILD COMMAND command1 [ARGS] [WORKING_DIRECTORY dir] [COMMAND command2 [ARGS]] [DEPENDS [depend1 [depend2 ...]]] [COMMENT comment] [VERBATIM]) 例如： 1234add_custom_command( TARGET MyExecutable POST_BUILD COMMAND ${CMAKE_COMMAND} -E echo &quot;Build completed.&quot;) *实例* 一个简单的 CMakeLists.txt 文件示例： 12345678cmake_minimum_required(VERSION 3.10)project(MyProject CXX)# 添加源文件add_executable(MyExecutable main.cpp) # 设置 C++ 标准set(CMAKE_CXX_STANDARD 11) 4.2.变量和缓存[CMake 使用](https://so.csdn.net/so/search?q=CMake 使用&amp;spm=1001.2101.3001.7020)变量来存储和传递信息，这些变量可以在 CMakeLists.txt 文件中定义和使用。 变量可以分为普通变量和缓存变量。 4.2.1.变量定义与使用定义变量： 1set(MY_VAR &quot;Hello World&quot;) 使用变量： 1message(STATUS &quot;Variable MY_VAR is ${MY_VAR}&quot;) 4.2.2.缓存变量缓存变量存储在 CMake 的缓存文件中，用户可以在 CMake 配置时修改这些值。缓存变量通常用于用户输入的设置，例如编译选项和路径。 定义缓存变量： 1set(MY_CACHE_VAR &quot;DefaultValue&quot; CACHE STRING &quot;A cache variable&quot;) 使用缓存变量： 1message(STATUS &quot;Cache variable MY_CACHE_VAR is ${MY_CACHE_VAR}&quot;) 4.3.查找库和包CMake 可以通过 find_package() 指令自动检测和配置外部库和包。 常用于查找系统安装的库或第三方库。 4.3.1.find_package() 指令基本用法： 1find_package(Boost REQUIRED) 指定版本： 1find_package(Boost 1.70 REQUIRED) 查找库并指定路径： 1find_package(OpenCV REQUIRED PATHS /path/to/opencv) 使用查找到的库： 1target_link_libraries(MyExecutable Boost::Boost) 设置包含目录和链接目录： 12include_directories(${Boost_INCLUDE_DIRS})link_directories(${Boost_LIBRARY_DIRS}) 4.3.2.使用第三方库假设你想在项目中使用 Boost 库，CMakeLists.txt 文件可能如下所示： 实例 1234567891011cmake_minimum_required(VERSION 3.10)project(MyProject CXX) # 查找 Boost 库find_package(Boost REQUIRED) # 添加源文件add_executable(MyExecutable main.cpp) # 链接 Boost 库target_link_libraries(MyExecutable Boost::Boost) 通过上述内容，用户可以了解 CMakeLists.txt 文件的基本结构和常用指令，掌握如何定义和使用变量，查找和配置外部库，从而能够有效地使用 CMake 管理项目构建过程。","link":"/2025/01/02/GCC%E7%BC%96%E8%AF%91/"},{"title":"GPIO接口","text":"GPIO接口 GPIO：通用输入输出接口，在开发板上常以引脚（pin）的方式出现。 两种使能：时钟或者供电 模式：可用于GPIO或者其他比如UART、I2C或SPI的接口 GPIO模式时，可以对其进行编程，主要是对其寄存器进行操作，使其输出高低电平。 修改方式： 直接读写：读出、修改bit位、写入； 使用设置和清除协议：对set_reg、clr_reg或data_reg寄存器进行操作以统一地修改。","link":"/2025/01/03/GPIO%E6%8E%A5%E5%8F%A3/"},{"title":"Jetson Nano B01基本情况","text":"Jetson Nano B01基本情况 jetson nano b01是一种SOC，片上系统，就是在芯片上集成了CPU、GPU、内存以及多种外设接口和通信模块的一整个系统。 我拿到的这款jetson，它的CPU是4核Arm Cortex-A57的架构，还有一颗128核的Maxwell架构的GPU，再一个它扩展了两个摄像头的接口，所以能在上面部署一些CV的应用，比如图像识别，能够进行障碍物的识别，再通过深度相机和传感器返回的数据进行分析，输出控制指令到STM32上来控制电机。 我觉得，这块jetson的最大优势就是成本低的同时还能验证一些AI的应用，这块jetson还可以支持DeepSeek-R1的1.5B的蒸馏模型，在第二个项目上我想用它基于这个MCP大模型上下文协议来接入一些好用的工具，尝试让大模型通过ROS2的节点发布控制或者交互的topic。","link":"/2024/12/21/Jetson%20Nano%20B01%E5%9F%BA%E6%9C%AC%E6%83%85%E5%86%B5/"},{"title":"Linux基础和常用命令","text":"Linux基础和常用命令 Linux目录和具体内容 2.3.2 目录/文件操作命令123456789101112131415161. pwd —— 打印当前路径2. cd —— 切换路径 1.1 cd - —— 上次目录 1.2 cd ~ —— 进入家目录3. mkdir —— 创建目录4. rmdir —— 删除目录5. ls —— 列出目录内容 1.1 ls -a —— 列出所有文件，包括隐藏文件 1.2 ls -l / ll —— 以详细列表的形式列出目录内容 1.3 ls -h —— 以人类可读的方式列出来6. cp —— 复制文件或目录 6.1 cp -r 递归地复制所有文件 6.2 cp -f 强制覆盖 -d 作为链接文件复制7. rm —— 删除文件或目录 -r -f8. cat —— 打印文件内容到标准输出9. touch —— 修改文件时间或创建空文件 就是记事本 su命令 切换当前用户","link":"/2025/01/05/Linux%E5%9F%BA%E7%A1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Linux编译调试工具链及常用命令","text":"Linux编译调试工具链及常用命令 Linux常用命令 Git——代码管理和协作开发工具 常用的git命令： 配置 git config –global user.name “name” git config –globle user.email “name@example.com“ 仓库操作1. git init 在当前目录初始化一个新的git仓库，会生成一个.git隐藏目录，存放配置和数据1. git clone 克隆一个已有的仓库地址到本地，一般通过这个拉取github上的远程仓库 分支操作 git branch 查看当前仓库的所有分支，一般会有一个默认分支main git branch [分支名] 创建分支 git checkout [分支名] 切换分支 git merge [分支名] 将指定分支的更改合并到当前分支 git branch -d [分支名] 删除指定分支 提交操作 git add [文件名] 将文件添加到暂存区 git status 查看仓库状态，会显式文件的修改信息 git commit -m “提交信息” 将暂存区的修改提交到本地仓库，并且描述提交信息，方便之后查看 git log 查看提交日志 远程仓库操作 git remote -v 查看关联的远程仓库 git push [远程仓库名] [分支名] 将本地分支更改推送到远程仓库 git pull [远程仓库名] [分支名] 从远程仓库拉取最新更改合并到当前分支 其他操作 查看分支差异git diff [1] [2] 查看文件历史git blame 回退到之前的提交 git reset –hard [提交哈希值] 一般的开发流程： 克隆仓库 git clone 进入目录后用git branch查看分支，根据情况branch创建或checkout切换分支 在分支内进行开发，写代码 写完之后可以git statue查看修改状态，然后将修改git add提交到暂存区，再git commit 提交更改 将本地的更改用git push推送到远程仓库，之后可以用git log查看日志 冲突的处理 合并或拉取的时候有冲突一般是修改没提交，要手动添加到暂存区或者commit提交 或者暂时用git add标记一下冲突的文件 GCC编译命令 GDB调试流程 Makefile语法及常用编译流程 CMake语法及常用编译流程","link":"/2025/01/03/Linux%E7%BC%96%E8%AF%91%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E9%93%BE%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Socket网络编程","text":"Socket网络编程 网络知识介绍 客户端和服务端 网络程序是由两个部分组成的–客户端和服务器端. 客户端——主动和外面的程序通信的程序 服务端——和客户端相对应，被动的等待外面的程序来和自己通讯的程序。 实际生活中有些程序是互为服务和客户端。在这种情况下， 一个程序既为客户端也是服务端。 常用的命令 由于网络程序是有两个部分组成,所以在调试的时候比较麻烦,为此我们有必要知道一些常用的网络命令 netstat 命令netstat是用来显示网络的连接,路由表和接口统计等网络的信息.netstat有许多的选项. 我们常用的选项是-na 用来显示详细的网络状态.至于其它的选项我们可以使用帮助手册获得详细的情况. telnet telnet是一个用来登录远程的程序,但是我们完全可以用这个程序来调试我们的服务端程序的. 比如我们的服务器程序在监听8888端口,我们可以用telnet localhost 8888来查看服务端的状况. ping ping程序用来判断网络的状态是否正常，最经常的一个用法是ping 192.168.0.1 表示我们想查看到192.168.0.1的硬件连接是否正常 TCP编程 Linux系统是通过提供套接字(socket)来进行网络编程的.网络程序通过socket和其它几个函数的调用, 会返回一个通讯的文件描述符,我们可以将这个描述符看成普通的文件的描述符来操作,这就是linux的设备无关性的好处.我们可以通过向描述符读写操作实现网络之间的数据交流. 服务端流程： 首先调用socket得到一个sockfd，类似文件句柄，此时其中没有任何ip信息； 调用bind绑定一个端口：表明这个服务器要监测这个ip的这个端口，地址信息来自结构体； 调用listen函数开始监测； 在while(1)中调用accept函数来等待客户端的连接，如果有客户端来连接，返回一个来自客户端的sockfd； 连接后，统计一下连接数，打印一些信息表示连接成功； 如果等待多个客户端连接，那么就在连接并打印信息后，对于每个客户端创建一个子进程，在子进程中，用recv函数，传入客户端sockfd和缓冲区，接受客户端发来的数据并显示出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* 包含的系统调用： socket bind listen accept send/recv*/// server.c// 端口#define SERVER_PORT 8888// 连接数量#define BACKLOG 10int main(int argc, char **argv){ int iSocketServer;// 返回的sockfd struct sockaddr_in tSocketServerAddr;// 服务端地址信息 struct sockaddr_in tSocketClientAddr;// 客户端地址信息 int iSocketClient;// 客户端sockfd int iRet;// 返回值 int iAddrLen;// 地址长度 int iRecvLen;// 接受到的数据 unsigned char ucRecvBuf[1000]; int iClientNum = -1;// 接收到的客户端连接数量 // 设置一下结构体 tSocketServerAddr.sin_family = AF_INET;// 进程间通信还是Internet tSocketServerAddr.sin_port = htons(SERVER_PORT);// 要监听的端口号 host to net, short,字节序的转换 tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// 本机上所有的ip memset(tSocketServerAddr.sin_zero, 0, 8);// 设置为0，8字节 // 创建socket iSocketServer = socket(AF_INET, SOCK_STREAM, 0);// 选择Internet和TCP if(-1 == iSocketServer){ printf(&quot;socket error!\\n&quot;); return -1; } // 绑定socket iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(-1 == iRet){ printf(&quot;bind error!\\n&quot;); return -1; } // 开始监听 iRet = listen(iSocketServer, BACKLOG); if(-1 == iRet){ printf(&quot;listen error!\\n&quot;); return -1; } // 等待一条连接并接受 while(1){ // 传入客户端地址信息 iAddrLen = sizeof(struct sockaddr); iSocketClient = accept(iSocketServer, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if(-1 != iSocketClient){ iClientNum++;// 连接数加一 // 返回不为-1则说明连接成功，并打印客户端地址信息 printf(&quot;Get connect from client %d : %s\\n&quot;, iClientNum, inet_ntoa(tSocketClientAddr.sin_addr));// inet_ntoa 将地址信息转换为我们能看懂的字符串 // 用子进程去接受数据 if(0 == fork()){ // child while(1){ // 接受客户端发来的数据并显示出来 iRecvLen = recv(iSocketClient, ucRecvBuf, 999, 0); if(iRecvLen &lt;= 0){ // 接受出错 close(iSocketClient); return -1; }else{ // 接受成功，打印缓冲区的消息 ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From Client %d: %s\\n&quot;, iClientNum, ucRecvBuf); } } } } } close(iSocketServer); return 0;} 客户端流程： 调用socket得到一个客户端句柄； 调用connect函数让服务端连接到客户端句柄，传入服务端的地址信息； 连接成功后，在while(1)中先用fgets从标准输入得到数据存储缓冲区，再调用send函数将缓冲区的数据发送出去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 包含的系统调用： socket connect send/recv*/// client.c// 端口#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient; struct sockaddr_in tSocketServerAddr;// 服务端地址信息 struct sockaddr_in tSocketClientAddr;// 客户端地址信息 int iRet; unsigned char ucSendBuf[1000]; int iSendLen; if(argc != 2){ printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } iSocketClient = socket(AF_INET, SOCK_STREAM, 0); // 设置一下结构体 tSocketServerAddr.sin_family = AF_INET;// 进程间通信还是Internet tSocketServerAddr.sin_port = htons(SERVER_PORT);// 要监听的端口号 host to net, short,字节序的转换 // tSocketServerAddr.sin_addr.s_addr = INADDR_ANY;// 本机上所有的ip if(0 == inet_aton(argv[1], &amp;tSocketServerAddr.sin_addr))// 将命令行输入的服务端ip存到结构体里 { printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8);// 设置为0，8字节 // 为客户端fd连接服务端地址信息 iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if(-1 == iRet){ printf(&quot;connect error!\\n&quot;); return -1; } // 发数据 while(1){ // 从标准输入获得数据 if(fgets(ucSendBuf, 999, stdin)){ // 如果获得了数据，用send发送数据 iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0); if(iSendLen &lt;= 0){ // 发送出错 close(iSocketClient); return -1; } } } return 0;} 运行写好的客户端和服务端程序 12345671.先运行服务端$./server2.(另一个终端)运行客户端加服务端ip$./client 192.168.1.1233.(连接成功)服务端收到连接成功的信息4.(客户端发送数据)发送abc5.(服务端接受数据)从client 0收到abc 关于僵尸进程——子进程退出 是指一个完成执行的子进程，这个子进程通过系统调用exit或其他方式退出后，父进程还没有通过wait或waitpid等系统调用来回收它的资源和状态信息，这时候会留下一个僵尸进程，用ps命令可以看到进程状态显示为“Z”，它不占内存和cpu，但是占用进程表项。 通常的危害就是占用了进程号，增加了os的管理负担。 如何避免？ 在父进程中，在子进程结束时调用wait或wait系统调用来获取子进程的退出状态并让os回收资源。 用SIGCHLD信号，父进程注册一个信号处理函数来处理SIGCHLD信号。 或者让父进程在子进程之前退出，一般不用，此时子进程会被init进程接管并清理掉。用kill -9 父进程pid来杀死父进程。 SIGCHLD信号 123在一个程序的开始调用：signal(SIGCHLD,SIG_IGN);意思是调用signal将SIGCHLD的配置设置为忽略，就不会产生僵尸进程了。 UDP编程服务端流程： 调用socket获得一个服务端句柄； 将ip和端口，调用bind绑定这个服务端句柄； 直接使用recvfrom接受数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;/* socket * bind * sendto/recvfrom */#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketServer; int iSocketClient; struct sockaddr_in tSocketServerAddr; struct sockaddr_in tSocketClientAddr; int iRet; int iAddrLen; int iRecvLen; unsigned char ucRecvBuf[1000]; int iClientNum = -1; iSocketServer = socket(AF_INET, SOCK_DGRAM, 0); if (-1 == iSocketServer) { printf(&quot;socket error!\\n&quot;); return -1; } tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT); /* host to net, short */ tSocketServerAddr.sin_addr.s_addr = INADDR_ANY; memset(tSocketServerAddr.sin_zero, 0, 8); iRet = bind(iSocketServer, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if (-1 == iRet) { printf(&quot;bind error!\\n&quot;); return -1; } while (1) { iAddrLen = sizeof(struct sockaddr); iRecvLen = recvfrom(iSocketServer, ucRecvBuf, 999, 0, (struct sockaddr *)&amp;tSocketClientAddr, &amp;iAddrLen); if (iRecvLen &gt; 0) { ucRecvBuf[iRecvLen] = '\\0'; printf(&quot;Get Msg From %s : %s\\n&quot;, inet_ntoa(tSocketClientAddr.sin_addr), ucRecvBuf); } } close(iSocketServer); return 0;} 客户端流程： 调用socket获得一个客户端句柄； 为客户端句柄，调用connect连接服务端地址信息； 直接使用send/sendto发送数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;/* socket * connect * send/recv */#define SERVER_PORT 8888int main(int argc, char **argv){ int iSocketClient; struct sockaddr_in tSocketServerAddr; int iRet; unsigned char ucSendBuf[1000]; int iSendLen; int iAddrLen; if (argc != 2) { printf(&quot;Usage:\\n&quot;); printf(&quot;%s &lt;server_ip&gt;\\n&quot;, argv[0]); return -1; } iSocketClient = socket(AF_INET, SOCK_DGRAM, 0); tSocketServerAddr.sin_family = AF_INET; tSocketServerAddr.sin_port = htons(SERVER_PORT); /* host to net, short */ //tSocketServerAddr.sin_addr.s_addr = INADDR_ANY; if (0 == inet_aton(argv[1], &amp;tSocketServerAddr.sin_addr)) { printf(&quot;invalid server_ip\\n&quot;); return -1; } memset(tSocketServerAddr.sin_zero, 0, 8);#if 0 iRet = connect(iSocketClient, (const struct sockaddr *)&amp;tSocketServerAddr, sizeof(struct sockaddr)); if (-1 == iRet) { printf(&quot;connect error!\\n&quot;); return -1; }#endif while (1) { if (fgets(ucSendBuf, 999, stdin)) {#if 0 iSendLen = send(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0);#else iAddrLen = sizeof(struct sockaddr); iSendLen = sendto(iSocketClient, ucSendBuf, strlen(ucSendBuf), 0, (const struct sockaddr *)&amp;tSocketServerAddr, iAddrLen);#endif if (iSendLen &lt;= 0) { close(iSocketClient); return -1; } } } return 0;} 运行和TCP一样 服务器和客户机的信息函数 3.1 字节转换函数 在网络上面有着许多类型的机器,这些机器在表示数据的字节顺序是不同的,* *比如i386芯片是低字节在内存地址的低端,高字节在高端,而alpha*芯片却相反，为了统一起来*,在Linux下面,*有专门的字节转换函数. 1234unsigned long int htonl(unsigned long int hostlong)unsigned short int htons(unisgned short int hostshort)unsigned long int ntohl(unsigned long int netlong)unsigned short int ntohs(unsigned short int netshort) 在这四个转换函数中,h 代表host, n 代表 network. s 代表short ，l 代表long第一个函数的意义是将本机器上的long数据转化为网络上的long. 其他几个函数的意义也差不多. 3.2 IP和域名的转换在网络上标志一台机器可以用IP或者是用域名.那么我们怎么去进行转换呢? 123456789101112131415struct hostent *gethostbyname(const char *hostname)struct hostent *gethostbyaddr(const char *addr,int len,int type)// struct hostent的定义：struct hostent{ char *h_name; /* 主机的正式名称 */ char *h_aliases; /* 主机的别名 */ int h_addrtype; /* 主机的地址类型 AF_INET*/ int h_length; /* 主机的地址长度 对于IP4 是4字节32位*/ char **h_addr_list; /* 主机的IP地址列表 */ } #define h_addr h_addr_list[0] /* 主机的第一个IP地址*/gethostbyname可以将机器名(如 linux.yessun.com)转换为一个结构指针.在这个结构里面储存了域名的信息gethostbyaddr可以将一个32位的IP地址(C0A80001)转换为结构指针.这两个函数失败时返回NULL 且设置h_errno错误变量,调用h_strerror()可以得到详细的出错信息 3.3 字符串的IP和32位的IP转换.在网络上面我们用的IP都是数字加点(192.168.0.1)构成的, 而在struct in_addr结构中用的是32位的IP,我们上面那个32位IP(C0A80001)是的192.168.0.1 为了转换我们可以使用下面两个函数 12int inet_aton(const char *cp,struct in_addr *inp)char *inet_ntoa(struct in_addr in) 函数里面 a 代表 ascii n 代表network.第一个函数表示将a.b.c.d的IP转换为32位的IP,存储在 inp指针里面.第二个是将32位IP转换为a.b.c.d的格式. 3.4 服务信息函数在网络程序里面我们有时候需要知道端口.IP和服务信息.这个时候我们可以使用以下几个函数 1234567891011int getsockname(int sockfd,struct sockaddr *localaddr,int *addrlen)int getpeername(int sockfd,struct sockaddr *peeraddr, int *addrlen)struct servent *getservbyname(const char *servname,const char *protoname)struct servent *getservbyport(int port,const char *protoname)struct servent { char *s_name; /* 正式服务名 */ char **s_aliases; /* 别名列表 */ int s_port; /* 端口号 */ char *s_proto; /* 使用的协议 */ } 一般我们很少用这几个函数.对应客户端,当我们要得到连接的端口号时在connect调用成功后使用可得到系统分配的端口号.对于服务端,我们用INADDR_ANY填充后,为了得到连接的IP我们可以在accept调用成功后 使用而得到IP地址.在网络上有许多的默认端口和服务,比如端口21对ftp80对应WWW.为了得到指定的端口号的服务 我们可以调用第四个函数,相反为了得到端口号可以调用第三个函数.","link":"/2025/01/06/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"title":"TCP&#x2F;UDP网络编程","text":"TCP/UDP网络编程 网络编程有三个要素，分别是IP地址、端口号和通信协议。 一、IP地址网络中的计算机使用IP地址来进行唯一标识，IP地址有IPv4和IPv6两种类型。IPv4采用十进制或二进制表示形式，十进制是一种比较常用的表示形式，如192.168.1.131，IPv6采用十六进制表示形式，一般不常用。 查看IP地址相关信息： Windows命令——ipconfig Linux或Mac——ifconfig`命令 二、端口号端口号是计算机中的应用程序的一个整数数字标号，用来区分不同的应用程序。 0 ~ 1023 为被系统使用或保留的端口号，0 ~ 65535为有效的端口号，也就是说我们要对一些程序定义端口号的时候，要选择1024 ~ 65535范围内的整数数字。 ftp服务器：使用21号端口。 ssh服务器：使用22号端口。 telnet服务器：使用23号端口。 http服务器：使用80号端口。 https服务器：使用443号端口。 三、通信协议说的通俗一点，通信协议就是网络通信中的规则，分为TCP协议和UDP协议两种。 第一种：TCP协议英文名：Transmission Control Protocol 中文名：传输控制协议 协议说明：TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。 举例：传输前要建立连接，比如打电话，需要双方都接通，才能进行对话。 特点：效率低，数据传输比较安全，因为有重传机制。 面向连接的 可靠的 面向字节流的 确认应答(ACK)机制对于TCP双方发送的每一个报文，作为接收的一方都需要发送确认应答信息（ACK）来表示自己已经接收到了对端发送的报文，这样的机制即为确认应答机制，而这种机制保证了对端接收到了信息，也即保证了发送数据的可靠性。 TCP将每个字节的数据都进行了编号. 即为序列号; 那么主机A与B进行数据传输的时候如下图: 应答时ACK标志位置1,每一个ACK都带有对应的确认序列号, 意思是告诉发送者, 我已经收到了哪些数据; 从而让发送端下一次从相应位置开始发。 这个序列号也解决了数据到达先后顺序的问题。 超时重传机制网络通信中可能存在这种情况:主机A发送数据给B之后, 可能因为网络拥堵等原因, 数据无法到达主机B; 那么如果主机A在一个特定时间间隔内没有收到B发来的确认应答, 就会进行重发; 情况二:数据到达了主机B，但是主机B的确认应答消息丢失了,那么A还是以为自己的数据没到，再次发送相同消息;这不就重复了吗？ 没关系,既然B之前已经收到了A的1~1000消息,那么确认序号就是1001发回A，即便A没收到确认，但是之后主机B意识到消息重复了，然后舍弃; 以上TCP超时重传机制也保证了TCP的可靠性; 那么这个重传所需要等待的时间怎么规范呢？ 时间太长，影响整体效率;时间太短，相同数据包可能重复发送;因此,TCP为了保证无论在任何环境下都能比较高性能的通信, 因此会动态计算这个最大超时时间; Linux中(BSD Unix和Windows也是如此), 超时以500ms为一个单位进行控制, 每次判定超时重发的超时时间都是- 500ms的整数倍.如果重发一次之后, 仍然得不到应答, 等待 2*500ms 后再进行重传.如果仍然得不到应答, 等待 4*500ms 进行重传. 依次类推, 以指数形式递增.累计到一定的重传次数, TCP认为网络或者对端主机出现异常, 强制关闭连接,释放资源。 连接管理机制 三次握手——TCP建立连接三次握手是由客户端connect()主动发起，之后由操作系统内部建立，accpet只是把建立连接的结果拿上到应用层; 客户端把含有SYN(同步报文段)标志位的报文发给server请求建立连接； server系统内部发回给client带有SYN+ACK标志位的报文，表示已收到，确认允许连接请求; client收到确认信息后，发送ACK确认报文给server; 因为connect与accept都是应用层上拿到连接的接口，则建立连接的具体过程由双方操作系统内部建立起来连接并将连接返回给connect()与accept(),我们可以通过他们的返回值判断连接是否建立成功！(连接由connect发起，操作系统内部自动完成！accpet只是看结果用); 123为什么是3次连接？两次握手不够：无法解决历史连接的干扰问题，也无法确认客户端是否正确接收了服务器的初始序列号。四次握手多余：会增加连接建立的时间和网络开销，而三次握手已经能够满足可靠性和效率的平衡。 四次挥手——TCP断开连接 每次挥手由断开方调用close(连接sock)发起挥手给对方发送FIN（结束报文段）； 在对方收到断开消息后，回应ACK，表示数据还未发完，稍等一下； 并准备数据处理完后，调用close(sock)与之也准备进行挥手断开； 同时等待ACK（last_ack）; 123为什么是四次挥手而不是三次挥手？三次挥手无法确保数据完整传输：如果接收方还有数据未发送，仅用三次挥手可能会导致数据丢失。四次挥手能够兼顾可靠性和效率：通过两次FIN和两次ACK，确保双方都能安全地关闭连接。 关于TIME_WAIT状态TIME_WAIT状态是TCP协议中一个重要的机制，其主要作用是： 确保最后一个ACK报文能够被对方收到：如果对方没有收到ACK报文，可能会重新发送FIN报文，此时TIME_WAIT状态可以确保连接不会被过早关闭。 防止历史连接的干扰：等待2MSL（2倍报文最大生存时间）时间，确保网络中残留的报文能够被清理干净，避免对后续连接造成干扰。 三次握手和四次挥手充分体现了标志位对区分普通报文和建立连接时的请求\\应答报文的重要性。 滑动窗口顾名思义，这个机制类似与算法里的滑动窗口; 之前我们提到过TCP的确认应答策略，即对于连接双方发送的每一个数据端，都需要进行ACK确认应答，收到ACK后再发送下一个数据段，但这样做有一个明显的缺陷，串行就是性能较差，尤其是数据往返时间较长的时候： 引入滑动窗口机制;我们将发送缓冲区分为三个部分： 其中红色标注部分就是滑动窗口，也就是说滑动窗口本质是发送缓冲区的一部分，其因为应发送的数据不断变化，而区域也不断变化，就像在滑动一样，故称为滑动窗口。 TCP协议报头里的16位窗口大小就是这个滑动窗口的大小,他的大小是受接收方接收缓冲区可用大小制约的，这个大小通过之前通信时接收方发来报头里的确认序号传递; 串行效率差我们来并行： 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值. 上图的窗口大小就是4000个字节(四个段) 发送前四个段的时候, 不需要等待任何 ACK, 直接发送 收到第一个段的ACK后, 滑动窗口向后移动, 继续发送第五个段的数据; 依次类推 操作系统内核为了维护这个滑动窗口, 需要开辟 发送缓冲区 来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉; 窗口越大, 则网络的吞吐率就越高; 滑动窗口可以让发送方一次发送大量数据，从而保证效率。 滑动窗口可以配合对端的接收能力，来实现流量控制。 快重传在并发传送数据过程中发生了丢包，除了超时重传机制应该怎么解决，这里分两种情况： 情况1: 数据包已经抵达, ACK被丢了 这种情况很容易解决，因为假设A的1~1000数据发过去了，但是B发回来的ack没收到，那么如果B发回来的2001或者更大位置的ack被A收到了(B一定是按顺序收的，如果收到大的index数据，那么证明之前的小序列号的数据已经收了)，则证明A的1~1001其实已经被B收到了，只是ack丢了，不用重新发1~1000了; 情况2： 发送的数据发生了丢包 假如A的1~1000发过去了，那么此时B只收到了1~1000，提醒A下一个是1001以后，A发给B的1001~2000数据丢了！那么B将收不到1001，即便是之后的2001~3000，3001~4000都过来了，B也不能收，只能先存缓冲区，并且返回接下来应该收到的序列1001; 如果A连续收到3次同样的ACK以后，就会意识到自己这个数据包丢了，然后重新发送给B,此时B终于拿到1001，紧接着把之前存到缓冲区的2000 ~3000 ~4000的数据拼起来，最后直接返回个4001ACK给A，A之后就能从4001继续传输数据了; 这种对付丢包问题的机制就被称为“高速重发机制”（也被叫做“快重传”）; 这种快重传(效率)可以理解为并发大量数据包时候的一种丢包处理方法，与超时重传(可靠性)不矛盾; 流量控制其实,在引入滑动窗口这个机制后，流量控制自然显现出来了；流量控制是TCP协议中保证效率的一个重要措施 接收端处理数据的速度是有限的，如果发送端发的太快, 导致接收端的缓冲区被打满, 这个时候如果发送端继续发送,就会造成丢包, 继而引起超时重传等等一系列连锁反应。 因此TCP支持根据接收端的处理能力, 来决定发送端的发送速度. 这个机制就叫做流量控制(Flow Control); 接收端将自己可以接收的缓冲区大小放入 TCP 首部中的 “窗口大小” 字段, 通过ACK端通知发送端;窗口大小字段越大, 说明网络的吞吐量越高; 接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;发送端接受到这个窗口之后, 就会减慢自己的发送速度; 如果接收端缓冲区满了, 就会将窗口置为0; 这时发送方不再发送数据, 但是需要定期发送一个窗口探测数据段, 使接收端把窗口大小告诉发送端同时防止接收端的窗口更新通知丢失，也要定期发送窗口探测数据包。 至于接收端如何把窗口大小告诉发送端呢? 之前我们介绍的TCP首部中, 有一个16位窗口字段, 就是存放了窗口大小信息;建立连接的时候就能给到发送端;那么问题来了, 16位数字最大表示65535, 那么TCP窗口最大就是65535字节么?实际上, TCP首部40字节选项中还包含了一个窗口扩大因子M, 实际窗口大小是 窗口字段的值左移 M 位。 拥塞控制在刚开始阶段就发送大量的数据, 仍然可能引发问题.因为网络上有很多的计算机, 可能当前的网络状态就已经比较拥堵. 在不清楚当前网络状态下, 贸然发送大量的数据, 是很有可能引起雪上加霜的. TCP引入慢启动机制, 先发少量的数据, 探探路, 摸清当前的网络拥堵状态, 再决定按照多大的速度传输数据. 此处引入一个概念程为拥塞窗口，发送开始的时候, 定义拥塞窗口大小为1，每次收到一个ACK应答, 拥塞窗口加1(相当于每次启动拥塞窗口大小是上次的一倍); 每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口; 像上面这样的拥塞窗口增长速度, 是指数级别的. “慢启动” 只是指初使时慢, 但是增长速度非常快 为了不增长的那么快, 因此不能使拥塞窗口单纯的加倍,此处引入一个叫做慢启动的阈值 当拥塞窗口超过这个阈值的时候, 不再按照指数方式增长, 而是按照线性方式增长 当TCP通信开始后, 网络吞吐量会逐渐上升; 如之后如果网络发生拥塞,拥塞控制生效，吞吐量会立刻下降; 这里的拥塞判断有不同策略：1.发生快重传(连续收到重复确认的次数维度) 2. 发生超时重传(等待确认的时间维度) 拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案 延迟应答关于确认应答机制，如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小; 假设接收端缓冲区为1M. 一次收到了500K的数据; 如果立刻应答, 返回的窗口就减少500K; 但实际上可能处理端处理的速度很快, 10ms之内就把500K数据从缓冲区消费掉了 在这种情况下, 接收端处理还远没有达到自己的极限, 即使窗口再放大一些（把这500k加上）, 也能处理过来 因此如果接收端稍微等一会再应答, 比如等待200ms再应答, 那么这个时候返回的窗口大小就是1M，显然吞吐量加大了，这就是延迟应答; 窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率; 延迟应答的具体方式有两种: 数量限制: 每隔N个包就应答一次(如上图),一般N = 2; 时间限制: 超过最大延迟时间就应答一次，一般T= 200ms，注意，这个延迟时间应远小于超时重传时间，不然就帮倒忙了; 捎带应答在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一个发送数据，一个确认收到” 的. 意味着接收方需要发送确认收到的报文给发送方; 可是往往接收方也需要回复数据给确认方，那么就可以回复ACK顺便捎带上数据了。 通过抓包工具，可以发现四次挥手怎么只有三次？原因是确认方收到断开信息以后，自己也要断开，就把2，3次挥手用捎带应答优化了！ TCP异常处理 进程终止: 进程终止会释放文件描述符,此时TCP连接还在,仍然可以发送FIN. 和正常关闭没有什么区别. 机器重启: 和进程终止的情况相同; 机器掉电/网线断开: 接收端认为连接还在, 一旦接收端有写入操作, 接收端发现连接已经不在了, 就会进行reset. 即使没有写入操作, TCP自己也内置了一个保活定时器, 会定期询问对方是否还在. 如果对方不在, 也会把连接释放.另外, 应用层的某些协议, 也有一些这样的检测机制. 例如HTTP长连接中, 也会定期检测对方的状态. 例如QQ, 在QQ断线之后, 也会定期尝试重新连接. 此外,TCP在面对异常情况可能会发送RST包（重新建立连接请求）。发送RST包的情况通常有：1、端口未打开；2、请求超时；3、提前关闭；4、在一个已关闭的socket上收到数据 面向字节流特性由于读/写缓冲区的存在，TCP程序的读和写操作不需要一一匹配: 写100个字节数据时, 可以调用一次write写100个字节, 也可以调用100次write, 每次写一个字节; 读100个字节数据时, 也完全不需要考虑写的时候是怎么写的, 既可以一次read 100个字节, 也可以一次read一个字节, 重复100次。 TCP如果发送的字节数太长, 会被拆分成多个TCP的数据包发出; 如果发送的字节数太短, 就会先在缓冲区里等待, 等到缓冲区长度差不多了, 或者其他合适的时机发送出 去; 而UDP只有接收缓冲区,是面向数据包的，固定的发送与读取！ 粘包问题粘包问题中的 “包” , 是指的应用层的数据包，不是分离报头和有效载荷的报; 站在传输层的角度, TCP是一个一个报文过来的. 按照报头里的序号排好序放在缓冲区中，而站在应用层的角度, 看到的只是一串连续的字节数据，那么应用程序看到了这么一连串的字节数据, 就不知道从哪个部分开始到哪个部分, 是一个完整的应用层数据包——不会分割 解决方法:明确两个包之间的边界 对于定长的包,保证每次都按固定大小读取即可;eg:没内容的HTTP请求报文Request，就直接按sizeof(Request)单位大小读取; 对于变长的包,发送方可以在包头的位置, 添加约定一个包总长度的字段length,从而就知道了包的结束位置;接收方就有能力根据单位length分开不同的包了;//TCP 对于变长的包, 还可以在包和包之间使用明确的分隔符(应用层协议, 是程序猿自己来定的, 只要保证分隔 符不和正文冲突即可) eg：HTTP的报头与body正文的分隔符空行/n这种规定的方式，在包与包之间加特殊分隔符; UDP不需要考虑粘包： UDP报头本身就存在数据包长度，按照那个大小就能有效读取; 面向数据报，要么收到完整的UDP报文, 要么不收;不会出现”不完整的半个”的情况. 第二种：UDP协议英文名：User Datagram Protocol 中文名：数据报协议 协议说明：UDP是一种面向无连接的传输层通信协议。 举例：发短信，不需要双方建立连接，But，数据报的大小应限制在64k以内 特点：效率高，数据传输不安全，容易丢包 无连接: 知道对端的IP和端口号就直接进行传输, 不需要建立连接; 不可靠: 没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层 返回任何错误信息; 面向数据报: 不能够灵活的控制读写数据的次数和数量; TCP与UDP对比我们既然说了TCP是可靠连接，那么是不是TCP就一定优于UDP呢？这个问题已经老生常谈了。TCP和UDP的优缺点不能简单、绝对的进行比较。 TCP用于可靠传输的情况，应用于文件传输，重要状态更新等场景，其也有一系列提高效率的机制保证效率。 UDP用于对高速传输和实时性要求较高的通信领域，比如早期的qq，视频传输等。另外UDP可以用于广播。 UDP实现可靠传输;（经典面试题）//回答tcp可靠性的的核心方法 引入确认应答, 确保对端收到了数据; 引入超时重传, 如果隔一段时间没有应答, 就重发数据; 引入序列号, 保证数据顺序; 四、三要素关系图与网络模型图1、网络编程三要素关系图 2、OSI参考模型与TCP/IP参考模型","link":"/2025/01/07/TCPUDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"title":"modern C++","text":"modern C++ 新特性 1. C++11 委托构造函数 允许一个构造函数调用同一个类中的另一个构造函数来初始化对象。 123456789class MyClass {public: MyClass(int param1, int param2) { // 构造函数的具体实现 } MyClass(int param) : MyClass(param, 0) { // 委托给另一个构造函数完成初始化 }}; 不能同时使用委托构造函数和成员初始化列表： 1MyClass(int param) : MyClass(param, 0), param_(param) { // 错误：不能同时使用委托构造函数和成员初始化列表 可以形成一个链，叫委托链，一层一层调用，但是不能互相调用，形成调用闭环： 123456789MyClass(int param1, int param2, int param3) : param1_(param1), param2_(param2), param3_(param3) { // A：构造函数 } MyClass(int param1, int param2) : MyClass(param1, param2, 0) { // B：委托构造函数，调用A } MyClass(int param1) : MyClass(param1, 0) { // C: 委托构造函数，调用B } 使用场景： 减少代码重复，避免在多个构造函数之间重复相同的初始化代码 修改类的初始化逻辑时，只需要在一个地方进行修改，避免重复 如果类之前有多个构造函数，委托构造函数可以简化这些构造函数的实现，尤其是重复的初始化步骤 2. C++11 类内初始化 以前如果要对结构体或者类成员变量进行初始化——使用初始化列表或者构造函数 1234567struct Data{ int i; float f; bool b; Data():i(0),f(0),b(true){}}; C++11后，类成员变量的初始化可以直接赋值，类似普通变量初始化，定义的时候直接初始化 12345struct Data{ int i = 1; float f = 2.0; bool b = true;}; 3. 空指针nullptr 传统C++中，使用大写NULL的宏 代表空指针 1#define NULL 0 C++在编译时有一些类型检查，可以避免一些错误，但是宏是预编译的，在编译之前进行的是简单地语句替换，编译器就不能进行类型检查，可能会出错： 比如我们可以给int和float赋给NULL，这时候如果我们重载两个同名函数，调用的时候编译器不知道具体调用哪个函数，因为宏定义的语句替换后，int和float是0，是合法的。 所以在C++11后，对任何空指针都推荐使用nullptr表示，此时如果将nullptr赋给int，编译器会报错 4. 枚举类 enum class 对旧枚举类的增强 123456enum Number { One, Two, Three};// 旧的enum class Number { One, Two, Three};// 新的int main(){ Number num = Number::One;// 枚举类的使用 return 0;} 能避免命名冲突：定义两个枚举类，里面具有相同名字的值都是可以的 5. C++11 类型推导 auto 比如对一个vector的遍历，for循环中需要定义一个很长数据类型的迭代器，此时可以用auto，让编译器自己推导： 12for(auto it = numbers.cbegin(); it != numbers.cend(); ++it) // auto 可以代替vector&lt;int&gt;::const_iterator 而且可以推导任意类型变量——不推荐，可读性差： 123auto a = 1;auto b = 1.5f;auto c = a + b; auto还可以作为函数的返回值： 12345678910auto add(T x, U y){return x + y};// C++ 14提供的新特性auto add2(T x, U y) -&gt; decltype(x + y){return x + y};// C++ 11的老特性/*decltype 是 C++11 引入的一个关键字，用于获取表达式的类型。decltype(expression)返回expression的类型，而不是表达式的值，一般这么用：int a = 10;decltype(a) b = a; 其中，b的类型是int，由decltype返回的*/ 6. C++11 常量表达式 constexpr 任何表达式都行 甚至是递归函数 将 运行时 的计算 提前到 编译时来做性能优化 比如，有一个计算幂次方的函数： 123456constexpr int pow(int x, int y){};// 在开头加上constexpr，表示这个表达式会在编译时被计算// 这时候，在需要计算常量的场景可以使用int a[pow(2,4)] = {};// 数组的数量是一个常量，如果传入一个变量，则会报错，但是加了constexpr，表达式会在编译时被计算// 相当于编译器将这里计算成16int a[16] = {}； 7. C++11 初始化列表 所有标准库中的容器都可以使用类似于数组初始化的语法来初始化，而不需要用多次push_back： 12345std::vector&lt;int&gt; v = {1,2,3};std::set&lt;int&gt; s = {1,2,3};std::list&lt;int&gt; l = {1,2,3};// 也支持嵌套vector&lt;set&lt;int&gt;&gt; v = {{1,2}, {3,4,5}}; 8. 基于范围的for循环 对于任何标准库容器，可以使用类似java的语法来遍历其中的元素： 123456789vector&lt;int&gt; nums = {1,2,3};for(int x: nums){ cout &lt;&lt; x &lt;&lt; endl;}// 在C++ 17以后，可以同时配合结构化绑定(Structured Bindings)将map的遍历写成如下：map&lt;int, string&gt; numMap = {{1, &quot;one&quot;}, {2, &quot;two&quot;}, {3, &quot;three&quot;}};for( auto [key, val] : numMap){ cout &lt;&lt; key &lt;&lt; &quot;-&gt;&quot; &lt;&lt; val &lt;&lt; endl;} 比老式写法（迭代器）简洁非常多 9. C++11 智能指针 unique ptr 用于自动管理动态分配的资源，如堆上的内存，核心作用是确保动态分配的对象在离开作用域时能够自动释放内存，从而避免内存泄露等问题。在程序逻辑复杂的时候十分好用。 有唯一性：不会有两个智能指针同时指向同一个对象 12345678910111213141516#include &lt;memory&gt;struct SomeData{ int a,b,c;}void f(){ // 在堆上申请一块内存 new SomeData* data = new SomeData;// 传统写法 std::unique_ptr&lt;SomeDate&gt; data(new SomeData);// 智能指针写法 new // 用std::make_unique来创建智能指针更安全，避免重复的new表达式和野指针（构造函数出现异常） auto data = make_unique&lt;SomeData&gt;();// 传入SomeData的构造函数 // 可以用熟悉的语法访问这个智能指针指向的对象 data-&gt;a = 1; data-&gt;b = 2; data-&gt;c = 3; // 不需要用delete来释放内存，当程序离开智能指针的作用域时，对象的内存就会自动释放} 不适合需要指针在不同函数间传递的场景 不适合需要多个指针指向同一个对象的智能指针 不要使用unique_ptr，而是shared_ptr。 10. C++11 Lambda 表达式 本质上是一个匿名函数（对象），可以用很简洁的语法快速定义一个临时的匿名函数。 1234567891011#include &lt;algorithm&gt;// algorithm中定义了很多算法，如排序sorting、搜索searching、排列permutation、翻转reversing等等vector&lt;int&gt; nums = {1,2,3,4,5};auto it = find_if(nums.begin(), nums.end(), [](int x){return x % 2 == 0;});//使用find_if寻找偶数，第三个参数使用lambda表达式/*[](){};是lambda的语法，本质是个函数对象[]用于变量的捕获，()里是函数参数，{}里是函数体变量的捕获意思是将lambda表达式外部的变量复制到内部，并且只在内部生效，可以在内部修改而不影响外部变量*/ lambda表达式可以让函数更简洁，尤其是在有回调函数的地方。 11. 右值引用 在C++中，左右值不能通过位置进行判断，可以说能够取到地址的就是左值，此时可以简单理解为： 左值一般是指：一个指向特定内存，具有名称的值，生命周期长，也叫具名对象。右值则反之。 左值引用和右值引用 123456789101112131415161718192021// 关于常量左值引用int &amp;x1 = 7; // 编译错误const int &amp;x = 11;// 编译成功，常见于拷贝构造函数// 右值引用基本语法int &amp;&amp;k = 11;// 意义在于能够延长右值的生命周期，优化性能X make_x(){ X x1; return x1; /* 没有进行右值引用时会有3次构造： 1. make_x函数中x1会默认构造一次 2. return x1会复制构造产生临时对象 3. X x2 = make_x()会使用复制构造将临时对象复制到x2，然后临时对象被销毁 现在的编译器会进行优化，避免多次复制构造 */}int main(){ X &amp;&amp;x2 = make_x();// make_x()返回一个右值，但是使用了右值引用，引用了这个右值 x2.show();// 此时x2引用了一个右值，将返回的这个右值x1的生命周期延长了，使其可以调用show()} 可以发现，使用了右值引用后，复制构造次数会减少，这也就是右值引用的终极目标：减少对象复制，提升程序性能，而不仅仅是延长右值（临时对象）的生命周期。 C++的指针为什么危险？ 指针是一个很灵活的工具，可以对内存直接操作，所以可能导致程序崩溃、内存泄露、数据损坏等问题： 野指针 可能会有产生指向未知内存地址的指针，通常是没有正确初始化或错误修改导致的 悬挂指针 意思是指向已经被释放的内存的指针，危险在于被释放后被使用会导致一些问题 内存泄漏 我们用动态分配出的内存，让指针指向这块内存，但是如果没有正确释放的话可能会导致内存泄漏 多次释放 对动态分配的内存多次释放，导致程序崩溃 指针越界 指访问数组或内存块之外的内存，导致程序崩溃或数据损坏 指针类型不匹配 指针赋值的时候类型转换错误，可能导致错误的内存访问 错误的使用指针 比如空指针和未初始化的指针","link":"/2025/01/05/modern%20C++%20%E6%96%B0%E7%89%B9%E6%80%A7/"},{"title":"通讯协议总结","text":"通讯协议总结 原贴：https://blog.csdn.net/weixin_45726161/article/details/146225631 1. 串口通信 简介：成本低、容易使用、线路简单，可实现两个设备的互相通信。 原理：简单双向串口通信 有两根通信线（发送端TX和接收端RX），TX和RX交叉连接，只需单项数据传输时可只接一根通信线。 电平标准：不同设备可能使用不同电平标准，电平不匹配时需要电平转换芯片进行适配。 电平标准 电压范围 常用设备 TTL电平 +3.3V 或 +5V 表示 1, 0V表示 0 单片机和嵌入式设备 RS-232电平 -3V-15V 表示 1，+3V+15V 表示 0 传统 PC 串口通信 RS-485电平 两线压差 +2V+6V 表示 1，-2V-6V 表示 0 采用差分信号，抗干扰强，适用工业总线 不同电平标准的设备通信时，可使用 MAX232（TTL ↔ RS232） 或 MAX485（TTL ↔ RS485） 等电平转换芯片。 串口参数及时序： 波特率：串口通信的速率（发送和接收约定好速率），决定每隔多久发送一位（或者每秒传输的bit位数），单位为bps（bits per second，位/秒）。例如9600 bps：每秒传输 9600 个 bit，或者传输一个bit需要1/9600s。 起始位：标志一个数据帧的开始，固定为低电平；因为空闲状态是低电平。 数据位：数据帧的有效载荷，1为高电平，0为低电平，低位先行，左边为低位。 校验位：用于数据验证，根据数据位计算得来；校验位为0或1，具体校验位的值根据奇校验还是偶校验得出（奇校验：保证数据位1的个数为奇数；偶校验：保证数据位1的个数是偶数） 停止位：用于数据帧间隔，固定为高电平，为下一帧的起始位低电平准备 2. UART(USART) UART（通用异步收发传输） 和 USART（通用同步/异步收发传输） 是串口通信的一种实现方式，其基本原理与串口通信一致。 其中UART 是一种常见的串行通信方式，广泛应用于RS-232、RS-422、RS-485 及 TTL 电平通信。 RS-232 采用点对点通信模式，仅支持两个设备直接连接，适用于短距离、本地设备间的全双工通信。 RS-485 支持多设备总线通信，具备较长的传输距离和较强的抗干扰能力，但通常采用半双工通信模式。 3. I2C 简介：串行数据总线，一根是双向的数据线SDA,一根是时钟线SCL。两条线可以挂多个设备，一般IIC设备里有个固化的地址，只有传输对应固化地址时才会响应。基本谁控制时钟线谁就是主设备。 I2C优缺点： ​ 优点：硬件资源节约，协议设计精巧，易用，使用广泛易移植。 ​ 缺点：传输速率较慢。原理：两根通信线：时钟线SCL（Serial Clock）、数据线SDA（Serial Data），工作模式为同步（双方有时钟线SCL），半双工，带数据应答，支持总线挂载多设备（一主多从、多主多从），数据位一般7位或10位。 所有I2C设备的时钟线SCL连在一起，SDA连在一起设备的SCL和SDA均要配置成开漏输出模式；SCL和SDA各添加一个上拉电阻，阻值一般为4.7KΩ左右。从设备下拉，总线处于低电平；从设备放开，从设备相当于浮空，但由于上拉电阻作用，总线处于高电平。只要有一个从设备下拉，总线就处于低电平。 时序： 初始化：SCL SDA均为高。 开始信号：SCL保持高电平，SDA由高变低，SCL拉低。 停止信号：SCL拉高，SDA由低变高。 （1）主机发送一个字节——SCL低电平发数据 SCL高电平读数据 SCL低电平期间，主机将数据位依次放到SDA线上（高位先行），然后释放SCL，从机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可发送一个字节。SCL低电平的时候发送一方通过拉低或者释放SDA发送0或者1，SCL释放处于高电平的时候SDA不允许有数据变化。 （2）主机接收一个字节——主机在接收前要释放SDA给从机，从机获得发送权 SCL低电平期间，从机将数据位依次放到SDA线上（高位先行），然后释放SCL，主机将在SCL高电平期间读取数据位，所以SCL高电平期间SDA不允许有数据变化，依次循环上述过程8次，即可接收一个字节（主机在接收之前，需要释放SDA，意思就是让从机获得发送权）。 （3）发送应答——接收后发送应答数据 主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答 （4）接收应答——发送后接收应答数据 主机在发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA，释放相当于放手SDA处于高电平，要不然SDA时钟被主机拉着处于低电平，从机没办法发送0和1） （5）指定地址写 对于指定设备（Slave Address），在指定地址（Reg Address）下，写入指定数据（Data） （6）当前地址读 对于指定设备（Slave Address），在当前地址指针（具体哪个寄存器）指示的地址下，读取从机数据（Data） （7）指定地址读 对于指定设备（Slave Address），在指定地址（Reg Address）下，读取从机数据（Data）；写两次，写设备地址和寄存器地址（与当前地址读的区别就是多写一次寄存器的地址） 4. SPI 简介：SPI（Serial Peripheral Interface）是由Motorola公司开发的一种通用数据总线。四根通信线：SCK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、SS（Slave Select）从机选择，是一种同步（有时钟线SCK，相当于I2C的SCL），全双工（主机发送和接收各占一条线）的协议， 支持总线挂载多设备（一主多从，不支持多主机）。 优缺点： ​ · 支持全双工操作，操作简单，数据传输速率较高（相比于I2C的优点，I2C的传输速率慢）； ​ · 需要占用主机较多的口线，只支持单个主机，没有应答机制确认是否接收到数据（相比于I2C的缺点）。 原理： 所有SPI设备的SCK、MOSI、MISO分别连在一起，主机另外引出多条SS控制线，分别接到各从机的SS引脚，输出引脚配置为推挽输出，输入引脚配置为浮空或上拉输入。推挽输出驱动能力强，SCK上升沿和下降沿都迅速，不像I2C上升沿慢。 不同于I2C发送寻址地址寻找从机，SPI通过从机选择线SS来寻找具体哪个从机SS线低电平有效。 移位示意图——循环式数据互换 SPI的主机和从机之间的数据传输就是一个数据移位的过程（主机把自身数据移给从机，同时从机把数据移给主机，在同一个时钟信号SCK的控制下）。高位先行，左移波特率发生器即SCK的上升沿，所有移位寄存器向左移动一位，把两边寄存器的最高位放在MISO和MOSI的数据线上； 下降沿的时候，主机和从机都会进行数据的采样输入，被发送的bit到达目的地； 这样八个时序之后，主机和从机的数据互换，实现了彼此的数据交换。 (1)时序： 起始条件：SS从高电平切换到低电平。终止条件：SS从低电平切换到高电平。SS为低电平有效，通信过程中要时钟保持为低电平。 (2)时钟极性与时钟相位 时钟极性（CPOL）：表示 SPI 在空闲时, 时钟信号是高电平还是低电平。若CPOL =1, 设备在空闲时 SCK时钟信号为高电平.。CPOL=0, SCK为低电平。 时钟相位（CPHA）：表示SPI在采样数据时是在SCK第一个边沿还是第二个边沿，第一个边沿CPHA=0,第二个边沿CPHA=1.如何判断：SCK的空闲时候的电压，是0还是1，决定了CPOL是0还是1，数据采样时刻对应着的SCK的电平，是第一个边沿还是第二个边沿，对应着CPHA为0还是1。 (3)交换一个字节（模式0）： 模式0的时候：CPOL=0：空闲状态时，SCK为低电平 CPHA=0：SCK第一个边沿移入数据（上升沿移入数据），第二个边沿移出数据（下降沿移出数据）。 模式0是最常用的，S起始位的时候，下降的同时移出数据MOSI写入，SCK上升沿移入数据，SCK下降沿移出数据。 MISO最开始的横线代表为高阻态，在一个从机被选中的时候为了避免别的从机的干扰，置为高阻态即为没有输入。 (4)发送指令 向SS指定的设备，发送指令（0x06），这里使用模式0，空闲时候SCK=0，上升沿采样读取数据，下降沿移除数据发送。 从机没有数据发送给主机，所以这里全是1挂起。 (5)指定地址写 向SS指定的设备，发送写指令（0x02），随后在指定地址（Address[23:0]）下，写入指定数据（Data） (6)指定地址读 向SS指定的设备，发送读指令（0x03） 随后在指定地址（Address[23:0]）下，读取从机数据（Data） 5 DDS DDS（Data Distribution Service）是一种实时发布-订阅（Pub-Sub）通信协议，用于分布式系统中的高效、低延迟数据交换。它支持数据自动发现、动态扩展、QoS（服务质量）管理，无需服务器中转，设备间可直接通信（明显区分于MQTT）。DDS 适用于工业自动化、航空航天、汽车电子、机器人等需要高可靠性和实时性的场景。 以下是DDS协议中的一些概念： （1）Domain：代表一个通信平面，由Domain ID唯一标识，只有在同一个域内的通信实体才可以通信；如果考虑车内通信，可以只划分1个Domain，也可以按照交互规则或其他规则，定义多个Domain； （2）Domain Participant：代表域内通信的应用程序的本地成员身份，简单来说，就是说明同一数据域内的通信成员； （3）Topic：是数据的抽象概念，由TopicName标识，关联相应数据的数据类型(DataType)，如果把车内所涉及的所有Topic集合在一起，这样就形成一个虚拟的全局数据空间“Global Data Space”，进一步弱化了节点的概念，所以域参与者已经不是节点的概念了； （4）DataWriter：数据写入者，类似缓存，把需要发布的主题数据从应用层写入到DataWriter中； （5）DataReader：数据读取者，同样可以理解为一种缓存，从订阅者得到主题数据，随之传给应用层； （6）Publisher：发布者，发布主题数据，至少与1个DataWriter关联，通过调用DataWriter的相关函数将数据发出去； （7）Subscriber：订阅者，订阅主题数据，至少与1个DataReader关联。当数据到达时，应用程序可能忙于执行其他操作或应用程序只是等待该消息时，这样就会存在两种情况，同步访问和异步通知。 根据前面介绍，我们清楚了DDS是一个以数据为中心的中间件协议和API标准，意为用户只关心自己想要的数据，数据通过Topic进行标识，这样发布者根据主题发布数据，订阅者根据自己感兴趣的主题订阅数据。","link":"/2025/01/09/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"},{"title":"进程调度","text":"进程调度 目的：在进程间切换CPU，最大化CPU的利用率，提高计算机的效率。 1. 基本概念1.1 CPU-I/O执行周期进程的属性：进程执行包括周期地进行CPU执行和I/O等待。据此可以将程序分为CPU密集型程序和I/O密集型程序。 CPU密集型程序一般只有少量长CPU执行；I/O密集型程序一般具有大量短CPU执行。 1.2 CPU调度程序（CPU scheduler）CPU空闲时，操作系统从就绪队列中选择一个进程来执行，进程选择采用短期调度程序（short-term scheduler）或CPU调度程序。 调度程序分为：短期调度程序，中期调度程序和长期调度程序。 短期调度程序：从准备执行的进程中选择进程，并分配CPU，这里准备执行的进程理解为内存中就绪的进程。 长期调度程序：从外部大容量存储设备（通常为磁盘）的缓冲池中选择进程，加载到内存。 中期调度程序：将进程从内存（或从CPU竞争）中移出，从而降低多道程序程度（内存中的进程数量）。被调出的进程可被重新调入内存，并从中断处继续运行，这种方案称为交换（swap）。通过中期调度程序，进程可换入（swap in）和换出（swap out）。 1.3 进程状态模型其中七状态模型包含的情况比较全面，除了进程的创建、就绪、运行、等待、终止这五个状态，考虑在执行虚拟内存管理的操作系统中，可以将暂时不用的进程（处于就绪态和等待态的进程）换出（swap out）到外部存储设备（如硬盘）中，在适当的时间再将其换入（swap in）到内存中，此时引入了就绪挂起和等待挂起状态。 1.4 抢占调度需要CPU调度的4种情况： 当一个进程从运行状态切换到等待状态（例如I/O请求，或wait()调用） 当一个进程从运行状态切换到就绪状态（例如当出现中断） 当一个进程从等待状态切换到就绪状态（例如I/O完成） 当一个进程终止。 调度方案分为两种：（1）非抢占的（nonpreemptive）或协作的（cooperative）；（2）抢占的（preemptive）。非抢占调度下，一旦某个进程分配到CPU，该进程会一直使用CPU，直到它终止或切换到等待状态。抢占调度允许第二个进程抢占第一个进程的运行，这中间可能涉及进程共享数据的一致性问题，进程同步问题。 1.5 调度程序（dispatcher）这个调度程序在英文原书中称为“dispatcher”，与上面说的CPU调度程序（CPU scheduler）不同，CPU scheduler负责进程的选择（调度），而dispatcher负责将CPU控制交给由CPU schedule（即短期调度程序）选择的进程，CPU scheduler负责进程选择，dispatcher实现调度过程的进程切换细节，个人感觉二者属于上下游关系。 dispatcher的主要功能如下： 切换上下文； 切换到用户模式； 跳转到用户程序的合适位置，以便重新启动程序； 调度程序停止一个程序而启动另一个程序所需的时间称为调度延迟（dispatch latency）。 1.6 调度准则为了比较不同的CPU调度算法，采用一些比较准则来评价CPU调度算法的特性，具体的一些比较准则包括： CPU使用率； 吞吐量（throughput）：一个时间单元内进程完成的数量； 周转时间（turnaround time）：进程从提交到进程完成的时间段； 等待时间：进程在就绪队列种因等待所需的时间； 响应时间：进程从提交请求到产生第一响应的时间。 进程调度的理想情况是：最大化CPU使用率和吞吐量，最小化周转时间、等待时间和响应时间。 2. 调度算法2.1 先到先服务（FCFS）先到先服务（First-Come First-Served，FCFS）调度算法。通过FIFO队列实现，当一个进程进入就绪队列中的时候，它的PCB会被链接到队列尾部；当CPU空闲时，它会分配给位于队列头部的进程，并且这个进程从队列中移去。 特点： 平均等待时间往往很长； 非抢占，可能导致一个进程占用CPU时间过长； 会存在多个I/O进程在就绪队列中等待CPU密集型进程的完成（其他进程都等待一个大进程释放CPU），称为护航效果（convoy effect），导致CPU和设备的使用率降低。 2.2 最短作业优先调度（SJF）最短作业优先（Shortest-Job-First，SJF）调度算法。将每个进程与其下次CPU执行长度关联起来，CPU空闲时会被赋给具有最短CPU执行时间（注意是下次CPU执行的时间最短而不是总的时间最短）的进程执行。另一种叫法是：最短下次CPU执行（shortest-next-CPU-burst）算法。 特点： SJF算法可以证明是最优的，对于给定的一组进程，SJF算法的平均等待时间最短。 SJF算法困难在于如何确定下次CPU执行的长度。下次CPU执行通常预测为以前CPU执行的测量长度的指数平均（exponential average）。 SJF算法可以是抢占或非抢占的。 2.3 优先级调度优先级调度（priority-scheduling）算法为每个进程关联一个优先级，具有最高优先级的进程会分到CPU；具有相同优先级的进程按照FCFS的顺序调度。SJF算法是一个简单的优先级算法，其优先级（p）为下次（预测的）CPU执行时间的导数。 特点： 优先级算法可以是抢占的或非抢占的； 主要问题是会导致无穷阻塞（indefinite blocking）或饥饿（starvation）； 解决低优先级进程的无穷等待的方案之一：老化（aging），即逐渐增加在系统中等待时间很长的进程的优先级。 2.4 轮转调度（RR）轮转（Round-Robin，RR）调度算法，类似FCFS调度，但是增加了抢占以切换进程。将一个较小的时间单元定义为时间量（time quantum）或时间片（time slice），将就绪队列作为循环队列，CPU调度整个就绪队列，为每个进程分配不超过一个是时间片的CPU。 特点： RR算法的性能很大程度上取决于时间片的大小：时间片太小，频繁的进程上下文切换耗费大量资源；时间片太大，RR退化成FCFS。一般根据经验，80％的CPU执行应小于时间片。 2.5 多级队列调度多级队列（multilevel queue）调度算法，将就绪队列分成多个单独的队列，根据进程属性（如内存大小、进程优先级、进程类型等），一个进程永久分到一个队列，每个队列有自己的调度算法。例如可有两个队列分别用于前台进程和后台进程，前台队列可采用RR算法调度，后台队列采用FCFS算法调度。 多级队列调度算法实例，有五个队列，优先级由高到低，分别为：（1）系统进程；（2）交互进程；（3）交互编辑进程；（4）批处理进程；（5）学生进程。其中每个队列与更低层队列相比具有绝对的优先，例如只有系统进程、交互进程和交互编辑进程队列都为空，批处理队列内的进程才能运行。如果一个批处理进程运行过程中有一个交互进程进入就绪队列，那么该批处理进程会被抢占。 另一种可能是，在队列之间划分时间片，每个队列具有一定比例的CPU时间，可用于调度队列内的进程。例如对于前台-后台队列例子，前台队列可有80％的CPU时间，用于进程之间的RR调度；后台队列可以有20％的CPU时间，用于按FCFS算法来调度进程。 2.6 多级反馈队列调度多级反馈队列调度（multilevel feedback queue）调度算法允许进程在队列之间迁移，其特点在于： 如果进程使用过多的CPU时间，其将会被放到更低的优先级队列； I/O密集型和交互进程放在更高优先级队列上； 在较低优先级队列中等待过长的进程会被移到更高优先级队列，以阻止饥饿的发生。 多级反馈队列调度程序可由下列参数定义： 队列数量； 每个队列的调度算法； 用以确定何时升级到最高优先级队列的方法； 用以确定何时降级到最低优先级队列的方法； 用以确定进程在需要服务时将会进入那个队列的方法。 3 线程调度线程可以分为用户级（user-level）线程和内核级（kernel-level）线程。在支持线程的操作系统上，内核级线程（而不是进程）才是操作系统所调度的。这里理解为上述的进程调度算法，其实就CPU而言，并不严格区分该算法究竟是用于调度进程还是用于调度线程，而是用于调度基本的调度单元，在支持线程的操作系统上，线程才是CPU调度的基本单元，此时上述调度算法此时用于线程调度。 关于用户级线程和内核级线程：用户级线程是由线程库管理的，内核并不知道。用户级线程最后运行在CPU上，映射到相应的内核级线程，这种映射不是直接的，可能采用轻量级进程（Light Weight Process，LWP），因此内核级线程和用户级线程的调度具体实现仍有所区别。 进程竞争范围（Process-Contention Scope，PCS）：对于实现多对一和多对多模型的系统线程库会调用用户级线程，以便在可用LWP上运行。线程调度到可用LWP上并不意味着线程真实运行在一个CPU上，而是需要系统调度内核线程到物理CPU） 系统竞争范围（System-Contention Scope）：为了决定哪个内核线程调度到同一个处理器上，内核采用SCS竞争CPU。采用一对一模型的系统如Windows、Linux和Solaris只采用SCS调度","link":"/2025/01/07/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"},{"title":"进程间通信","text":"进程间通信 一、进程间通信介绍 进程间通信概念​ 进程间通信（Inter-Process Communication, IPC）是指在不同进程之间传递或交换信息的一种机制。在操作系统中，进程是资源分配和独立运行的基本单位，它们拥有各自独立的内存空间和系统资源。因此，进程间不能直接访问对方的内存空间，需要通过特定的通信机制来实现数据交换和同步操作。 是什么—— 两个或多个进程实现数据层面的交互。因为进程独立性的存在，导致进程通信的成本比较高。 为什么—— 发送基本数据、发送指令、多进程协同等需求 怎么办—— 进程间通信的本质：必须让不同的进程看到同一份“资源”，这里的资源就是指以特定形式存在的内存空间。 资源由谁来提供？一般是操作系统。为什么不是我们两个进程中的一个呢？假设一个进程提供，这个资源就属于该进程所有，因为进程具有独立性！破坏进程独立性，这是操作系统不允许的，所以需要第三方提供空间，所以操作系统就是和事佬。 我们进程访问空间，进行进程间通信，本质就是访问操作系统，而进程代表的是用户，用户不能直接访问操作系统内核数据，所以操作系统提供了系统调用接口，所以是从操作系统底层设计，从接口设计，一个独立的通信模块IPC —— 隶属文件系统。当进程通信变多，显而易见，操作系统需要将他们管理起来，先描述再组织。 进程间通信目的 数据传输：一个进程需要将它的数据发送给另一个进程 资源共享：多个进程之间共享同样的资源。 通知事件：一个进程需要向另一个或一组进程发送消息，通知它（它们）发生了某种事件（如进程终止时要通知父进程）。 进程控制：有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变。 进程间通信的本质 必须让不同的进程看到同一份“资源”，这里的资源就是指以特定形式存在的内存空间。 因此，进程间通信的本质就是，让不同的进程看到同一份资源（内存，文件内核缓冲等）。 由于这份资源可以由操作系统中的不同模块提供，因此出现了不同的进程间通信方式。 4. 进程间通信发展 管道 System V 进程间通信 POSIX 进程间通信 进程间通信分类 管道（文件缓冲区）1. 匿名管道pipe2. 命名管道 System V IPC System V 消息队列 System V 共享内存 （内存块） System V 信号量 POSIX IPC 消息队列 共享内存 信号量 互斥量 条件变量 读写锁 二、管道​ 管道（Pipes）是一种基本的进程间通信（IPC）机制，用于连接一个进程的输出到另一个进程的输入。管道允许数据以字节流的形式从一个进程传递到另一个进程。它是单向的，即数据只能从一个方向流动。管道分为匿名管道和命名管道（也称为FIFO，即First In First Out）。 ​ 原理：基于文件的一种通信方式 匿名管道 ​ 匿名管道是最早出现的UNIX IPC机制之一，它只能用于具有亲缘关系的进程之间（通常是父子进程或兄弟进程）。当一个进程创建了一个管道后，它会得到两个文件描述符：一个用于写（通常称为管道的写端），另一个用于读（通常称为管道的读端）。进程可以将数据写入管道的写端，然后另一个进程可以从管道的读端读取数据。由于管道是基于文件描述符的，因此当所有指向管道的文件描述符都被关闭后，管道中的数据就会被丢弃，管道本身也会被销毁。 管道是一种简单但强大的IPC机制，它适用于需要数据流的场景，如父子进程之间的数据传递。然而，由于其单向性和有限的容量，管道可能不适合所有类型的IPC需求。在这种情况下，可以考虑使用其他IPC机制，如消息队列、共享内存或套接字等。 例如，统计我们当前使用云服务器上的登录用户个数 1who | wc -l who命令和wc命令都是两个程序，当它们运行起来后就变成了两个进程，who进程通过标准输出将数据打到“管道”当中，wc进程再通过标准输入从“管道”当中读取数据，至此便完成了数据的传输，进而完成数据的进一步加工处理。( who命令用于查看当前云服务器的登录用户（一行显示一个用户），wc -l用于统计当前的行数) 由管道（“|”）连接起来的各个进程是有亲缘关系的，它们之间互为兄弟进程，是匿名管道。 1.1 匿名管道原理重温一下进程结构体： 进程创建时，创建 task_struct 结构体，结构体内有指针指向 files_struct 结构体，该结构体内有一个struct file* 数组，即文件描述符表，指向被该进程打开的 struct file 文件（默认打开stdin、stdout、stderr，对应键盘和显示器文件）。如果进程又打开一个文件（操作系统创建的内存级文件），那么为就为该文件分配一个最小的没有被使用的fd，在fd下标的文件描述符数组的元素填写指向该文件的struct file的struct file*，并且 struct file 结构体还指向了 inode 属性集结构体（有大部分inode的属性）、file_opeartors函数方法集（对硬件的操作函数的函数指针结构体）、文件页缓冲区。对于文件页缓冲区来说，无论读写，都将磁盘数据加载到文件页缓冲区（相当于缓冲，提高效率），如果是写就会修改缓冲区数据，该数据为脏，所以就会被操作系统刷新到磁盘， 管道虽然用的是文件的方案，但操作系统一定不会把进程进行通信的数据刷新到磁盘当中，因为这样做有IO参与会降低效率，而且也没有必要。也就是说，这种文件是一批不会把数据写到磁盘当中的文件，换句话说，磁盘文件和内存文件不一定是一一对应的，有些文件只会在内存当中存在，而不会在磁盘当中存在。 进程打开文件后再 fork，会拷贝 files_struct 吗？ 会拷贝files_struct ，但是不会拷贝struct file，对于 struct file 直接引用计数即可(图画错了，两个进程的3号fd应该指向相同的struct file)。 所以父子进程会看到同一个新建的文件 —— 内存级文件，这就实现了不同的进程，看到同一份资源！父进程可以向文件页缓冲区写入数据，子进程就可以在文件页缓冲区读取数据！这就实现了进程间通信。所以管道就是文件！是一种内存级别文件，不在磁盘。 内存级文件：不在磁盘，操作系统在内存直接创建一个struct file。 管道是一个内存级别文件，由os直接创建一个文件结构体用于进程间读写，不会加载到磁盘。 这里父子进程看到的同一份文件资源是由操作系统来维护的，所以当父子进程对该文件进行写入操作时，该文件缓冲区当中的数据并不会进行写时拷贝。 1234内存级文件（管道文件）有路径、文件名、inode吗？由于匿名管道不直接对应于文件系统中的任何实体，因此它没有自己的inode号。并且根本就不需要名字，因为子进程看到父进程是靠继承拷贝来看到的。匿名管道的文件描述符仅用于在创建它的进程及其子进程或通过其他IPC机制（如消息队列、共享内存等）与之通信的进程之间进行数据传递。 命名管道：有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作。匿名管道：没有明确的路径、文件名和inode号，仅存在于内存中，通过进程间的文件描述符进行通信。 123当进程依靠管道文件通信时，一方关闭文件，另一方会受影响而出现错误吗？如果父进程只是以读方式打开管道文件，那么子进程拷贝父进程进程的一系列结构体，导致子进程也只能以读方式读管道文件，父子都只能读管道文件，这就会引发矛盾。所以，父进程打开文件是有要求的，需要以读和写分别打开管道文件！ 虽然读写在技术角度可以，但是读写不建议混起来，因为读写都是由各自的变量控制的，如果混在一起我们刚写的数据是读不出来的。所以，一般都是读打开一次、写打开一次，但是除了创建一个struct file，其他的都是共享（inode结构体、文件缓冲区） 所以操作系统规定，一个进程不能同时读写，因为如果同时读写，不能确定哪些数据是自己的哪些是其他进程写的，这就很繁琐，操作系统使用文件系统来实现就是为了简单一些，否则就会再设计一个复杂的系统来实现，所以操作系统就规定进程之间只能进行单向通信！ 所以一个进程在读时，就关闭自己的写文件，另一个进程在写时，就关闭自己的读文件，从而实现单向通信。 管道进行读写时，一般都是关闭各自的另一个写读文件，比如A读就关闭A的写文件，B写就关闭B的读文件，实现单向通信，而且只能互斥地读写，每次每个管道只能有一端被一个进程访问。 匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。 12为什么非要搞管道，我父进程写一个全局数据，子进程继承，这不就是传递消息吗？首先，进程的通信内容大部分为动态的消息，即消息是即时性的传递，而不是静态的数据，其次父进程的全局数据只是单方面的传递，子进程只能读数据，不能写数据，一旦写数据就会触发写时拷贝。 写时拷贝/写时复制：一种资源管理优化策略 核心思想是延迟数据的实际复制操作，直到数据被修改时才进行复制。具体来说，如果有多个调用者同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。 fork()系统调用创建子进程时会使用写时拷贝。子进程和父进程共享内存空间，只有在某个进程对内存进行写操作时，才会复制相应的内存页面。 优点：减少不必要的数据复制，节省内存和存储空间。提高系统性能，避免数据共享时的多个复制开销。 缺点：需要额外的机制来管理；某些情况会多次触发写时拷贝，导致内存中有多份数据副本。 12345678如果进程不是父子关系，那么还能通过管道通信吗？不可以，必须是父子关系。管道原理就是父子进程共享管道文件。如果父进程创建多个子进程，那么这些子进程可以通过管道通信吗？可以，因为全都继承的父进程，所以都指向同一个内存文件——管道文件（文件页缓冲区）。 如果父进程创建的子进程，子进程又创建了子进程，那么爷孙进程可以通过管道通信吗？可以，因为也都是拷贝的同一份files_struct，都指向同一个内存文件——管道文件。 小结：匿名管道通信，进程之间需要又血缘关系，常见于父子关系。匿名管道通常只能用于具有亲缘关系的进程之间（如父子进程、兄弟进程）。这是因为非亲缘关系的进程无法直接访问对方的内存空间，也无法通过文件描述符/句柄继承来访问对方的管道。 1.2 pipe系统调用1man 2 pipe 1int pipe(int pipefd[2]); 该函数参数是一种输出型参数，pipe内部将struct file、文件缓冲区等结构创建好，以读写方式打开内存文件（匿名管道），然后返回两个文件描述符fd ，靠数组带回，数组只需两个元素，默认： pipefd[0] ：读下标 pipefd[1] ：写下标 返回值：pipe函数调用成功时返回0，调用失败时返回-1 举例： pipefd有两个元素，用于存储管道的读写端； pipefd传入pipe，将pipefd[0]设为当前文件句柄3，将pipefd[1]设为当前文件句柄4； 然后返回一个数用于反馈，成功为0，并且pipefd中会包含两个有效的文件描述符；失败为-1，并且会设置errno以指示错误原因。 1.3 匿名管道的使用 在创建匿名管道实现父子进程间通信的过程中，需要pipe函数和fork函数搭配使用。 1、父进程调用pipe函数创建管道 2、父进程创建子进程 3、父进程关闭写端，子进程关闭读端（当然，父进程也可以关闭读端） 匿名管道是单向的，即数据只能从一个方向流动。一个管道有一个读端和一个写端，数据从写端进入管道，从读端被读取。 父子进程的通信靠操作系统的系统调用接口write、read，因为操作系统不相信用户，不可能让用户自己指定一块内存区域，让用户随便访问，这是不允许的。 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//child-&gt;write, father-&gt;read#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;int main(){ int fd[2] = { 0 }; if (pipe(fd) &lt; 0){ //使用pipe创建匿名管道 perror(&quot;pipe&quot;); return 1; } pid_t id = fork(); //使用fork创建子进程 if (id == 0){ //child close(fd[0]); //子进程关闭读端 //子进程向管道写入数据 const char* msg = &quot;hello father, I am child...&quot;; int count = 10; while (count--){ write(fd[1], msg, strlen(msg)); sleep(1); } close(fd[1]); //子进程写入完毕，关闭文件 exit(0); } //father close(fd[1]); //父进程关闭写端 //父进程从管道读取数据 char buff[64]; while (1){ ssize_t s = read(fd[0], buff, sizeof(buff)); if (s &gt; 0){ buff[s] = '\\0'; printf(&quot;child send to father:%s\\n&quot;, buff); } else if (s == 0){ printf(&quot;read file end\\n&quot;); break; } else{ printf(&quot;read error\\n&quot;); break; } } close(fd[0]); //父进程读取完毕，关闭文件 waitpid(id, NULL, 0); return 0;} 管道内部自带同步与互斥机制 多执行流共享时，可能会出现访问冲突问题。即一个进程正在访问数据时，另一个进程写入数据，这就可能覆盖原数据——临界资源竞争问题 临界资源是需要被保护的，若是我们不对管道这种临界资源进行任何保护机制，那么就可能出现同一时刻有多个进程对同一管道进行操作的情况，进而导致同时读写、交叉读写以及读取到的数据不一致等问题。 为了避免这些问题，内核会对管道操作进行同步与互斥： ​ 同步： 两个或两个以上的进程在运行过程中协同步调，按预定的先后次序运行。比如，A任务的运行依赖于B任务产生的数据。​ 互斥： 一个公共资源同一时刻只能被一个进程使用，多个进程不能同时使用公共资源。实际上，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。对于管道的场景来说，互斥就是两个进程不可以同时对管道进行操作，它们会相互排斥，必须等一个进程操作完毕，另一个才能操作，而同步也是指这两个不能同时对管道进行操作，但这两个进程必须要按照某种次序来对管道进行操作。 也就是说，互斥具有唯一性和排它性，但互斥并不限制任务的运行顺序，而同步的任务之间则有明确的顺序关系。 1.4 管道通信的特征​ 亲缘性：具有血缘关系的进程才能通过管道通信​ 单向性：管道是单向的，数据只能从一个方向流动​ 通信进程之间会协同（互斥、同步），这是为了保护管道文件的数据安全。如果父进程读数据时，缓冲区直接拿来就读会导致乱码，因为缓冲区不是每时每刻都为空，子进程也不是时时刻刻写入缓冲区，所以进程间需要协同！一方没有写入，另一方就不读写。​ 基于字节流：管道是面向字节流的，管道中的数据以字节流的形式传递，没有消息边界的概念（不管一个进程写了多少字符、写了几次，另一个进程读取时一次全部读完。就像是自来水，来自写端的自来水不分边界，不管写端放了多少自来水，读端都是一个读完，不管读端是拿盆还是拿桶来接）对于进程A写入管道当中的数据，进程B每次从管道读取的数据的多少是任意的，这种被称为流式服务。​ 生命周期：匿名管道的生命周期随进程结束而结束；命名管道的生命周期则取决于文件系统，除非显式删除，否则会一直存在。管道是基于文件的，文件的生命周期是跟随进程的。父子进程退出时，管道文件自动被操作系统释放，例如默认打开的stdin、stdout、stderr都是操作系统关闭的管道是有固定大小的 ，在不同内核里大小有差别 1ulimit -a 使用 ulimit 指令查看对很多重要资源的限制，进程可打开最大文件数、管道大小等等 centos7.6版本默认给管道大小是64KB。当写入的字节小于PIPE_BUF时，写入的必须是原子（单次写入大小），这里的pipe size 就可以看 作 PIPE_BUF 当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。 1.5 管道读写的4种情况 读写端正常，管道如果为空，读端就要阻塞，直到管道内出现数据 读写端正常，管道如果被写满，写端就要阻塞，直到管道内数据被读端读取 读端正常读，写端关闭，读端就会读到0，表明读到了文件（pipe）结尾，不会被阻塞 写端正常写，读端关闭，操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程（操作系统不会做低效、浪费内存等类似的工作，如果做了，那么就是操作系统的bug） 操作系统通过13号信号SIGPIPE杀死还在向管道写入的进程 其中前面两种情况就能够很好的说明，管道是自带同步与互斥机制的，读端进程和写端进程是有一个步调协调的过程的，不会说当管道没有数据了读端还在读取，而当管道已经满了写端还在写入。读端进程读取数据的条件是管道里面有数据，写端进程写入数据的条件是管道当中还有空间，若是条件不满足，则相应的进程就会被挂起，直到条件满足后才会被再次唤醒。 第三种情况也很好理解，读端进程已经将管道当中的所有数据都读取出来了，而且此后也不会有写端再进行写入了，那么此时读端进程也就可以执行该进程的其他逻辑了，而不会被挂起。第四种情况也不难理解，既然管道当中的数据已经没有进程会读取了，那么写端进程的写入将没有意义，因此操作系统直接将写端进程杀掉。而此时子进程代码都还没跑完就被终止了，属于异常退出，那么子进程必然收到了某种信号。 1.6 实践操作：shell管道 hpp文件：c++的头文件。直接将.h和.cpp文件混在一起，之前 .h 和 .cpp 分开编译是因为为了打包成库，如果本身就奔着开源，那么大部分就是直接使用hpp后缀 进程池 由于每次fork一个子进程效率并不高，我们可以在空闲时让父进程fork出一些子进程，组成一个进程池，当有需要时指定进程池中任意一个进程分配任务，这样的效率就提高了。 命名管道（FIFO） 命名管道克服了匿名管道只能用于亲缘关系进程间通信的限制，它允许无亲缘关系的进程间通信。命名管道在文件系统中有一个名字，任何进程都可以通过这个名字来访问管道。 命名管道和匿名管道一样，都是内存文件，只不过命名管道在磁盘有一个简单的映像，但这个映像的大小永远为0，因为命名管道和匿名管道都不会将通信数据刷新到磁盘当中 匿名管道是通过子进程继承父进程实现的看到同一份资源，而命名管道是通过 路径+文件名 确定同一份资源，该文件只存一份数据，即一份inode、一份文件缓冲区、一份操作方法集。 2.1 mkfifo1man mkfifo 命令行创建命名管道 1mkfifo myfifo 可以看到，创建出来的文件的类型是**p，代表该文件是命名管道文件** 举例：我们打开两个终端，一个终端持续向命名管道追加写入字符串，另一个终端cat命名管道，两个终端靠命名管道实现echo进程与cat进程的通信 echo 指令并不在左边终端打印，而是从命名管道myfifo传到右边终端的cat进程，并且在打印过程中命名管道大小不变（因为命名管道不会将通信数据刷新到磁盘当中） 123进程间通信的前提，是先让不同的进程看到同一份资源。那么为什么两个进程不直接读同一个磁盘上的文件？进行交流信息的进程只想用文件缓冲区来交流，只需要一个进程把数据放到缓冲区，另一个进程去拿就够了，如果是磁盘文件，它就需要刷盘，这是一个冗余的行为！管道文件不需要刷到磁盘，是一个内存级文件，所以即使追加写到命名管道，它的属性inode也不会改变，因为不会刷到磁盘 123不同的进程怎么知道打开的是同一个文件？匿名管道是通过继承，而命名管道：路径+文件名我们在基础IO学过，路径+文件名具有唯一性，因为路径确定了分区，同一目录下文件名不能重复，因为文件名需要和inode一一映射，再者找到文件后发现是p属性，进程就知道要找到文件就是它了，所以这种方式就是命名管道通信方式 命名管道与匿名管道几乎完全相同，不同的一点就是命名管道可以让毫不相干、没有血缘关系的进程进行通信 系统调用创建命名管道： 1man 3 mkfifo 12345678910111213int mkfifo(const char *pathname, mode_t mode);mkfifo函数的第一个参数是pathname，表示要创建的命名管道文件。· 若pathname以路径的方式给出，则将命名管道文件创建在pathname路径下。· 若pathname以文件名的方式给出，则将命名管道文件默认创建在当前路径下。（注意当前路径的含义）mkfifo函数的第二个参数是mode，表示创建命名管道文件的默认权限。例如，将mode设置为0666，则命名管道文件创建出来的权限：prw-rw-rw- 具体权限会受到umask掩码的影响（0002） umask掩码是控制文件和目录默认权限的mkfifo函数的返回值。· 命名管道创建成功，返回0· 命名管道创建失败，返回-1 命名管道的打开规则 1、如果当前打开操作是为读而打开FIFO时。 O_NONBLOCK disable：阻塞直到有相应进程为写而打开该FIFO。O_NONBLOCK enable：立刻返回成功。2、如果当前打开操作是为写而打开FIFO时。 O_NONBLOCK disable：阻塞直到有相应进程为读而打开该FIFO。O_NONBLOCK enable：立刻返回失败，错误码为ENXIO。 2.2 unlinkunlink——删除命名管道 1man 3 unlink 2.3 实践通信comm.hpp 封装命名管道的创建与销毁功能 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#pragma once #include &quot;log.hpp&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cerrno&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt; #define FIFO_FILE &quot;./myfifo&quot; //命名管道的文件名#define MODE 0664 //管道默认创建权限 //enum错误类型，假定为进程退出码enum{ FIFO_CREAT_ERR = 1, FIFO_DELETE_ERR, FIFO_OPEN_ERR}; //对创建和销毁命名管道做封装class Init{public: Init() { //创建命名管道，mkfifo int n = mkfifo(FIFO_FILE, MODE); if (n == -1) { perror(&quot;mkfifo&quot;); exit(FIFO_CREAT_ERR); } } ~Init() { //销毁命名管道，unlink int m = unlink(FIFO_FILE); if (m == -1) { perror(&quot;unlink&quot;); exit(FIFO_DELETE_ERR); } } private: Log log; //日志}; server.cc 服务端创建命名管道，打开管道读取数据（此时客户端未进程启动，所以会在open处阻塞） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;comm.hpp&quot;#include &quot;log.hpp&quot;using namespace std; // 让服务端管理命名管道文件int main(){ Init init; Log log; // 先设置日志为单文件输出 log.Enable(Classfile); // 打开管道 int fd = open(FIFO_FILE, O_RDONLY); if (fd &lt; 0) { log(Fatal, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); exit(FIFO_OPEN_ERR); } log(Warning, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); log(Error, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); log(Info, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); // 让服务端作为读端 while (true) { char buffer[1024] = {0}; int x = read(fd, buffer, sizeof(buffer)); if (x &gt; 0) { buffer[x] = 0; // 读取后在末尾处加\\0，构成C语言字符串 cout &lt;&lt; &quot;client say# &quot; &lt;&lt; buffer &lt;&lt; endl; } else if (x == 0) { log(Debug, &quot;client quit, me too! error string: %s, error code: %d&quot;, strerror(errno), errno); break; } else break; } // break出来表示写端读端都关闭了，所以关闭管道文件 close(fd); return 0;} cilent.cc 打开管道文件，从键盘读取数据，再向文件内write数据 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &quot;comm.hpp&quot;using namespace std; int main(){ int fd = open(FIFO_FILE, O_WRONLY); if (fd &lt; 0) { perror(&quot;open&quot;); exit(FIFO_OPEN_ERR); } cout &lt;&lt; &quot;client open file done&quot; &lt;&lt; endl; string line; while (true) { cout &lt;&lt; &quot;Please Enter@ &quot;; getline(cin, line); write(fd, line.c_str(), line.size()); } close(fd); return 0;} 123456789101112131415161718192021在大多数现代操作系统和编程语言中，当一个进程被Ctrl+C（SIGINT信号）直接关闭时，程序会接收到一个中断信号，这通常会导致程序立即终止执行。对于C++等需要显式资源管理的语言来说，这意味着如果程序在没有适当处理该信号的情况下被终止，那么程序中的对象可能不会按预期调用它们的析构函数。析构函数的调用通常发生在以下几种情况：作用域结束：对于局部变量，当它们的作用域结束时（例如，函数返回或块结束），它们的析构函数会被自动调用。delete操作符：对于通过new操作符动态分配的对象，当使用delete操作符释放这些对象时，它们的析构函数会被调用。程序正常结束：当程序正常结束（例如，通过return语句从main函数返回）时，全局对象和静态局部对象的析构函数会按照与它们被创建时相反的顺序被调用。然而，当程序接收到SIGINT信号（如Ctrl+C）并直接终止时，这些规则并不适用。程序会立即停止执行，而不会执行任何清理操作（如调用析构函数）。这可能导致资源泄漏，比如未关闭的文件描述符、未释放的内存等。要处理这种情况，你可以：使用信号处理：在C++中，你可以使用信号处理函数（如signal或sigaction在UNIX/Linux系统中）来捕获SIGINT信号，并执行一些清理工作。但请注意，从信号处理函数中直接调用非异步信号安全的函数（包括大多数C++库函数）是不安全的。使用RAII（Resource Acquisition Is Initialization）：尽量使用RAII技术来管理资源。RAII是一种在对象构造时获取资源并在对象析构时释放资源的编程技术。这样，即使程序因为接收到SIGINT信号而异常终止，如果对象的析构函数有机会被调用（这通常很难保证），那么资源也能被正确释放。然而，如前所述，当程序因为信号而终止时，析构函数可能不会被调用。优雅地关闭程序：在程序的关键位置添加检查点，以检测用户是否请求了中断（例如，通过捕获SIGINT信号），并在检测到中断时执行必要的清理工作，然后正常退出程序。综上所述，当程序被Ctrl+C直接关闭时，程序中的对象可能不会按预期调用它们的析构函数，这可能导致资源泄漏等问题。因此，在编写需要处理中断信号的程序时，应该采取适当的措施来确保资源被正确管理。 先关闭客户端（写端），服务端（读端）就会因为写端关闭而读到0，然后break，init对象的生命周期随程序结束，才会调用它的析构函数，unlink命名管道。 如果直接ctrl c掉服务端，那么进程直接退出，不会调用析构函数，这就会导致内存泄露 多文件编译Makefile 1234567891011.PHONY:allall:client server client:client.cc g++ -o $@ $^ -std=c++11server:server.cc g++ -o $@ $^ -std=c++11 .PHONY:cleanclean: rm -f client server 命名管道和匿名管道的区别 命名管道有明确的路径、文件名和inode号，可以通过文件系统的接口进行访问和操作。 匿名管道没有明确的路径、文件名和inode号，仅存在于内存中，通过进程间的文件描述符进行通信匿名管道由pipe函数创建并打开。 命名管道由mkfifo函数创建，由open函数打开。 FIFO（命名管道）与pipe（匿名管道）之间唯一的区别在于它们创建与打开的方式不同，一旦这些工作完成之后，它们具有相同的语义。 四、system V管道通信本质是基于文件的，也就是说操作系统并没有为此做过多的设计工作，而system V IPC是操作系统特地设计的一种通信方式。但是不管怎么样，它们的本质都是一样的，都是在想尽办法让不同的进程看到同一份由操作系统提供的资源。 system V IPC提供的通信方式有以下三种： system V共享内存：允许两个或多个进程共享一段内存区域，是进程间通信中最快的方式，因为数据不需要在进程间复制。 system V消息队列：允许一个或多个进程写入或读取消息，可以看作是一个消息链表，每个消息都有一个类型和一个优先级 system V信号量：用于同步进程，控制多个进程对共享资源的访问。System V信号量分为二进制信号量和计数信号量。 其中，system V共享内存和system V消息队列是以传送数据为目的的，而system V信号量是为了保证进程间的同步与互斥而设计的，虽然system V信号量和通信好像没有直接关系，但属于通信范畴 1. 共享内存1.1 共享内存原理类似动态库加载，操作系统在物理内存创建一块区域，通过页表映射到需要通信的进程的虚拟地址空间的共享区中，并向应用层返回一个起始的虚拟地址，使得虚拟地址和物理地址之间建立起对应关系，从而使不同的进程看到同一份资源，这块物理内存就是共享内存。 可以概括为：申请内存、挂接到进程地址空间、返回首地址。并且不能由进程自己malloc内存，因为进程是独立的，需要操作系统创建内存空间，创建信道，才可以实现不同进程通信。所以需求方进程要求执行方操作系统完成任务的过程就是系统调用。 1.2 共享内存数据结构当进程之间的共享内存多了之后，操作系统就需要描述并组织起来大量的共享内存！所以对共享内存的增删查改就变成了对组织的数据结构的增删查改，所以共享内存除了在内存当中真正开辟空间之外，系统一定还要为共享内存维护相关的内核数据结构。 共享内存的数据结构： 12345678910111213struct shmid_ds { struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) */ __kernel_time_t shm_atime; /* last attach time */ __kernel_time_t shm_dtime; /* last detach time */ __kernel_time_t shm_ctime; /* last change time */ __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no. of current attaches */ unsigned short shm_unused; /* compatibility */ void *shm_unused2; /* ditto - used by DIPC */ void *shm_unused3; /* unused */}; 当我们申请了一块共享内存后，为了让要实现通信的进程能够看到同一个共享内存，因此每一个共享内存被申请时都有一个key值，这个key值用于标识系统中共享内存的唯一性。 可以看到上面共享内存数据结构的第一个成员是shm_perm，shm_perm是一个ipc_perm类型的结构体变量，每个共享内存的key值存储在shm_perm这个结构体变量当中，其中ipc_perm结构体的定义如下： 123456789struct ipc_perm{ __kernel_key_t key; __kernel_uid_t uid; __kernel_gid_t gid; __kernel_uid_t cuid; __kernel_gid_t cgid; __kernel_mode_t mode; unsigned short seq;}; 1.3 共享内存的建立与释放1234567共享内存的建立大致包括以下两个过程：1. 在物理内存当中申请共享内存空间。2. 将申请到的共享内存挂接到地址空间，即建立映射关系。共享内存的释放大致包括以下两个过程：1. 将共享内存与地址空间去关联，即取消映射关系。2. 释放共享内存空间，即将物理内存归还给系统。 1.4 共享内存的创建创建共享内存我们需要用shmget函数，shmget函数的函数原型如下： shmget 1man 2 shmget 1234shmget函数的参数说明：· 第一个参数key，表示待创建共享内存在系统当中的唯一标识。· 第二个参数size，表示待创建共享内存的大小。· 第三个参数shmflg，表示创建共享内存的方式。 shmflg：创建共享内存的操作只需要一次，剩下的进程只需要获取就好了，所以需要有一个参数来标识 123IPC_CREAT：如果申请的共享内存不存在，就创建；存在，就获取并返回。（这些都是宏，标记位，每个bit都不相同）IPC_CREAT | IPC_EXCL：如果申请的共享内存不存在，就创建；存在，就出错返回原有的共享内存。解释：第二个搭配确保了，如果我们申请成功了一个共享内存，这个共享内存一定是一个新的！并且 IPC_EXCL不单独使用 12345shmget函数的返回值说明：· shmget调用成功，返回一个有效的共享内存标识符（用户层标识符），类似文件句柄，我们使用后续接口时都要通过这个句柄对指定的共享内存进行操作。· shmget调用失败，返回-1。在进程内，shimid 用来标识资源的唯一性，shmid并不像fd那样是0，1，2的小的数组下标，shmid数值很大，但是他也是一个数组下标，在它内部还有一套算法。shmid搞特殊，因为Linux中一切皆文件，那么共享内存也可以被看作文件，那么我们也应该使用fd就可以访问，这是因为当初shmid 标准没有制定好。 1注意：我们把具有标定某种资源能力的东西叫做句柄，而这里shmget函数的返回值实际上就是共享内存的句柄，这个句柄可以在用户层标识共享内存，当共享内存被创建后，我们在后续使用共享内存的相关接口时，都是需要通过这个句柄对指定共享内存进行各种操作 12我们怎么保证让不同的进程看到同一个共享内存？怎么知道这个共享内存是是否存在呢？通过相同的参数调用ftok函数，获取相同的Key值 传入shmget函数的第一个参数key，需要我们使用ftok函数进行获取 1234key_t ftok(const char *pathname, int proj_id);ftok函数的作用就是，将一个已存在的路径名pathname和一个整数标识符proj_id转换成一个key值，称为IPC键值，在使用shmget函数获取共享内存时，这个key值会被填充进维护共享内存的数据结构当中。需要注意的是，pathname所指定的文件必须存在且可存取。ftok是一套算法，用路径名和项目id进行数值计算，获得冲突概率极低的数字 。 123456为什么要让用户自己指定key，而不是操作系统自动生成？操作系统完全有能力创建很多的不冲突的key，但是操作系统创建的key只能由一个进程拿到，又因为进程的独立性，其他的想要和该进程通信的进程（没有血缘关系）拿不到该数据，又需要通信传递key，这就矛盾了，所以让用户（程序员）约定一个key，根据ftok使用通向的路径名和项目id，即使通信双方看不到彼此，也能获取相同的key，这样才可以看到同一个共享内存注意：使用ftok函数生成key值可能会产生冲突，此时可以对传入ftok函数的参数进行修改。需要进行通信的各个进程，在使用ftok函数获取key值时，都需要采用同样的路径名和和整数标识符，进而生成同一种key值，然后才能找到同一个共享资源。 至此我们就可以使用ftok和shmget函数创建一块共享内存了，创建后我们可以将共享内存的key值和句柄进行打印，以便观察，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Log log;// 共享内存的大小一般建议是4096的整数倍// 4097,实际上操作系统给你的是4096*2的大小const int size = 4096; const string pathname=&quot;/home/ljs&quot;;const int proj_id = 0x666; //进程调用的GetKey函数相同，代表着它们拿到的Key一定相同key_t GetKey(){ //获取key key_t k = ftok(pathname.c_str(), proj_id); if(k &lt; 0) { log(Fatal, &quot;ftok error: %s&quot;, strerror(errno)); exit(1); } log(Info, &quot;ftok success, key is : 0x%x&quot;, k); return k;} //创建共享内存int GetShareMemHelper(int flag){ //调用GetKey获取key key_t k = GetKey(); //创建 int shmid = shmget(k, size, flag); if(shmid &lt; 0) { log(Fatal, &quot;create share memory error: %s&quot;, strerror(errno)); exit(2); } log(Info, &quot;create share memory success, shmid: %d&quot;, shmid); return shmid;} int CreateShm(){ return GetShareMemHelper(IPC_CREAT | IPC_EXCL | 0666);} int GetShm(){ return GetShareMemHelper(IPC_CREAT); } 共享内存权限在flag参数处追加 在Linux中，查看系统内IPC的指令 1ipcs 单独使用 ipcs命令时，会默认列出消息队列、共享内存以及信号量相关的信息，若只想查看它们之间某一个的相关信息，可以选择携带以下选项： -q：列出消息队列相关信息。 -m：列出共享内存相关信息。 -s：列出信号量相关信息。 ipcs命令输出的每列信息的含义如下： key 系统区别各个共享内存的唯一标识 shmid 共享内存的用户层id（句柄） owner 共享内存的拥有者 perms 共享内存的权限 bytes 共享内存的大小 nattch 关联共享内存的进程数 status 共享内存的状态 注意： key是在内核层面上保证共享内存唯一性的方式，而shmid是在用户层面上保证共享内存的唯一性，key和shmid之间的关系类似于fd和FILE*之间的的关系。 共享内存挂接 共享内存创建后，开始调用系统调用shmat进行挂接 123456void *shmat(int shmid, const void *shmaddr, int shmflg);shmat函数的参数说明：· 第一个参数shmid：表示待关联共享内存的用户级标识符。应用层都是以shmid为准· 第二个参数shmaddr：指定共享内存映射到进程地址空间的某一地址，通常设置为NULL，表示让内核自己决定一个合适的地址位置。最终的挂接位置会被返回· 第三个参数shmflg：表示关联共享内存时设置的某些属性。挂接时按什么权限，在创建共享内存时的权限就可以了，不用再修改，所以可以从传0 其中，作为shmat函数的第三个参数传入的常用的选项有以下三个： 选项 作用 SHM_RDONLY 关联共享内存后只进行读取操作 SHM_RND 若shmaddr不为NULL，则关联地址自动向下调整为SHMLBA的整数倍。公式：shmaddr-(shmaddr%SHMLBA) 0 默认为读写权限 shmat函数的返回值说明： shmat调用成功，返回共享内存映射到进程地址空间中的起始地址。 shmat调用失败，返回(void*)-1。 1234567//由processa来管理共享内存的创建和销毁int main(){ int shmid = CreateShm(); //创建共享内存 char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接共享内存 //通信...} 1.5 共享内存去关联取消共享内存与进程地址空间之间的关联我们需要用shmdt函数，shmdt函数的函数原型如下： 1int shmdt(const void *shmaddr); 去掉共享内存的关联，如果直接进程退出，那么进程会释放它的进程虚拟地址空间，和页表映射的物理内存，所以此时共享内存的引用计数–，ipcs -m 就可以查看到 nattck （挂接数）减1 shmdt函数的参数说明： 待去关联共享内存的起始地址，即调用shmat函数时得到的起始地址。 shmdt函数的返回值说明： shmdt调用成功，返回0。 shmdt调用失败，返回-1。 12只给它起始地址，shmdt它是怎么知道我们申请的共享内存有多大呢？因为需要知道具体大小才能在页表消除映射，并使共享内存引用计数-- 这个问题就如同malloc申请内存、free只需要起始地址，这两个概念是完全相同的，因为操作系统有结构体维护申请的空间，例如malloc，如果你申请100字节，那么实际上操作系统会在进程地址空间的堆区申请120字节，多出来的就是维护申请空间信息的变量 举例： 12345678//由processa来管理共享内存的创建和销毁int main(){ int shmid = CreateShm(); //创建共享内存 char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接共享内存 //通信... shmdt(shmaddr); //取消关联} 注意： 将共享内存段与当前进程脱离不等于删除共享内存，只是取消了当前进程与该共享内存之间的联系。 1.6 共享内存的释放通过上面创建共享内存的实验可以发现，当我们的进程运行完毕后，申请的共享内存依旧存在，并没有被操作系统释放。即进程退出，共享内存没有被释放！ 这表明共享内存的生命周期是跟随内核的（匿名管道是生命周期是随进程的，命名管道生命周期独立于进程，需要显示的unlink），用户不主动关闭，共享内存会一直存在，除非内核重启或用户释放。如果我们忘记释放共享内存，那么这就算内存泄漏；如果我们没有忘记，那么这就不算内存泄漏 例如两个进程通信完毕后走了，操作系统把共享内存释放了，过了一段时间，这两个进程又回来继续通信，此时发现共享内存没有了，而里面可能还有它们上一次通信的内容，此时操作系统就算是惹祸了 此时我们若是要将创建的共享内存释放，有两个方法，一就是使用命令释放共享内存，二就是在进程通信完毕后调用释放共享内存的系统调用函数进行释放。 命令释放共享内存 在shell中使用命令释放共享内存 ipcrm 1ipcrm -m 共享内存shmid 注意： 指定删除时使用的是共享内存的用户层id，即列表当中的shmid。用户层统一使用shmid，命令行输入也是用户层。 系统调用释放共享内存 在程序中，释放共享内存我们需要用shmctl函数，控制共享内存，我们用它来删除共享内存。shmctl函数的函数原型如下： 123456789int shmctl(int shmid, int cmd, struct shmid_ds *buf);shmctl函数的参数说明：· 第一个参数shmid，表示所控制共享内存的用户级标识符。· 第二个参数cmd，表示具体的控制动作。· 第三个参数buf，用于获取或设置所控制共享内存的数据结构。shmctl函数的返回值说明：· shmctl调用成功，返回0。· shmctl调用失败，返回-1 其中，作为shmctl函数的第二个参数传入的常用的选项有以下三个： 选项 作用 IPC_STAT 获取共享内存的当前关联值，此时参数buf作为输出型参数 IPC_SET 在进程有足够权限的前提下，将共享内存的当前关联值设置为buf所指的数据结构中的值 IPC_RMID 删除共享内存段 我们目前使用该函数时，不需要获取值，所以在第三个参数处传nullptr即可（我们是C/C++混编，所以使用了nullptr） 12345678910111213//由processa来管理共享内存的创建和销毁int main(){ int shmid = CreateShm(); //创建共享内存 char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接共享内存 //通信... shmdt(shmaddr); //取消关联 shmctl(shmid, IPC_RMID, nullptr); //删除共享内存 return 0;} 1.7 实践通信 我们讲了这么多全都是预备工作，创建、挂接、去关联、释放共享内存。那么预备工作完成后，双方如何进行通信？ 很简单，此时共享内存已经被映射到各进程的地址空间中，已经属于进程（进程：这就是我创建的空间，我随便用），使用方法与平时我们 malloc 的空间使用方法完全相同！直接访问、写入即可 为了让服务端和客户端在使用ftok函数获取key值时，能够得到同一种key值，那么服务端和客户端传入ftok函数的路径名和和整数标识符必须相同，这样才能生成同一种key值，进而找到同一个共享资源进行挂接。这里我们可以将这些需要共用的信息放入一个头文件当中，服务端和客户端共用这个头文件即可。 我们依旧使用日志类来管理程序。共享内存流程：创建、挂接、去关联、释放 comm.hpp 该文件用来定义+实现共享内存的创建和获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#ifndef __COMM_HPP__#define __COMM_HPP__ #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &quot;log.hpp&quot;using namespace std; Log log; // 共享内存的大小一般建议是4096的整数倍// 4097,实际上操作系统给你的是4096*2的大小const int size = 4096; const string pathname=&quot;/home/ljs&quot;;const int proj_id = 0x666; //进程调用的GetKey函数相同，代表着它们拿到的Key一定相同key_t GetKey(){ //获取key key_t k = ftok(pathname.c_str(), proj_id); if(k &lt; 0) { log(Fatal, &quot;ftok error: %s&quot;, strerror(errno)); exit(1); } log(Info, &quot;ftok success, key is : 0x%x&quot;, k); return k;} //创建共享内存int GetShareMemHelper(int flag){ //调用GetKey获取key key_t k = GetKey(); //创建 int shmid = shmget(k, size, flag); if(shmid &lt; 0) { log(Fatal, &quot;create share memory error: %s&quot;, strerror(errno)); exit(2); } log(Info, &quot;create share memory success, shmid: %d&quot;, shmid); return shmid;} int CreateShm(){ return GetShareMemHelper(IPC_CREAT | IPC_EXCL | 0666);} int GetShm(){ return GetShareMemHelper(IPC_CREAT); } #endif 服务端processa.cc ​ 读取共享内存的信息 1234567891011121314151617181920212223#include &quot;comm.hpp&quot; extern Log log; //由processa来管理共享内存的创建和销毁int main(){ int shmid = CreateShm(); //创建共享内存 char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接共享内存 while(true) { cout &lt;&lt; &quot;client say@ &quot; &lt;&lt; shmaddr &lt;&lt; endl; //直接访问共享内存 sleep(1); } //注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除 //如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用 shmdt(shmaddr); //取消关联 shmctl(shmid, IPC_RMID, nullptr); //删除共享内存 return 0;} 客户端processb.cc ​ 向共享内存写入 123456789101112131415161718#include &quot;comm.hpp&quot; //processb直接使用即可，共享内存的创建和销毁由processa全权负责int main(){ int shmid = GetShm(); char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接 while(true) { cout &lt;&lt; &quot;Please Enter@ &quot;; fgets(shmaddr, 4096, stdin); } shmdt(shmaddr); //去掉共享内存关联 return 0;} 根据结果来看，共享内存有几个特性： 共享内存没有同步互斥之类的保护机制，跟管道不同，共享内存的读端进程不会等待写端进程就绪，会一直读空字符串。所以我们可以将共享内存和管道结合，当共享内存创建后，两者再使用管道，那么读端就必须等待写端写入数据，否则阻塞，这就实现了同步！ 当共享内存创建好后就不再需要调用系统接口进行通信了，共享内存是所有的进程间通信中，速度是最快的，因为拷贝少！不需要read、write等系统接口进行通信。一旦有了共享内存，挂接到自己的地址空间中，那么直接使用起始地址进程操作即可，就如同操作自己malloc的空间，而管道创建好后仍需要read、write等系统接口进行通信。 共享内存内部的数据由用户自己维护 我们来算算管道通信拷贝次数： 使用管道通信的方式，将一个文件从一个进程传输到另一个进程需要进行四次拷贝操作： 服务端将信息从输入文件复制到服务端的临时缓冲区中。 将服务端临时缓冲区的信息复制到管道中。 客户端将信息从管道复制到客户端的缓冲区中。 将客户端临时缓冲区的信息复制到输出文件中。 注意：服务端和客户端的退出顺序 ，将共享内存和命名管道结合 与命名管道的服务端和客户端相同，只有先关闭客户端（写端），读端才会读到0，然后break，再执行后序的shmctl，shmctl是真的能删除共享内存，不用手动的使用 ipcrm -m 删除共享内存 如果直接ctrl c掉读端，进程会直接退出，不会执行后面的代码 每一个共享内存都有自己的数据结构，里面就有相应的key值 共享内存+命名管道代码 comm.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#ifndef __COMM_HPP__#define __COMM_HPP__ #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt; #include &quot;log.hpp&quot; using namespace std; #define FIFO_FILE &quot;./myfifo&quot;#define MODE 0664 enum{ FIFO_CREATE_ERR = 1, FIFO_DELETE_ERR, FIFO_OPEN_ERR}; class Init{public: Init() { // 创建管道 int n = mkfifo(FIFO_FILE, MODE); if (n == -1) { perror(&quot;mkfifo&quot;); exit(FIFO_CREATE_ERR); } } ~Init() { //销毁管道 int m = unlink(FIFO_FILE); if (m == -1) { perror(&quot;unlink&quot;); exit(FIFO_DELETE_ERR); } }}; Log log;// 共享内存的大小一般建议是4096的整数倍// 4097,实际上操作系统给你的是4096*2的大小const int size = 4096; const string pathname=&quot;/home/ljs&quot;;const int proj_id = 0x666; //进程调用的GetKey函数相同，代表着它们拿到的Key一定相同key_t GetKey(){ //获取key key_t k = ftok(pathname.c_str(), proj_id); if(k &lt; 0) { log(Fatal, &quot;ftok error: %s&quot;, strerror(errno)); exit(1); } log(Info, &quot;ftok success, key is : 0x%x&quot;, k); return k;} //创建共享内存int GetShareMemHelper(int flag){ //调用GetKey获取key key_t k = GetKey(); //创建 int shmid = shmget(k, size, flag); if(shmid &lt; 0) { log(Fatal, &quot;create share memory error: %s&quot;, strerror(errno)); exit(2); } log(Info, &quot;create share memory success, shmid: %d&quot;, shmid); return shmid;} int CreateShm(){ return GetShareMemHelper(IPC_CREAT | IPC_EXCL | 0666);} int GetShm(){ return GetShareMemHelper(IPC_CREAT); } #endif processa.cc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;comm.hpp&quot; extern Log log; //由processa来管理共享内存的创建和销毁int main(){ // Init init; int shmid = CreateShm(); //创建共享内存 char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接共享内存 // ipc code 在这里！！ // 一旦有人把数据写入到共享内存，其实我们立马能看到了！！ // 不需要经过系统调用，直接就能看到数据了！ int fd = open(FIFO_FILE, O_RDONLY); // 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！ if (fd &lt; 0) { log(Fatal, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); exit(FIFO_OPEN_ERR); } // struct shmid_ds shmds; while(true) { char c; ssize_t s = read(fd, &amp;c, 1); if(s == 0) break; else if(s &lt; 0) break; cout &lt;&lt; &quot;client say@ &quot; &lt;&lt; shmaddr &lt;&lt; endl; //直接访问共享内存 sleep(1); // shmctl(shmid, IPC_STAT, &amp;shmds); // cout &lt;&lt; &quot;shm size: &quot; &lt;&lt; shmds.shm_segsz &lt;&lt; endl; // cout &lt;&lt; &quot;shm nattch: &quot; &lt;&lt; shmds.shm_nattch &lt;&lt; endl; // printf(&quot;shm key: 0x%x\\n&quot;, shmds.shm_perm.__key); // cout &lt;&lt; &quot;shm mode: &quot; &lt;&lt; shmds.shm_perm.mode &lt;&lt; endl; } //注意：只有写端先被ctrl c掉，读端才能读到0，然后break出来到这里，执行共享内存的删除 //如果读端先被ctrl c掉，那么进程会收到中断信号，程序立即终止，不会执行shmctl系统调用 shmdt(shmaddr); //取消关联 shmctl(shmid, IPC_RMID, nullptr); //删除共享内存 close(fd); return 0;} processb.cc 12345678910111213141516171819202122232425262728293031#include &quot;comm.hpp&quot; //processb直接使用即可，共享内存的创建和销毁由processa全权负责int main(){ int shmid = GetShm(); char *shmaddr = (char*)shmat(shmid, nullptr, 0); //挂接 int fd = open(FIFO_FILE, O_WRONLY); // 等待写入方打开之后，自己才会打开文件，向后执行， open 阻塞了！ if (fd &lt; 0) { log(Fatal, &quot;error string: %s, error code: %d&quot;, strerror(errno), errno); exit(FIFO_OPEN_ERR); } // 一旦有了共享内存，挂接到自己的地址空间中，你直接把他当成你的内存空间来用即可！ // 不需要调用系统调用 // ipc code while(true) { cout &lt;&lt; &quot;Please Enter@ &quot;; fgets(shmaddr, 4096, stdin); write(fd, &quot;c&quot;, 1); // 通知对方 } shmdt(shmaddr); //去掉共享内存关联 close(fd); return 0;} 2. System V消息队列2.1 消息队列基本原理 消息队列实际上就是在系统当中创建了一个队列，队列当中的每个成员都是一个数据块，这些数据块都由类型和信息两部分构成，两个互相通信的进程通过某种方式看到同一个消息队列，这两个进程向对方发数据时，都在消息队列的队尾添加数据块，这两个进程获取数据块时，都在消息队列的队头取数据块。 其中消息队列当中的某一个数据块是由谁发送给谁的，取决于数据块的类型。 总结一下： 消息队列提供了一个从一个进程向另一个进程发送数据块的方法。 每个数据块都被认为是有一个类型的，接收者进程接收的数据块可以有不同的类型值。 和共享内存一样，消息队列的资源也必须自行删除，否则不会自动清除，因为system V IPC资源的生命周期是随内核的。 2.2 消息队列数据结构​ 当然，系统当中也可能会存在大量的消息队列，系统一定也要为消息队列维护相关的内核数据结构。 消息队列的数据结构如下： 123456789101112131415struct msqid_ds { struct ipc_perm msg_perm; struct msg *msg_first; /* first message on queue,unused */ struct msg *msg_last; /* last message in queue,unused */ __kernel_time_t msg_stime; /* last msgsnd time */ __kernel_time_t msg_rtime; /* last msgrcv time */ __kernel_time_t msg_ctime; /* last change time */ unsigned long msg_lcbytes; /* Reuse junk fields for 32 bit */ unsigned long msg_lqbytes; /* ditto */ unsigned short msg_cbytes; /* current number of bytes on queue */ unsigned short msg_qnum; /* number of messages in queue */ unsigned short msg_qbytes; /* max number of bytes on queue */ __kernel_ipc_pid_t msg_lspid; /* pid of last msgsnd */ __kernel_ipc_pid_t msg_lrpid; /* last receive pid */}; 可以看到消息队列数据结构的第一个成员是msg_perm，它和shm_perm是同一个类型的结构体变量，ipc_perm结构体的定义如下： 123456789struct ipc_perm{ __kernel_key_t key; __kernel_uid_t uid; __kernel_gid_t gid; __kernel_uid_t cuid; __kernel_gid_t cgid; __kernel_mode_t mode; unsigned short seq;}; 2.3 消息队列的创建创建消息队列我们需要用msgget函数，msgget函数的函数原型如下： 1int msgget(key_t key, int msgflg); 参数接口几乎与共享内存完全相同，这里还不用传size 说明一下： 创建消息队列也需要使用ftok函数生成一个key值，这个key值作为msgget函数的第一个参数。 msgget函数的第二个参数，与创建共享内存时使用的shmget函数的第三个参数相同。 消息队列创建成功时，msgget函数返回的一个有效的消息队列标识符（用户层标识符）。 2.4 消息队列的释放释放消息队列我们需要用msgctl函数，msgctl函数的函数原型如下： 1int msgctl(int msqid, int cmd, struct msqid_ds *buf); 说明一下： msgctl函数的参数与释放共享内存时使用的shmctl函数的三个参数相同，只不过msgctl函数的第三个参数传入的是消息队列的相关数据结构 向消息队列发送数据 向消息队列发送数据我们需要用msgsnd函数，msgsnd函数的函数原型如下： 1int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); msgsnd函数的参数说明： 第一个参数msqid，表示消息队列的用户级标识符。 第二个参数msgp，表示待发送的数据块。 第三个参数msgsz，表示所发送数据块的大小 第四个参数msgflg，表示发送数据块的方式，一般默认为0即可。 msgsnd函数的返回值说明： msgsnd调用成功，返回0。 msgsnd调用失败，返回-1。 其中msgsnd函数的第二个参数必须为以下结构： 1234struct msgbuf{ long mtype; /* message type, must be &gt; 0 */ char mtext[1]; /* message data */}; 注意： 该结构当中的第二个成员mtext即为待发送的信息，当我们定义该结构时，mtext的大小可以自己指定。 2.5 从消息队列获取数据从消息队列获取数据我们需要用msgrcv函数，msgrcv函数的函数原型如下： 1ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); msgrcv函数的参数说明： 第一个参数msqid，表示消息队列的用户级标识符。 第二个参数msgp，表示获取到的数据块，是一个输出型参数。 第三个参数msgsz，表示要获取数据块的大小 第四个参数msgtyp，表示要接收数据块的类型。 msgrcv函数的返回值说明： msgsnd调用成功，返回实际获取到mtext数组中的字节数。 msgsnd调用失败，返回-1。 *消息队列不作为重点* 3. System V信号量3.1 信号量的基本概念 定义：信号量是一种用于保证两个或多个关键代码段不被并发调用的机制。线程在进入一个关键代码段之前，必须先获取一个信号量；一旦该关键代码段执行完成，线程必须释放信号量。 类型：信号量主要分为计数信号量（Counting Semaphore）和二元信号量（Binary Semaphore）或称为互斥量（Mutex）。计数信号量允许多个线程访问一定数量的资源，而二元信号量则只允许一个线程访问资源。 核心操作：信号量的核心操作包括P操作（也称为wait或down操作）和V操作（也称为signal或up操作）。P操作会使信号量的值减1，如果信号量的值已经为0，则调用线程将会被阻塞；V操作则使信号量的值加1，如果有线程因为信号量值为0而被阻塞，则这些线程会被唤醒。 123456共享内存中，如果进程A正在写入10个数字，只写了一部分，例如5个数字，此时进程B直接就拿走了这5个数字，但是这10个数字必须组合在一起才有意义，所以B拿了也没用，这就会导致数据不一致问题，即A发的数据和B收的数据不一致，这就是没有互斥的弊端。而管道就不会出现这种问题，因为管道数据有原子性1. A、B看到的同一份资源——共享资源，如果不加保护，会导致数据不一致问题2. 加锁 -- 互斥访问 -- 任何时刻只允许一个执行流访问共享资源 -- 互斥 3. 共享资源，任何时刻只允许一个执行流访问的资源——临界资源 --- 一般是内存空间4. 如果有100行代码，其中只有5-10行在访问临界资源（访问IPC资源都是代码干的），那么我们访问临界资源的代码叫做临界区 12为什么多进程在显示器上打印的数据又是是错乱的、还会和命令行混在一起？因为显示器也是被多个进程共享的共享资源，没有互斥保护所以各打各的 3.2 信号量数据结构在系统当中也为信号量维护了相关的内核数据结构。 信号量的数据结构如下： 12345678910struct semid_ds { struct ipc_perm sem_perm; /* permissions .. see ipc.h */ __kernel_time_t sem_otime; /* last semop time */ __kernel_time_t sem_ctime; /* last change time */ struct sem *sem_base; /* ptr to first semaphore in array */ struct sem_queue *sem_pending; /* pending operations to be processed */ struct sem_queue **sem_pending_last; /* last pending operation */ struct sem_undo *undo; /* undo requests on this array */ unsigned short sem_nsems; /* no. of semaphores in array */}; 信号量数据结构的第一个成员也是ipc_perm类型的结构体变量，ipc_perm结构体的定义如下： 123456789struct ipc_perm{ __kernel_key_t key; __kernel_uid_t uid; __kernel_gid_t gid; __kernel_uid_t cuid; __kernel_gid_t cgid; __kernel_mode_t mode; unsigned short seq;}; 3.3 信号量原理以停车场的运作为例，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆直接进入，然后放下车拦，剩下的车则必须在入口等待。此后来的车也都不得不在入口处等待。当有一辆车离开停车场时，看门人得知后，会打开车拦，放入外面的一辆车进去。这个过程中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用——计数信号量（Counting Semaphore） 如果此时只有一个车位，那么就表示只有一辆车能抢占位置，那么我们只需要一个值为1的计数器——二元信号量（Binary Semaphore）或称为互斥量（Mutex） 将临界资源整合，作为一个整体，此时就是互斥原理 信号量是描述临界资源中资源数量的多少，我们怕的是多个执行流（车）访问同一个资源（车位），所以引入计数器，当计数器为0时，再有执行流申请资源，就不会同意了 但是信号量计数器也是共享资源！它的目的是保护别人的安全，但是前提是它自己是安全的！ 所以信号量的申请和释放是原子的！ 123456小结：· 信号量本质是一把计数器，信号量的申请和释放（PV）操作是原子的· 执行流申请资源，必须先申请信号量资源，得到信号量之后才能访问临界资源· 信号量值为0或1两态的是二元信号量，对应互斥功能· 申请信号量的本质就是对临界资源的预定机制，就是对计数器的--，即P操作· 释放资源，释放信号量，本质是对计数器的++，即V操作 123信号量凭什么是进程通信的一种？它又不能进行通信。 · 通信不仅仅是通信数据，互相协同也算通信· 要协同本质也是通信，信号量首先要被所有的通信进程看到，即不同的进程看到同一份资源 信号量不能用来通信资源，它是来帮助通信的 3.4 信号量的优缺点 优点： 灵活性强：信号量可以用于多种同步场景，如进程同步、资源管理和死锁预防。 可扩展性：信号量可以扩展为计数信号量，用于管理多个同类型资源的并发访问。 缺点： 编程复杂度：信号量的使用需要开发者仔细设计同步逻辑，避免出现死锁、优先级反转等问题。 五、mmap系统调用mmap（内存映射文件）函数是Unix和类Unix系统（包括Linux）中用于创建内存映射文件的一个系统调用。它允许程序将文件或其他对象的内容映射到进程的地址空间，从而实现文件内容的高效访问。通过mmap，进程可以像访问内存一样访问文件内容，这可以显著提高处理大文件时的性能，因为操作系统可以更有效地管理内存和磁盘之间的数据传输。 mmap（Memory Mapped File）是将磁盘上的文件加载到内存中，并将其映射到进程的地址空间中。这种机制允许进程通过访问内存的方式（通过指针）来直接操作文件内容，而无需通过传统的系统调用如read和write来进行数据的读写操作。这样做可以显著提高文件I/O操作的效率，尤其是在处理大文件或需要频繁访问文件内容的场景下。 功能： 内存映射文件 将文件的内容映射到进程的地址空间中，使得文件内容可以通过指针直接访问。 这种方式可以提高文件读写效率，因为它减少了系统调用的开销。 匿名内存映射 创建一块匿名内存区域，通常用于分配动态内存。这块内存不与任何文件关联。 进程间通信 多个进程可以映射同一个文件或共享内存区域，从而实现进程间通信。 1. 函数原型在C语言中，mmap函数的原型定义在&lt;sys/mman.h&gt;头文件中，其基本形式如下： 123456#include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 2. 参数说明void *addr：建议的映射地址。通常设为NULL，让系统自动选择地址。size_t length：要映射的字节数。int prot：映射区域的保护方式，可以是PROT_READ（可读）、PROT_WRITE（可写）或PROT_EXEC（可执行）的位或操作。int flags：映射选项，常用的有MAP_SHARED（共享映射）和MAP_PRIVATE（私有映射）。int fd：文件描述符，表示要映射的文件。off_t offset：文件映射的偏移量，即从文件的哪个位置开始映射。 3. 返回值成功时，mmap返回指向映射区域的指针。失败时，返回MAP_FAILED（其值通常被定义为(void *)-1），并设置errno以指示错误。 4. 示例以下是一个简单的使用mmap来读取文件的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main() { int fd = open(&quot;example.txt&quot;, O_RDONLY); if (fd == -1) { perror(&quot;Error opening file&quot;); return EXIT_FAILURE; } struct stat sb; if (fstat(fd, &amp;sb) == -1) { perror(&quot;Error getting file size&quot;); close(fd); return EXIT_FAILURE; } size_t length = sb.st_size; char *map = mmap(0, length, PROT_READ, MAP_PRIVATE, fd, 0); if (map == MAP_FAILED) { close(fd); perror(&quot;Error mmapping the file&quot;); return EXIT_FAILURE; } // 假设example.txt是一个文本文件 printf(&quot;Contents of file:\\n%s&quot;, map); if (munmap(map, length) == -1) { close(fd); perror(&quot;Error un-mmapping the file&quot;); return EXIT_FAILURE; } close(fd); return EXIT_SUCCESS; } 5. 注意事项 使用完映射区域后，应使用munmap函数来取消映射。 映射的文件在进程终止时自动取消映射，但在进程生命周期内，如果不显式调用munmap或关闭文件描述符，映射会一直保持。 映射的写操作（当使用MAP_SHARED时）会直接影响磁盘上的文件内容，这可能不是所有应用场景都期望的。 四、mmap 的优点 高效性 mmap 提供了高效的文件访问方式，减少了系统调用的开销。 数据直接在内存中操作，无需通过缓冲区复制。 简单性 mmap 提供了简单的接口，使得文件操作类似于内存操作。 灵活性 支持多种保护权限和映射类型，可以根据需要选择共享或私有映射。 进程间通信 多个进程可以映射同一个文件或共享内存区域，从而实现进程间通信。 五、mmap 的缺点 复杂性 mmap 的使用相对复杂，需要理解内存映射的概念和参数。 内存管理 需要手动管理映射区域的取消映射，否则可能导致内存泄漏。 文件大小限制 映射区域的大小必须与文件大小一致，否则可能导致未定义行为","link":"/2025/01/08/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"},{"name":"学术","slug":"学术","link":"/tags/%E5%AD%A6%E6%9C%AF/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Kunpeng","slug":"Kunpeng","link":"/tags/Kunpeng/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Games101","slug":"Games101","link":"/tags/Games101/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Leetcode","slug":"算法/Leetcode","link":"/categories/%E7%AE%97%E6%B3%95/Leetcode/"},{"name":"学术","slug":"学术","link":"/categories/%E5%AD%A6%E6%9C%AF/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Kunpeng","slug":"Kunpeng","link":"/categories/Kunpeng/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"3DGS","slug":"学术/3DGS","link":"/categories/%E5%AD%A6%E6%9C%AF/3DGS/"},{"name":"三维重建","slug":"学术/三维重建","link":"/categories/%E5%AD%A6%E6%9C%AF/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"},{"name":"命令","slug":"学术/命令","link":"/categories/%E5%AD%A6%E6%9C%AF/%E5%91%BD%E4%BB%A4/"},{"name":"NeRF","slug":"学术/NeRF","link":"/categories/%E5%AD%A6%E6%9C%AF/NeRF/"},{"name":"Limb","slug":"Kunpeng/Limb","link":"/categories/Kunpeng/Limb/"},{"name":"App","slug":"Linux/App","link":"/categories/Linux/App/"},{"name":"Game","slug":"Game","link":"/categories/Game/"},{"name":"Games101","slug":"Game/Games101","link":"/categories/Game/Games101/"}],"pages":[{"title":"关于作者","text":"这里是 骨頭 的博客访客你好，博主是一名计算机系普通的研究生，研究方向是三维重建，参与过华为鲲鹏众智计划（加速库相关），同时也对昇腾（CANN算子)及华为云社区有一定了解。 这个博客当前主要是用来记录博主自己的学习情况，上传了一部分可供分享的学习笔记，大家对于感兴趣的内容也可以自行查看，如有疑问可通过邮箱或QQ与我联系。 博主当前的主要学习方向为Linux应用及驱动开发，同时在对新能源汽车和人形机器人两个行业进行深入了解，期望硕士毕业之后在汽车电子或人形机器人行业内工作，如有志同道合的朋友想一起报团学习也可与我联系！","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}