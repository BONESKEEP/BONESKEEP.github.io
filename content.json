{"posts":[{"title":"Leetcode","text":"Leetcode 练习 Easy = E Middle = M E 1.两数之和 2024.3.26 方法一：暴力枚举 两个循环搞定 注意用malloc先分配好空间 int* ret = malloc(sizeof(int)*2); 时间O(N^2^) 空间O(1) ！！！方法二：哈希表 用于方法一的时间复杂度过高——寻找匹配元素 创建一个哈希表，对于每一个x，先查询表中是否存在target-x，再将x插入到表中，保证不会让x与自己匹配 E 9.回文数 2024.3.27 方法一：将数字划分为各个单个数进行循环判断； 常规解法：1.先将数字划分为单个数存入数组，while循环加静态数组；2.循环进行判断，注意循环次数；3.可使用动态数组以防止overflow。 方法二：将其转换为字符串数组，直接进行数组元素的相等判断。循环次数到n/2即可。 E 13.罗马数字转整数 2024.3.29 方法一：字符串的转化 找规律 建立转化表 再进行数字判断并累加 出现了问题“如何建立一个转换表” “switch函数的参数是否能输入多字符结构（字符串）” E 14.最长公共前缀 2024.3.30 指针与字符串——文言一心 指针的定义与类型 char* 是一个指向字符的指针。 char** 或 char* * 是一个指向字符指针的指针，通常用于存储字符串数组。 数组与指针 ： 当有一个字符串数组（如 char* strs[]），strs 是一个指向该数组第一个元素的指针，即 strs 的类型是 char**。 strs[i] 表示数组中的第 i 个字符串，它的类型是 char*。 解引用指针 ： 使用 * 运算符可以解引用指针，获取指针所指向的值。例如，*strs[0] 获取 strs 数组中第一个字符串的第一个字符。 printf 函数与格式说明符 ： %s：用于输出以空字符结尾的字符串。 %d：用于输出整数。 %c：用于输出单个字符。 %p：用于输出指针的地址，通常需要将指针转换为 void* 类型。 字符串与地址的输出 ： 直接使用 printf(&quot;%s\\n&quot;, strs[i]) 可以输出 strs 数组中第 i 个字符串的内容。 使用 printf(&quot;%p\\n&quot;, (void*)strs[i]) 可以输出 strs 数组中第 i 个字符串的地址（即指针的值）。 指针与整数的区别 ： 指针存储的是内存地址，而整数存储的是数值。 错误的格式说明符可能导致输出无意义的结果或未定义的行为。 方法一：横向扫描 依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串（对比其各个字符是否相等），更新最长公共前缀，当遍历完所有字符串后，即可得到最长公共前缀。 对比其各个字符是否相等——strs[i][j]==prefix[j] prefix为存储当前最长公共前缀的字符串 如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。 if(prefixLength == 0) 方法二：纵向扫描 纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。 具体思路：把第一个字符先拿出来（循环1），然后依次用用数值的相应字符与其比较（strs[0][i] != strs[j][i]）（循环2），然后判断是否相同，如果有一个字符不同则将这个字符赋’\\0’，然后将新的数组赋给strs[0]，然后return 新的strs[0]; **注意：此方法会更改strs[0]原本的值 如果此变量之后还具有价值的话 会导致值被更改 ** 最好的方法是动态分配一块内存用于存储公共前缀的值，记得在返回后free掉， 除此之外，如果不想使用动态分配的话，可以再传入函数参数时，多传入一个具有足够大空间的静态缓冲区， 因为在函数内部定义的缓冲区是局部变量，会在结束后被释放，所以不能用于返回，返回会为一个null E 20.有效的括号 栈 2024.3.31 括号的正确匹配问题 用到了数据结构——栈 使用栈来跟踪尚未匹配的打开括号 遍历输入字符串：对于字符串中的每个字符，我们检查它是打开括号还是闭合括号。 处理打开括号：如果遇到打开括号（如(、[、{），我们将其压入栈中，表示这个括号尚未找到匹配的闭合括号。 处理闭合括号：如果遇到闭合括号（如)、]、}），我们检查栈顶的元素是否是与之匹配的打开括号。如果是，则从栈中弹出该元素，表示找到了匹配的括号对；如果不是或栈为空，则说明括号无效。 检查栈是否为空：在遍历完整个字符串后，如果栈为空，说明所有的打开括号都找到了匹配的闭合括号，因此括号组合是有效的；如果栈不为空，则说明还有未匹配的打开括号，括号组合无效。 这种算法思想利用了栈的后进先出（LIFO）特性，非常适合处理这种需要匹配成对出现元素的问题。在遍历字符串的过程中，我们只需要维护一个栈，就可以高效地判断括号是否有效。 注意栈的定义与初始化 char* stack = (char*)malloc(strlen(s) * sizeof(char)); 其中因为malloc函数的返回值为void*类型 所以要进行类型转换 int top = -1；这是栈顶指针 初始化为-1 表示栈空 元素入栈时，stack[++top] = s[i]；栈顶指针要自增 再压入栈中 元素出栈时，pop = stack[top–]; 出栈时要先取值再自减 不然取到的值是栈顶第二个元素 E 21.合并两个有序链表 2024.3.29 方法一：双指针遍历 创建一个新链表进行存储合并后的链表 创建链表结点的问题 如果此结点需要存储信息，则要malloc分配空间 如果此结点/指针仅仅用来遍历，则不需要分配空间 注意断链问题 可能需要一个指针防止断链 防止内存泄漏问题 动态分配内存malloc后记得free掉 E 26.删除有序数组中的重复项 2024.4.1 不能使用临时数组存储不需要考虑其他元素 只考虑返回唯一的元素需要记录元素覆盖的位置 思想：定义一个变量pos初始化为1，即时更新 表示当前插入的数组位置，最后可以当作nums的唯一元素数量返回 E 27.移除元素 2024.4.2 原地删除 给一串数字，用两个循环遍历，第一个循环找出对应值的元素，第二个循环从对应值开始向后遍历，找不等于对应值的元素，找到后赋值到第一个循环找到的位置，然后直接退出第二个循环，再如此进入第一个循环继续遍历。 E 28.找出字符串中第一个匹配项的下标 2024.4.3 给了两个字符串，在第一个字符串中找到第二个字符串的第一个匹配项的下标，未匹配到就返回-1。 思想：用双循环，第一个循环遍历第一个字符串，每次从一个字符开始，用第二个循环和第二个字符串匹配，如果不匹配就从第一个字符串的下一个字符开始继续匹配，直到第一个字符串全部遍历结束。 E 35.搜索插入位置 二分查找 2024.4.4 规定了时间复杂度 用二分查找 规定中间值与目标值进行对比，不等时从两侧查找，当前后两个位置值顺序反转或相等时退出循环 要注意整数溢出问题 C或C++中，整数值过大时直接相加会导致整数溢出，此时可以用如下方法： first + (last - first) / 2 等价于 (first + last) / 2 E 70.爬楼梯 动态规划 2024.3.25 方法一：每次爬1或2层 找规律可得递推公式 递归解决 方法二 C++：为了节省时间 记忆化递归 用memo数组记录计算结果 如果已经计算过就直接返回memo中的结果 保证每个结点只计算一次 方法三：动态规划算法 记录n个状态，从1到n依次更新 只记录其中用到的两个状态 可以优化时间复杂度到O(1) 方法四：滚动数组 每次状态更新后 把状态2移到状态1的位置 状态3移到状态2的位置 状态整体向前滚动一位 E 94.二叉树的中序遍历 2024.4.19 递归 由于是左中右的遍历顺序 所以遍历当前节点前要先遍历左子树 遍历当前节点后遍历右子树 迭代 二叉树中序遍历的迭代法，相比较递归法就是显式地维护了一个栈 用数组保存中序遍历 用栈来遍历节点 当根结点不为空且栈不空时 说明树没遍历完 进入循环遍历 用循环将当前节点和所有左子节点压入栈中 全部压入栈中后，再取栈顶元素，出栈，加入结果数组，然后遍历当前结点的右子树 最后返回结果数组 E 104.二叉树的最大深度 2024.4.22 深度优先搜索 递归 当前树的深度 = max（左子树深度 + 右子树深度） + 1 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。 广度优先搜索 迭代 队列 按层数进行节点的遍历，定义一个队列用来存储当前层的节点，遍历节点时，注意其左右孩子节点，如果存在就入队，再进行队列中下一个节点的遍历和操作，每遍历完一层结点（一次循环），记录（h++），最后的遍历层数就是最大深度。 时间复杂度：O(n)。 空间复杂度：O(n)，最大要遍历所有元素n个。 E 118.杨辉三角 2024.4.11 迭代/递归 迭代 先定义一个二维数组，初始化第一第二行，从第三行开始循环算：一行一行初始化一个辅助vector存储当前行的元素，用一个循环计算中间元素，最后将当前行的元素push_back进二位数组中 递归 先确定边界条件0和1，在递归调用生成前numRows-1行，此时会只剩当前行没生成，和迭代相同，创建当前行，使用一个辅助数组存储当前行元素，初始化第一和最后一个元素为1，在计算中间元素，最后将当前行加入整个二维数组中 back()的问题 vec.back()用来返回最后一个元素 vec2D.back()[i] 用来返回一个二维数组的最后一行的第i个元素 E 136.只出现一次的数字 2024.4.10 需要使用异或运算 异或运算的性质： 任何数和0做异或运算，结果仍然是原来的数，即 a ^ 0 = a。 任何数和其自身做异或运算，结果是0，即 a ^ a = 0。 异或运算满足交换律和结合律，即 a ^ b ^ a = b ^ (a ^ a) = b ^ 0 = b。 除了一个元素只出现一次以外，其余每个元素都出现两次。 那么，如果我们对数组中的所有元素进行异或操作，那些出现两次的元素会两两抵消（因为 a ^ a = 0），最后剩下的就是只出现一次的元素。 E 141.环形链表 2024.4.13 判断环 快慢指针判断环 E 160.相交链表 双指针 2024.4.6 方法一：双指针 1.写一个求链表元素的函数2.双指针遍历 比较指针(比较指针所指的值时可能会重复 指针是唯一的)3.遍历前操作：先让链表更长的指针先走 时间复杂度:O*(m+n) 空间复杂度:O*(1) 方法二：循环遍历 用指针实现循环链表 两个指针走了相同距离必定相遇 12345678910111213struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { //定义指针p,q,当两个指针走了相同距离必定相遇 struct ListNode *p = headA; struct ListNode *q = headB; while(p != q) { p = p ? p-&gt;next : headB; q = q ? q-&gt;next : headA; } return p;} 方法三：哈希集合 E 169.多数元素 跟踪者/计数器 摩尔投票算法（Boyer–Moore Voting Algorithm） 这个算法的基本思想是在遍历数组时，用一个变量 count 来记录当前候选众数的出现次数，用另一个变量 candidate 来记录当前的候选众数。如果当前元素与candidate相等，则count++；否则count–。count==0时，更新此时candidate= 当前元素。 这样做由于是多数元素，最终的count一定会是正数，而多数元素就是此时candidate记录的元素。 E 206.反转链表 2024.4.7 逐个翻转结点法 初始化两个指针，一个指向当前节点（prev），另一个指向下一个节点（curr）。 将prev初始化为NULL，curr初始化为head。 遍历链表，每次迭代将curr的next指针指向prev，然后移动prev和curr到下一个位置。 当curr为NULL时，遍历结束，此时prev就是反转后的头节点。 头结点的问题 一般提到头结点head时，可以将其理解为指向第一个结点的指针 所以head-&gt;val=第一个结点的值 head-&gt;next=第二个结点 递归解法 主要关键在于反向工作 用C++解决 构造函数 1234567struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {}}; ListNode() : val(0), next(nullptr) {} 这是ListNode的默认构造函数。当你创建一个ListNode对象而不提供任何参数时，这个构造函数会被调用。它将val初始化为0，并将next初始化为nullptr（即空指针）； 以此类推，如果传入int x 或 int x与一个next指针，则会调用相应的构造函数 解法 M 215.数组中的第k个最大元素 2024.4.14 1.快速选择2.堆排序3.先排序后直接返回 一般用这个就够了根据快速排序算法的快速选择算法，在划分之后，如果枢轴元素正好是第k个，就找到了目标值，如果k在枢轴元素左边，则向左递归划分，否则向右递归划分。需要重点掌握的算法：划分、快排 划分 快排 E 226. 翻转二叉树 2024.4.23 递归 递归交换 只需要声明两个指针，用于递归地翻转左右子树，再进行交换，交换时直接交换节点而不是节点的值 时间和空间都是O(n) E 283.移动零 双指针 2024.4.5 双指针 一个指针遍历整个数组找非0值 一个指针标记0的位置（即要插入的位置）用非0值覆盖0值的位置 E 543.二叉树的直径 2024.6.6 这道题主要搞清楚几点：1.深度优先遍历 需要用其来计算深度 深度=max（左儿子深度，右儿子深度）+ 12.路径长度 = 根结点左右儿子的深度之和3.最长路径长度 用一个MAX来在计算深度时顺便记录 计算完左右孩子的深度时进行更新4.用到一个class内的局部变量MAX 只需定义一次5.注意：MAX是求深度depth时顺便记录的 depth返回的是深度 最长路径是MAX","link":"/2024/12/03/Leetcode/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/12/03/hello-world/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","link":"/tags/Leetcode/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于作者","text":"这里是BONESKEEP的博客","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}